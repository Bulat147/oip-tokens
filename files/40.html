<!doctype html>
<html lang="ru">
 <head>
  <title>Как на самом деле хранятся изображения? / Хабр</title>
  <meta property="fb:app_id" content="444736788986613">
  <meta property="fb:pages" content="472597926099084">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@habr_com">
  <meta property="og:site_name" content="Хабр">
  <link href="https://habr.com/ru/rss/post/906964/?fl=ru" type="application/rss+xml" title rel="alternate" name="rss">
  <link href="https://habr.com/ru/companies/sravni/articles/906964/" rel="canonical" data-hid="e3fa780">
  <link rel="image_src" href="https://habrastorage.org/getpro/habr/upload_files/c9d/b2d/c46/c9db2dc468e3c319b54d1ad8599f8898.jpg" data-hid="2a79c45">
  <link rel="amphtml" href="https://habr.com/ru/amp/publications/906964/">
  <meta property="og:title" content="Как на самом деле хранятся изображения?">
  <meta name="twitter:title" content="Как на самом деле хранятся изображения?">
  <meta name="aiturec:title" content="Как на самом деле хранятся изображения?">
  <meta name="description" content="Этот пост — погружение в кроличью нору. Разработчик Монсеф Аббад задумался о изображениях — вероятно, после недавнего изучения им некоторых схем компрессии. Общеизвестно, что изображения бывают либо...">
  <meta itemprop="description" content="Этот пост — погружение в кроличью нору. Разработчик Монсеф Аббад задумался о изображениях — вероятно, после недавнего изучения им некоторых схем компрессии. Общеизвестно, что изображения бывают либо...">
  <meta property="og:description" content="Этот пост — погружение в кроличью нору. Разработчик Монсеф Аббад задумался о изображениях — вероятно, после недавнего изучения им некоторых схем компрессии. Общеизвестно, что изображения бывают либо...">
  <meta name="twitter:description" content="Этот пост — погружение в кроличью нору. Разработчик Монсеф Аббад задумался о изображениях — вероятно, после недавнего изучения им некоторых схем компрессии. Общеизвестно, что изображения бывают либо...">
  <meta property="aiturec:description" content="Этот пост — погружение в кроличью нору. Разработчик Монсеф Аббад задумался о изображениях — вероятно, после недавнего изучения им некоторых схем компрессии. Общеизвестно, что изображения бывают либо...">
  <meta itemprop="image" content="https://habrastorage.org/getpro/habr/upload_files/c9d/b2d/c46/c9db2dc468e3c319b54d1ad8599f8898.jpg">
  <meta property="og:image" content="https://habrastorage.org/getpro/habr/upload_files/c9d/b2d/c46/c9db2dc468e3c319b54d1ad8599f8898.jpg">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="aiturec:image" content="https://habrastorage.org/getpro/habr/upload_files/c9d/b2d/c46/c9db2dc468e3c319b54d1ad8599f8898.jpg">
  <meta name="twitter:image" content="https://habrastorage.org/getpro/habr/upload_files/c9d/b2d/c46/c9db2dc468e3c319b54d1ad8599f8898.jpg">
  <meta property="vk:image" content="https://habrastorage.org/getpro/habr/upload_files/c9d/b2d/c46/c9db2dc468e3c319b54d1ad8599f8898.jpg?format=vk">
  <meta property="vk:image" content="https://habrastorage.org/getpro/habr/upload_files/c9d/b2d/c46/c9db2dc468e3c319b54d1ad8599f8898.jpg?format=vk">
  <meta property="aiturec:item_id" content="906964">
  <meta property="aiturec:datetime" content="2025-05-06T11:47:10.000Z">
  <meta content="https://habr.com/ru/companies/sravni/articles/906964/" property="og:url">
  <meta property="og:type" content="article">
  <meta property="og:locale" content="ru_RU">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta name="keywords" content="jpeg, png, gif, golang, изображения, go, картинки">
  <script type="application/ld+json" data-hid="1e0f0a2">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/companies\/sravni\/articles\/906964\/"},"headline":"Как на самом деле хранятся изображения?","datePublished":"2025-05-06T14:47:10+03:00","dateModified":"2025-05-07T00:14:25+03:00","author":{"@type":"Person","name":"Sravni_Tech"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Этот пост &mdash; погружение в кроличью нору. Разработчик Монсеф Аббад задумался о изображениях &mdash; вероятно, после недавнего изучения им некоторых схем компрессии. Обще...","url":"https:\/\/habr.com\/ru\/companies\/sravni\/articles\/906964\/#post-content-body","about":["c_sravni","h_go","h_programming","h_image_processing","f_develop"],"image":["https:\/\/habr.com\/share\/publication\/906964\/250754799c5c4233d05b4de23c29dd58\/","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/cd5\/f36\/c82\/cd5f36c82acd0a23a6e25dc2f8785b41.jpg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/1a7\/ed6\/521\/1a7ed652160402b799d4121884ea8648.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/340\/53d\/973\/34053d9735f43dc00fc27c27074e7179.jpg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/2e0\/b3c\/b52\/2e0b3cb525620acc688b87f5a39940cb.gif","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/5c7\/f05\/d2d\/5c7f05d2d5c4dd3eab5848bcbd8e04f3.gif","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/1d1\/907\/ed6\/1d1907ed6d1adef2f9d47bd249658993.png","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/b\/bf\/bf3\/bf38f5a536aeb76b2b417069a2a8d9ba.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/ec5\/c0e\/eeb\/ec5c0eeebf57605c976be679d83baf05.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/e\/e4\/e45\/e459c803c13c363f7bd03e9d332e9119.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/b1e\/55d\/6d0\/b1e55d6d0a5df517246250eb504dca6c.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/c9d\/b2d\/c46\/c9db2dc468e3c319b54d1ad8599f8898.jpg"]}</script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover,maximum-scale=1,user-scalable=0">
  <meta name="referrer" content="unsafe-url">
  <style>
      /* cyrillic-ext */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 400;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9E4kDNxMZdWfMOD5VvmojLazX3dGTP.woff2) format('woff2');
        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
      }

      /* cyrillic */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 400;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9E4kDNxMZdWfMOD5Vvk4jLazX3dGTP.woff2) format('woff2');
        unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
      }

      /* latin-ext */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 400;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9E4kDNxMZdWfMOD5VvmYjLazX3dGTP.woff2) format('woff2');
        unicode-range: U+0100-02AF, U+0304, U+0308, U+0329, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
      }

      /* latin */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 400;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9E4kDNxMZdWfMOD5Vvl4jLazX3dA.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
      }

      /* cyrillic-ext */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 500;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnZKveSxf6Xl7Gl3LX.woff2) format('woff2');
        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
      }

      /* cyrillic */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 500;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnZKveQhf6Xl7Gl3LX.woff2) format('woff2');
        unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
      }

      /* latin-ext */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 500;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnZKveSBf6Xl7Gl3LX.woff2) format('woff2');
        unicode-range: U+0100-02AF, U+0304, U+0308, U+0329, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
      }

      /* latin */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 500;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnZKveRhf6Xl7Glw.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
      }

      /* cyrillic-ext */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 700;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnLK3eSxf6Xl7Gl3LX.woff2) format('woff2');
        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
      }

      /* cyrillic */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 700;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnLK3eQhf6Xl7Gl3LX.woff2) format('woff2');
        unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
      }

      /* latin-ext */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 700;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnLK3eSBf6Xl7Gl3LX.woff2) format('woff2');
        unicode-range: U+0100-02AF, U+0304, U+0308, U+0329, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
      }

      /* latin */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 700;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnLK3eRhf6Xl7Glw.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
      }
    </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/theme/light-v1.css" as="style" media="(prefers-color-scheme: light)">
  <link rel="preload" href="https://assets.habr.com/habr-web/css/theme/dark-v1.css" as="style" media="(prefers-color-scheme: dark)">
  <link id="light-colors" rel="stylesheet" href="https://assets.habr.com/habr-web/css/theme/light-v1.css" media="(prefers-color-scheme: light)">
  <link id="dark-colors" rel="stylesheet" href="https://assets.habr.com/habr-web/css/theme/dark-v1.css" media="(prefers-color-scheme: dark)">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.635b6c39236ebd33fa716c71ab0131a0.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  <style>
      .grecaptcha-badge {
        visibility: hidden;
      }
    </style>
  <meta name="habr-version" content="2.241.0">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" type="image/png" sizes="16x16" href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png">
  <link rel="shortcut icon" type="image/png" sizes="32x32" href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png">
  <link rel="apple-touch-icon" type="image/png" sizes="76x76" href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png">
  <link rel="apple-touch-icon" type="image/png" sizes="120x120" href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png">
  <link rel="apple-touch-icon" type="image/png" sizes="152x152" href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png">
  <link rel="apple-touch-icon" type="image/png" sizes="180x180" href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png">
  <link rel="apple-touch-icon" type="image/png" sizes="256x256" href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)" href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)" href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)" href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)" href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)" href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)" href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png">
  <link rel="mask-icon" color="#77a2b6" href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg">
  <link crossorigin="use-credentials" href="/manifest.webmanifest" rel="manifest">
  <script async src="https://unpkg.com/pwacompat" crossorigin="anonymous"></script>
  <script>window.yaContextCb = window.yaContextCb || []</script>
  <script src="https://yandex.ru/ads/system/context.js" async></script>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.04465f7c.css" as="style">
  <link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.978df117.js" as="script">
  <link rel="preload" href="https://assets.habr.com/habr-web/css/app.8599692f.css" as="style">
  <link rel="preload" href="https://assets.habr.com/habr-web/js/app.58b8c457.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.04465f7c.css">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.8599692f.css">
 </head>
 <body>
  <div id="mount">
   <div id="app">
    <div class="tm-layout__wrapper">
     <!--[--><!---->
     <div></div><!---->
     <header class="tm-header" data-test-id="header">
      <div class="tm-page-width">
       <!--[-->
       <div class="tm-header__container">
        <!----><span class="tm-header__logo-wrap"><a class="tm-header__logo tm-header__logo_hl-ru tm-header__logo" href="/ru/">
          <svg class="tm-svg-img tm-header__icon" height="16" width="16">
           <title>
            Хабр
           </title><use xlink:href="/img/habr-logo-ru.svg#logo"></use>
          </svg></a><span style="display:none;" class="tm-header__beta-sign">β</span></span><!--[-->
        <div class="tm-dropdown tm-header__projects">
         <div class="tm-dropdown__head">
          <!--[-->
          <button class="tm-header__dropdown-toggle">
           <svg class="tm-svg-img tm-header__icon tm-header__icon_dropdown" height="16" width="16">
            <title>
             Открыть список
            </title><use xlink:href="/img/megazord-v28.7909a852..svg#arrow-down"></use>
           </svg></button><!--]-->
         </div><!---->
        </div><a href="/ru/sandbox/start/" class="tm-header__become-author-btn">Как стать автором</a>
        <div class="tm-feature tm-feature tm-feature_variant-inline tm-header__feature">
         <!---->
        </div><!----><!--]--><!---->
       </div><!--]-->
      </div>
     </header>
     <div class="tm-layout">
      <div class="tm-page-progress-bar"></div>
      <div class="tm-base-layout__header_is-sticky tm-base-layout__header" data-menu-sticky="true">
       <div class="tm-page-width">
        <!--[-->
        <div class="tm-base-layout__header-wrapper">
         <div class="tm-main-menu">
          <div class="tm-main-menu__section">
           <nav class="tm-main-menu__section-content">
            <!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/feed/">Моя лента</a><!--]--><!--[--><a class="tm-main-menu__item" href="/ru/articles/">Все потоки</a><!--]--><!--[--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/develop/">Разработка</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/admin/">Администрирование</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/design/">Дизайн</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/management/">Менеджмент</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/marketing/">Маркетинг</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/popsci/">Научпоп</a><!--]--><!--]-->
           </nav>
          </div>
         </div>
         <div class="tm-header-user-menu tm-base-layout__user-menu">
          <a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search" data-test-id="search-button">
           <svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark" height="24" width="24">
            <title>
             Поиск
            </title><use xlink:href="/img/megazord-v28.7909a852..svg#search"></use>
           </svg></a><!----><!---->
          <div class="tm-header-user-menu__item tm-header-user-menu__write">
           <div>
            <svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_write tm-header-user-menu__icon_dark" height="24" width="24">
             <title>
              Написать публикацию
             </title><use xlink:href="/img/megazord-v28.7909a852..svg#write"></use>
            </svg>
           </div><!---->
          </div><!--[-->
          <div class="tm-header-user-menu__item">
           <button class="tm-header-user-menu__toggle" data-test-id="user-menu-settings">
            <svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_dark" height="24" width="24">
             <title>
              Настройки
             </title><use xlink:href="/img/megazord-v28.7909a852..svg#page-settings"></use>
            </svg></button>
          </div><a href="https://habr.com/kek/v1/auth/habrahabr/?back=/ru/companies/sravni/articles/906964/&amp;hl=ru" rel="nofollow" class="tm-header-user-menu__item"><!--[-->
           <button class="btn btn_solid btn_small tm-header-user-menu__login" type="button"><!--[-->Войти<!--]--></button><!--]--></a><!--]--><!----><!--teleport start--><!--teleport end--><!---->
         </div>
        </div><!--]-->
       </div>
      </div><!---->
      <div class="tm-page-width">
       <!--[--><!--]-->
      </div>
      <main class="tm-layout__container">
       <div class="tm-page" hl="ru" companyname="sravni" data-async-called="true" style="--5ab2e5a8:16px;--44c4f6f6:100%;--45ba7a3b:0;">
        <div class="tm-page-width">
         <!--[-->
         <div class="tm-page__header">
          <!--[--><!--]-->
         </div>
         <div class="tm-page__wrapper">
          <div class="tm-page__main_has-sidebar tm-page__main">
           <div class="pull-down">
            <!---->
            <div class="pull-down__header" style="height:0px;">
             <div class="pull-down__content" style="bottom:10px;">
              <svg class="tm-svg-img pull-down__icon pull-down__arrow" height="24" width="24">
               <title>
                Обновить
               </title><use xlink:href="/img/megazord-v28.7909a852..svg#pull-arrow"></use>
              </svg>
             </div>
            </div><!--[--><!--[-->
            <div class="tm-article-presenter">
             <!--[--><!--[--><!---->
             <div class="tm-company-profile-card tm-company-article__profile-card">
              <div class="tm-company-card tm-company-profile-card__info">
               <div class="tm-company-card__header">
                <a href="/ru/companies/sravni/profile/" class="tm-company-card__avatar">
                 <div class="tm-entity-image">
                  <img alt="" class="tm-entity-image__pic" height="48" src="//habrastorage.org/getpro/habr/company/1cd/7c2/e10/1cd7c2e105e5f65ce3c80c6d03495ea3.png" width="48">
                 </div></a><!--[--><a class="tm-grade tm-company-card__rating" href="https://career.habr.com/companies/sravni" rel="noopener" target="_blank">
                 <div class="tm-counter-container">
                  <div class="tm-counter-container__header">
                   <!--[--><!--[-->
                   <svg class="tm-svg-img tm-svg-grade__icon" height="18" width="18">
                    <title>
                     Оценка компании на Хабр Карьере
                    </title><use xlink:href="/img/megazord-v28.7909a852..svg#grade"></use>
                   </svg><!--]-->
                   <div class="tm-votes-lever tm-votes-lever tm-votes-lever_appearance-grade">
                    <!---->
                    <div class="tm-votes-lever__score tm-votes-lever__score_appearance-grade tm-votes-lever__score">
                     <!--[--><span><span class="tm-votes-lever__score-counter tm-votes-lever__score-counter_grade tm-votes-lever__score-counter" data-test-id="votes-score-counter">4.57</span></span><!--]-->
                    </div><!---->
                   </div><!--]-->
                  </div>
                  <div class="tm-counter-container__footer">
                   <!--[--><span class="tm-rating__text tm-rating__text_variant-grade tm-rating__text">Оценка</span><!--]-->
                  </div>
                 </div></a>
                <div class="tm-counter-container tm-company-card__rating">
                 <div class="tm-counter-container__header">
                  <!--[--><!--[--><!--]-->
                  <div class="tm-votes-lever tm-votes-lever tm-votes-lever_appearance-rating">
                   <!---->
                   <div class="tm-votes-lever__score tm-votes-lever__score_appearance-rating tm-votes-lever__score">
                    <!--[--><span><span class="tm-votes-lever__score-counter tm-votes-lever__score-counter_rating tm-votes-lever__score-counter" data-test-id="votes-score-counter">78.5</span></span><!--]-->
                   </div><!---->
                  </div><!--]-->
                 </div>
                 <div class="tm-counter-container__footer">
                  <!--[--><span class="tm-rating__text tm-rating__text">Рейтинг</span><!--]-->
                 </div>
                </div><!----><!--]-->
               </div>
               <div class="tm-company-card__info">
                <a href="/ru/companies/sravni/profile/" class="tm-company-card__name"><span>Сравни</span></a><!---->
               </div>
              </div>
              <div class="tm-company-profile-card__buttons">
               <div class="tm-button-follow tm-company-profile-card__button tm-company-profile-card__button_follow">
                <!---->
                <button class="tm-button-follow__button tm-button-follow__button_big" data-test-id="follow-button" type="button">Подписаться</button>
               </div><!----><!----><!---->
              </div>
             </div><!----><!--]--><!--]-->
             <div class="tm-article-presenter__body" data-test-id="article-body">
              <div class="tm-misprint-area">
               <div class="tm-misprint-area__wrapper">
                <!--[-->
                <article class="tm-article-presenter__content tm-article-presenter__content_narrow">
                 <!--[-->
                 <div class="tm-article-presenter__header">
                  <!--[--><!--]-->
                  <div class="tm-article-snippet tm-article-snippet tm-article-presenter__snippet">
                   <!--[--><!--]-->
                   <div class="tm-article-snippet__meta-container">
                    <div class="tm-article-snippet__meta">
                     <span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/Sravni_Tech/" class="tm-user-info__userpic" data-test-id="user-info-pic" title="Sravni_Tech">
                       <div class="tm-entity-image">
                        <img alt="" class="tm-entity-image__pic" height="24" src="//habrastorage.org/r/w48/getpro/habr/avatars/792/688/0ad/7926880ade16dd9cb3033561888f4093.png" width="24">
                       </div></a><span class="tm-user-info__user tm-user-info__user_appearance-default" data-test-id="user-info-description"><a href="/ru/users/Sravni_Tech/" class="tm-user-info__username">Sravni_Tech <!----></a><!--[--><span class="tm-article-datetime-published"><time datetime="2025-05-06T11:47:10.000Z" title="2025-05-06, 14:47">18 часов назад</time></span><!--]--></span></span>
                    </div><!---->
                   </div>
                   <h1 class="tm-title tm-title_h1" lang="ru" data-test-id="articleTitle"><span>Как на самом деле хранятся изображения?</span></h1>
                   <div class="tm-article-snippet__stats" data-test-id="articleStats">
                    <!---->
                    <div class="tm-article-reading-time">
                     <span class="tm-svg-icon__wrapper tm-article-reading-time__icon">
                      <svg class="tm-svg-img tm-svg-icon" height="24" width="24">
                       <title>
                        Время на прочтение
                       </title><use xlink:href="/img/megazord-v28.7909a852..svg#clock"></use>
                      </svg></span><span class="tm-article-reading-time__label">29 мин</span>
                    </div><span class="tm-icon-counter tm-data-icons__item">
                     <svg class="tm-svg-img tm-icon-counter__icon" height="24" width="24">
                      <title>
                       Количество просмотров
                      </title><use xlink:href="/img/megazord-v28.7909a852..svg#counter-views"></use>
                     </svg><span class="tm-icon-counter__value" title="2974">3K</span></span>
                   </div>
                   <div class="tm-publication-hubs__container" data-test-id="articleHubsList">
                    <div class="tm-publication-hubs">
                     <!--[--><span class="tm-publication-hub__link-container"><a href="/ru/companies/sravni/articles/" class="tm-publication-hub__link"><!--[--><span>Блог компании Сравни</span><!----><!--]--></a></span><span class="tm-publication-hub__link-container"><a href="/ru/hubs/go/" class="tm-publication-hub__link"><!--[--><span>Go</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><span class="tm-publication-hub__link-container"><a href="/ru/hubs/programming/" class="tm-publication-hub__link"><!--[--><span>Программирование</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><span class="tm-publication-hub__link-container"><a href="/ru/hubs/image_processing/" class="tm-publication-hub__link"><!--[--><span>Обработка изображений</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><!--]-->
                    </div>
                   </div>
                   <div class="tm-article-labels" data-test-id="articleLabels">
                    <div class="tm-article-labels__container">
                     <!----><!--[-->
                     <div class="tm-publication-label tm-publication-label_variant-translation">
                      <span>Перевод</span>
                     </div><!--]-->
                    </div>
                   </div><!----><!---->
                  </div>
                 </div><!--[-->
                 <div class="tm-article-presenter__origin">
                  <a class="tm-article-presenter__origin-link" href="https://cefboud.com/posts/image-formats/" target="_blank">Автор оригинала: <span>Moncef Abboud</span></a>
                 </div>
                 <div class="tm-article-body" data-gallery-root lang="ru">
                  <div>
                   <!--[--><!--]-->
                  </div>
                  <div id="post-content-body">
                   <div>
                    <div class="article-formatted-body article-formatted-body article-formatted-body_version-2">
                     <div xmlns="http://www.w3.org/1999/xhtml">
                      <figure class="full-width ">
                       <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/cd5/f36/c82/cd5f36c82acd0a23a6e25dc2f8785b41.jpg" width="1920" height="1080" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/getpro/habr/upload_files/cd5/f36/c82/cd5f36c82acd0a23a6e25dc2f8785b41.jpg 780w,
       https://habrastorage.org/r/w1560/getpro/habr/upload_files/cd5/f36/c82/cd5f36c82acd0a23a6e25dc2f8785b41.jpg 781w" loading="lazy" decode="async">
                      </figure>
                      <p>Этот пост — погружение в кроличью нору. Разработчик Монсеф Аббад задумался о изображениях — вероятно, после <a href="https://cefboud.com/posts/compression/">недавнего изучения</a> им некоторых схем компрессии. Общеизвестно, что изображения бывают либо полутоновыми, либо RGB, когда новые цвета создаются на основе смешения красного, зелёного и синего. Но для хранения изображения требуется нечто большее, чем просто выравнивание трехбайтовых значений RGB.</p>
                      <p>Что-то в этой идее пробудило любопытство автора, поэтому в статье он попытался удовлетворить его и ответить на вопрос: как на самом деле хранятся изображения?</p>
                      <hr>
                      <h2>Основы</h2>
                      <p>Изображение — это набор пикселей. Пиксель — &nbsp;наименьшая единица цвета в изображении. Рассмотрим следующее изображение из известного <a href="https://en.wikipedia.org/wiki/MNIST_database">датасета MNIST</a>:</p>
                      <figure class="full-width ">
                       <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/1a7/ed6/521/1a7ed652160402b799d4121884ea8648.png" width="3164" height="1660" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/getpro/habr/upload_files/1a7/ed6/521/1a7ed652160402b799d4121884ea8648.png 780w,
       https://habrastorage.org/r/w1560/getpro/habr/upload_files/1a7/ed6/521/1a7ed652160402b799d4121884ea8648.png 781w" loading="lazy" decode="async">
                      </figure>
                      <p>Это изображение состоит из 28x28 пикселей (или квадратов). Оно выполнено в градациях серого, то есть каждый пиксель имеет значение от 0 до 255, где 0 — чёрный, а 255 — белый.</p>
                      <p>А как насчет цветных изображений? В них также используются пиксели, но каждый пиксель хранится в виде RGB-триплета. Для каждого пикселя 3 байта представляют его цвет: красный, зеленый и синий. (0, 0, 0) — это чёрный цвет, а (255, 255, 255) — белый. Суть в том, что при отсутствии светлого (0, 0, 0), цвет — чёрный, а смешивая максимальное количество каждого цвета, вы получаете белый. Красный — это (255, 0, 0), зеленый — (0, 255, 0), а синий — (0, 0, 255).</p>
                      <p>RGB может иметь четвёртый компонент, называемый альфа, что делает его RGBA. Альфа указывает на непрозрачность или прозрачность пикселя. Он полезен при создании изображений, поскольку определяет, как обрабатывается прозрачность. Чем прозрачнее пиксель, тем меньше он скрывает фон за ним. При наложении двух изображений альфа-значение каждого пикселя определяет видимость фонового изображения через соответствующий пиксель изображения переднего плана.</p>
                      <p>Рассмотрим знаменитый клетчатый узор, который часто используется для обозначения прозрачности. В левой части изображения непрозрачность высокая (альфа-значение высокое), что делает фон невидимым. Напротив, в правой части, где непрозрачность ниже (альфа низкая), клетчатый фон становится видимым.</p>
                      <figure class="full-width ">
                       <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/340/53d/973/34053d9735f43dc00fc27c27074e7179.jpg" width="800" height="532" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/getpro/habr/upload_files/340/53d/973/34053d9735f43dc00fc27c27074e7179.jpg 780w,
       https://habrastorage.org/r/w1560/getpro/habr/upload_files/340/53d/973/34053d9735f43dc00fc27c27074e7179.jpg 781w" loading="lazy" decode="async">
                      </figure>
                      <p>Если мы храним цветное изображение (3 байта на пиксель) размером 1920x1080 без сжатия, то только для одного изображения нам потребуется 1920x1080x3 = 6 220 800 байт (около 6 МБ)!</p>
                      <p>1080p — обычное дело для видео, в то время как 240p (разрешение VHS) считается низким качеством. 480p — это нормально и соответствует качеству DVD.</p>
                      <p>Если бы мы передавали несжатое видео 1080p с частотой 24 кадра в секунду, это потребовало бы более 1 гигабита в секунду, что просто колоссально! Поэтому, если не использовать сжатие и другие ухищрения, потоковая передача высококачественного видео будет невозможна.</p>
                      <p><a href="https://cefboud.com/posts/compression/">Алгоритмы сжатия без потерь</a> обычно достигают коэффициента сжатия в лучшем случае 3:4. Алгоритмы, которые достигают таких высоких коэффициентов, часто требуют больших вычислительных затрат и работают медленно, что делает их непригодными для потоковой передачи в реальном времени. Даже коэффициента 3:4 недостаточно для передачи видео высокого разрешения с высокой частотой кадров.</p>
                      <p>Именно здесь на помощь приходит сжатие с потерями. Отбрасывая часть данных, мы можем добиться гораздо лучшего коэффициента сжатия. Схемы сжатия с потерями часто включают параметр качества, указывающий, в какой степени мы готовы пожертвовать качеством в обмен на лучший коэффициент сжатия.</p>
                      <h2>Форматы без потерь</h2>
                      <h3>GIF</h3>
                      <p>Graphical Interchange Format, GIF (произносится как «gif» от «gift») — это формат сжатия изображений без потерь. В нем используется фиксированная палитра из 256 цветов, каждый из которых задается 3 байтами для RGB. И вместо того, чтобы использовать 3 байта для кодирования каждого пикселя, мы используем индекс, указывающий на один из цветов в палитре. Идея здесь в том, что палитра содержит достаточно оттенков для передачи изображения. Таким образом, при 256 цветах нам нужен всего 1 байт для хранения индекса и коэффициент сжатия составляет 3:1. Хотя маловероятно, что изображение в реальном мире имеет только 256 цветов, некоторая форма сжатия должна была произойти раньше. Однако сам GIF не отвечает за это сжатие.</p>
                      <p>Изображения хранятся в виде массива w × h 8-битных индексов палитры, которые затем кодируются с помощью техники <a href="https://cefboud.com/posts/compression/#primer-on-compression">LZ </a>(повторяющиеся последовательности с обратной ссылкой).</p>
                      <p>Разумеется, GIF известен тем, что может хранить несколько изображений в одном файле, что позволяет создавать анимированные изображения.</p>
                      <figure class="">
                       <img src="https://habrastorage.org/getpro/habr/upload_files/2e0/b3c/b52/2e0b3cb525620acc688b87f5a39940cb.gif" width="330" height="216" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/getpro/habr/upload_files/2e0/b3c/b52/2e0b3cb525620acc688b87f5a39940cb.gif 780w,
       https://habrastorage.org/getpro/habr/upload_files/2e0/b3c/b52/2e0b3cb525620acc688b87f5a39940cb.gif 781w" loading="lazy" decode="async">
                      </figure>
                      <p>Давайте посмотрим на реализацию GIF в стандартной библиотеке Go. Полагаю, изучение того, как список изображений и задержки между ними используются для создания правильного GIF, поможет лучше понять этот формат:</p>
                      <pre><code class="go">images := []*image.Paletted{...}
// The successive delay times, one per frame, in 100ths of a second
// In this example, we have three images with 0.5 second delay between each
delays := []int{50,50,50} 
f, _ := os.OpenFile("amazing.gif", os.O_WRONLY|os.O_CREATE, 0600)
defer f.Close()
gif.EncodeAll(f, &amp;gif.GIF{
    Image: images,
    Delay: delays, 
})</code></pre>
                      <p>API для создания GIF в Go достаточно прост: нужно передать список изображений с палитрой и задержки между ними и сохранить результат в нужный нам файл.</p>
                      <p>Взглянем на структуру <a href="https://github.com/golang/go/blob/f6d17c540024418ca8a92371931b1b4fb076d2b6/src/image/image.go#L1148-L1159">Paletted</a>:</p>
                      <pre><code class="go">package image

// Paletted is an in-memory image of uint8 indices into a given palette.
type Paletted struct {
	// Pix holds the image's pixels, as palette indices. The pixel at
	// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1].
	Pix []uint8
	// Stride is the Pix stride (in bytes) between vertically adjacent pixels.
	Stride int
	// Rect is the image's bounds.
	Rect Rectangle
	// Palette is the image's palette.
	Palette color.Palette
}

type Palette []Color

// Color can convert itself to alpha-premultiplied 16-bits per channel RGBA.
// The conversion may be lossy.
type Color interface {
	// RGBA returns the alpha-premultiplied red, green, blue and alpha values
	// for the color. Each value ranges within [0, 0xffff], but is represented
	// by a uint32 so that multiplying by a blend factor up to 0xffff will not
	// overflow.
	//
	// An alpha-premultiplied color component c has been scaled by alpha (a),
	// so has valid values 0 &lt;= c &lt;= a.
	RGBA() (r, g, b, a uint32)
}

// A Rectangle contains the points with Min.X &lt;= X &lt; Max.X, Min.Y &lt;= Y &lt; Max.Y.
// It is well-formed if Min.X &lt;= Max.X and likewise for Y. Points are always
// well-formed. A rectangle's methods always return well-formed outputs for
// well-formed inputs.
type Rectangle struct {
	Min, Max Point
}

// A Point is an X, Y coordinate pair. The axes increase right and down.
type Point struct {
	X, Y int
}</code></pre>
                      <p>Палитра определяется следующими полями:</p>
                      <ul>
                       <li>
                        <p><strong>Rectangle</strong>, который определяется верхней левой точкой (min) и нижней правой точкой (max). Просто и эффективно! Чтобы упростить задачу, предположим, что <code>Min = (0, 0)</code>.</p></li>
                       <li>
                        <p><strong>color.Palette</strong> — массив интерфейсов <code>Color</code>, служащий, по сути, хранилищем для используемых RGB-цветов.</p></li>
                       <li>
                        <p><strong>Stride </strong>— расстояние между двумя вертикально соседними пикселями; часто это длина строки, т. е. <code>Max.X - Min.X</code>.</p></li>
                       <li>
                        <p><strong>Pix </strong>— фактические данные изображения в виде индексов цветовой палитры. Массив одномерный, но представляет собой двумерное изображение. Допустим, <code>Min = (0, 0)</code>. Эффективная прогрессия выглядит так:</p></li>
                      </ul>
                      <ul>
                       <li>
                        <p><code>(0, 0)</code>,&nbsp;<code>(1, 0)</code>, …,&nbsp;<code>(Max.X-1, 0)</code>,</p></li>
                       <li>
                        <p><code>(0, 1)</code>,&nbsp;<code>(1, 1)</code>, …,&nbsp;<code>(Max.X-1, 1)</code>,</p></li>
                       <li>
                        <p>…,</p></li>
                       <li>
                        <p><code>(0, Max.Y-1)</code>,&nbsp;<code>(1, Max.Y-1)</code>, …,&nbsp;<code>(Max.X-1, Max.Y-1)</code>.</p></li>
                      </ul>
                      <p>Проще говоря, <code>image.Paletted</code> — это список цветов и список пикселей, ссылающихся на эти цвета.</p>
                      <p>Палитризованные изображения и задержки используются для инициализации GIF-структуры. Взглянем на неё:</p>
                      <pre><code class="go">// GIF represents the possibly multiple images stored in a GIF file.
type GIF struct {
	Image []*image.Paletted // The successive images.
	Delay []int             // The successive delay times, one per frame, in 100ths of a second.
	// LoopCount controls the number of times an animation will be
	// restarted during display.
	// A LoopCount of 0 means to loop forever.
	// A LoopCount of -1 means to show each frame only once.
	// Otherwise, the animation is looped LoopCount+1 times.
	LoopCount int
	// Disposal is the successive disposal methods, one per frame. For
	// backwards compatibility, a nil Disposal is valid to pass to EncodeAll,
	// and implies that each frame's disposal method is 0 (no disposal
	// specified).
	Disposal []byte
	// Config is the global color table (palette), width and height. A nil or
	// empty-color.Palette Config.ColorModel means that each frame has its own
	// color table and there is no global color table. Each frame's bounds must
	// be within the rectangle defined by the two points (0, 0) and
	// (Config.Width, Config.Height).
	//
	// For backwards compatibility, a zero-valued Config is valid to pass to
	// EncodeAll, and implies that the overall GIF's width and height equals
	// the first frame's bounds' Rectangle.Max point.
	Config image.Config
	// BackgroundIndex is the background index in the global color table, for
	// use with the DisposalBackground disposal method.
	BackgroundIndex byte
}</code></pre>
                      <p>Отметим, что количество повторов (циклов) настраивается и по умолчанию равно бесконечности, если <code>LoopCount == -1</code>. Также мы видим, что ширина и высота GIF либо задаются явно, либо определяются из размеров первого изображения. Это означает, что изображения внутри GIF могут иметь разные размеры, и здесь становятся важными значения <code>Min </code>и <code>Max </code>в прямоугольнике каждого изображения: они не обязательно должны быть равны глобальным <code>Min </code>и <code>Max</code>.</p>
                      <p><code>Disposal </code>указывает, как следует обрабатывать предыдущий кадр. Этот параметр напрямую связан с альфа-каналом RGBA, то есть с параметром прозрачности. Основные методы удаления предыдущего кадра такие:</p>
                      <ul>
                       <li>
                        <p><strong>Unspecified (Ничего)</strong>. Полностью заменить одно полноразмерное непрозрачное изображение другим.</p></li>
                       <li>
                        <p><strong>Do Not Dispose (Оставить как есть)</strong>. Все пиксели, не покрытые следующим кадром, продолжают отображаться.</p></li>
                       <li>
                        <p><strong>Restore to Background (Восстановить фон)</strong>. Показать изображение, указанное в <code>BackgroundIndex</code>, через прозрачные пиксели нового кадра.</p></li>
                      </ul>
                      <p><code>Config</code> также может содержать <code>color.Palette</code>, которая является глобальной палитрой, общей для всех изображений. У каждого изображения может быть своя палитра, или они могут использовать одну для экономии места, если они достаточно похожи.</p>
                      <p>Итак. Теперь, когда мы знаем, как выглядят наши структуры, перейдем к <a href="https://github.com/golang/go/blob/f6d17c540024418ca8a92371931b1b4fb076d2b6/src/image/gif/writer.go#L364">самому процессу кодинга</a>:</p>
                      <pre><code class="go">// EncodeAll writes the images in g to w in GIF format with the
// given loop count and delay between frames.
func EncodeAll(w io.Writer, g *GIF) error {
	if len(g.Image) == 0 {
		return errors.New("gif: must provide at least one image")
	}
	if len(g.Image) != len(g.Delay) {
		return errors.New("gif: mismatched image and delay lengths")
	}
	e := encoder{g: *g}
    // ...

    
	if e.g.Config == (image.Config{}) {
        // If the image has no Config, we use the first image dimensions.
		p := g.Image[0].Bounds().Max
		e.g.Config.Width = p.X
		e.g.Config.Height = p.Y
	} else if e.g.Config.ColorModel != nil {
		if _, ok := e.g.Config.ColorModel.(color.Palette); !ok {
			return errors.New("gif: GIF color model must be a color.Palette")
		}
	}

    // ensure we have a proper write to send our data to
	if ww, ok := w.(writer); ok {
		e.w = ww
	} else {
		e.w = bufio.NewWriter(w)
	}

	e.writeHeader()
	for i, pm := range g.Image {
		disposal := uint8(0)
		if g.Disposal != nil {
			disposal = g.Disposal[i]
		}
		e.writeImageBlock(pm, g.Delay[i], disposal)
	}
	e.writeByte(sTrailer) // sTrailer = 0x3B =&gt; ascii semi-colon to signify EOF
	e.flush()
	return e.err
}</code></pre>
                      <p>Мне нравится такой код! Читается как обычный абзац. Проверка на ошибки, установка конфига, запись заголовка, затем запись каждого блока изображения и, наконец, запись символа EOF и сброс буфера.</p>
                      <p>Вот <code>writeHeader</code> с некоторыми дополнительными комментариями от меня:</p>
                      <pre><code class="go">func (e *encoder) writeHeader() {
	if e.err != nil {
		return
	}
	_, e.err = io.WriteString(e.w, "GIF89a") // Magic byte
	if e.err != nil {
		return
	}

	// Logical screen width and height.
	// written in Little Endian
	byteorder.LEPutUint16(e.buf[0:2], uint16(e.g.Config.Width))
	byteorder.LEPutUint16(e.buf[2:4], uint16(e.g.Config.Height))
	e.write(e.buf[:4])

    
	if p, ok := e.g.Config.ColorModel.(color.Palette); ok &amp;&amp; len(p) &gt; 0 {
		// write the global palette if we have it
		paddedSize := log2(len(p)) // Size of Global Color Table: 2^(1+n).
		e.buf[0] = fColorTable | uint8(paddedSize)
		e.buf[1] = e.g.BackgroundIndex
		e.buf[2] = 0x00 // Pixel Aspect Ratio.
		e.write(e.buf[:3])
		var err error
		e.globalCT, err = encodeColorTable(e.globalColorTable[:], p, paddedSize)
		if err != nil &amp;&amp; e.err == nil {
			e.err = err
			return
		}
		e.write(e.globalColorTable[:e.globalCT])
	} else {
		// All frames have a local color table, so a global color table
		// is not needed.
		e.buf[0] = 0x00
		e.buf[1] = 0x00 // Background Color Index.
		e.buf[2] = 0x00 // Pixel Aspect Ratio.
		e.write(e.buf[:3])
	}

	// Add animation info if necessary.
	if len(e.g.Image) &gt; 1 &amp;&amp; e.g.LoopCount &gt;= 0 {
		e.buf[0] = 0x21 // Extension Introducer.
		e.buf[1] = 0xff // Application Label.
		e.buf[2] = 0x0b // Block Size.
		e.write(e.buf[:3])
		_, err := io.WriteString(e.w, "NETSCAPE2.0") // Application Identifier.
		if err != nil &amp;&amp; e.err == nil {
			e.err = err
			return
		}
		e.buf[0] = 0x03 // Block Size.
		e.buf[1] = 0x01 // Sub-block Index.
		byteorder.LEPutUint16(e.buf[2:4], uint16(e.g.LoopCount))
		e.buf[4] = 0x00 // Block Terminator.
		e.write(e.buf[:5])
	}
}</code></pre>
                      <p>Вот цикл, который кодирует таблицу Palette:</p>
                      <pre><code class="go">	for i, c := range p {
		if c == nil {
			return 0, errors.New("gif: cannot encode color table with nil entries")
		}
		var r, g, b uint8
		// It is most likely that the palette is full of color.RGBAs, so they
		// get a fast path.
		if rgba, ok := c.(color.RGBA); ok {
			r, g, b = rgba.R, rgba.G, rgba.B
		} else {
			rr, gg, bb, _ := c.RGBA()
			r, g, b = uint8(rr&gt;&gt;8), uint8(gg&gt;&gt;8), uint8(bb&gt;&gt;8)
		}
		dst[3*i+0] = r
		dst[3*i+1] = g
		dst[3*i+2] = b
	}</code></pre>
                      <p>Ничего сложного. Мы проходим по цветам и последовательно кодируем красные, синие и зелёные байты в целевой буфер.</p>
                      <p>Собственно данные изображения записываются в <code>writeImageBlock</code>. Он немного длинноват, но самый интересный, на мой взгляд, фрагмент:</p>
                      <pre><code class="go">	for i, c := range p {
		if c == nil {
			return 0, errors.New("gif: cannot encode color table with nil entries")
		}
		var r, g, b uint8
		// It is most likely that the palette is full of color.RGBAs, so they
		// get a fast path.
		if rgba, ok := c.(color.RGBA); ok {
			r, g, b = rgba.R, rgba.G, rgba.B
		} else {
			rr, gg, bb, _ := c.RGBA()
			r, g, b = uint8(rr&gt;&gt;8), uint8(gg&gt;&gt;8), uint8(bb&gt;&gt;8)
		}
		dst[3*i+0] = r
		dst[3*i+1] = g
		dst[3*i+2] = b
	}</code></pre>
                      <p>В оригинальном коде <code>rect </code>имеет имя <code>b</code>. Я переименовал его для наглядности.</p>
                      <p>Мы берем массив <code>Pix&nbsp;</code>из нашей палитры изображения, где каждое значение представляет собой индекс в массиве цветов, затем сжимаем его по схеме <code>lzww </code>и записываем.</p>
                      <p>Вуаля! В этом и заключается магия кодирования GIF.</p>
                      <p>Я считаю, что декодер, который отображает GIF-изображение, — то, в чём кроется истинная магия формата. Но это небольшое исследование должно дать нам представление о том, как устроены под капотом все эти реакционные мемы, которые лично я использую слишком часто.</p>
                      <p>Напоследок в этом разделе сделаем до смешного простой GIF: 3 кадра синего, зелёного и красного цвета с 1-секундной задержкой. Запустив <code>go run main.go</code>, мы создадим файл <code>rgb.gif</code>, который будет зацикливать эти цвета.</p>
                      <pre><code class="go">package main

import (
	"fmt"
	"image"
	"image/color"
	"image/gif"
	"os"
)

func main() {
	var w, h int = 240, 240
	fileName := "rgb.gif"

	var palette = []color.Color{
		color.RGBA{0x00, 0x00, 0xff, 0xff}, // Blue
		color.RGBA{0x00, 0xff, 0x00, 0xff}, // Green
		color.RGBA{0xff, 0x00, 0x00, 0xff}, // Red
	}

	var images []*image.Paletted
	var delays []int
	for frame := 0; frame &lt; len(palette); frame++ {
		img := image.NewPaletted(image.Rect(0, 0, w, h), palette)
		paletteIndex := uint8(frame) // paletteIndex 0 is blue, 1 is green and 2 is red
		for p := 0; p &lt; 240*240; p++ {
			img.Pix[p] = paletteIndex
		}

		images = append(images, img)
		delays = append(delays, 100) // 1 second delay between frames
	}

	f, _ := os.OpenFile(fileName, os.O_WRONLY|os.O_CREATE, 0600)
	defer f.Close()
	gif.EncodeAll(f, &amp;gif.GIF{
		Image: images,
		Delay: delays,
	})
	fmt.Printf("Created '%v'.\n", fileName)
}</code></pre>
                      <figure class="">
                       <img src="https://habrastorage.org/getpro/habr/upload_files/5c7/f05/d2d/5c7f05d2d5c4dd3eab5848bcbd8e04f3.gif" width="240" height="240" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/getpro/habr/upload_files/5c7/f05/d2d/5c7f05d2d5c4dd3eab5848bcbd8e04f3.gif 780w,
       https://habrastorage.org/getpro/habr/upload_files/5c7/f05/d2d/5c7f05d2d5c4dd3eab5848bcbd8e04f3.gif 781w" loading="lazy" decode="async">
                      </figure>
                      <h3>PNG</h3>
                      <p>Portable Network Graphic (PNG) был разработан как преемник GIF. В отличие от своего предшественника, PNG поддерживает цвета без палитры, то есть фактически хранит RGB или RGBA для каждого цвета. Но он также поддерживает оттенки серого и палитры размером 3 байта RGB или 4 байта RGBA.</p>
                      <p>Каждый файл PNG начинается с сигнатуры:</p>
                      <pre><code>89 50 4E 47 0D 0A 1A 0A</code></pre>
                      <p>Затем следует список чанков. Существуют различные типы чанков:</p>
                      <ul>
                       <li>
                        <p>IHDR (заголовок изображения). Этот чанк должен идти первым и содержит важные метаданные изображения, такие как ширина, высота, битовая глубина, тип цвета и т. д.</p></li>
                       <li>
                        <p>IDAT (данные изображения): В этом чанке хранятся данные изображения, сжатые с помощью <a href="https://cefboud.com/posts/compression/#deflate-algorithm">алгоритма Deflate</a> (GZIP). Данные изображения могут быть разделены на несколько IDAT-чанков, особенно для больших изображений.</p></li>
                       <li>
                        <p>IEND (End Chunk). Этот чанк отмечает конец файла PNG.</p></li>
                      </ul>
                      <p>Я не большой поклонник этих аббревиатур (IHDR, IDAT), для меня они звучат излишне вычурно.</p>
                      <p>Так или иначе, PNG использует <a href="https://cefboud.com/posts/compression/#gzip">известный алгоритм DEFLATE</a>, применяемый в GZIP для сжатия данных изображения.</p>
                      <h4>Фильтрация</h4>
                      <p>Пиксели не всегда охотно поддаются сжатию. Они могут проявлять некоторое упрямство. Например, значения пикселей могут следовать определённому шаблону (2,4,6,8 и т. д.). Этот шаблон, к сожалению, не поддаётся сжатию LZ. Хоть мы и знаем, что существует повторяющееся поведение, которое управляет значениями пикселей, мы не можем просто использовать ссылки на предыдущие данные.</p>
                      <p>Решение? Преобразовать данные. Скажем, мы будем вычитать из каждого пикселя значение его соседа слева. В нашем примере мы получим (2,2,2,2,2 и т. д.). Это легко сжимается. Такая техника называется <code>Sub Filter</code>. Иногда закономерность проявляется по вертикали, а не по горизонтали. Например, пиксели в строке N - (12,18,44,89), а чуть ниже, в строке N+1, - (13,19,45,90). Это не так уж и маловероятно, потому что часто мы имеем градиент или плавные переходы цветов. Если мы применим фильтр <code>Up Filter</code>, то есть вычтем из каждого пикселя значение пикселя сверху, то получим аккуратный (1,1,1,1), что отлично поддаётся сжатию.</p>
                      <p>PNG применяет фильтры по строкам. Как выбрать фильтр? Идеального способа не существует, но используется такой эвристический подход: <strong>минимизируем сумму абсолютных разностей между пикселями оригинала и пикселями фильтра (вверх, до и т. д.)</strong>. Почему? Если сумма абсолютных разностей минимальна, то вполне вероятно, что у нас много близких или одинаковых значений, которые, скорее всего, более сжимаемы, чем «разрозненные» значения. Я понимаю, что можно придумать контрпример: например, массив (100, 100, 100, 100, 100, 100, 100), сумма которого равна 600, более сжимаем, чем (1,2,3,4,5,6), сумма которого намного меньше. Но это эвристика, и, судя по всему, она показала хорошие эмпирические результаты. Существуют и другие методы. В <a href="https://github.com/pnggroup/libpng/blob/0024abd279d3a06435c0309a3f4172eed7c7a19a/pngwutil.c#L2615">libpng </a>(канонической реализации PNG) есть следующий комментарий:</p>
                      <pre><code class="go">    * The prediction method we use is to find which method provides the
    * smallest value when summing the absolute values of the distances
    * from zero, using anything &gt;= 128 as negative numbers.  This is known
    * as the "minimum sum of absolute differences" heuristic.  Other
    * heuristics are the "weighted minimum sum of absolute differences"
    * (experimental and can in theory improve compression), and the "zlib
    * predictive" method (not implemented yet), which does test compressions
    * of lines using different filter methods, and then chooses the
    * (series of) filter(s) that give minimum compressed data size (VERY
    * computationally expensive).
    *
    * GRR 980525:  consider also
    *
    *   (1) minimum sum of absolute differences from running average (i.e.,
    *       keep running sum of non-absolute differences &amp; count of bytes)
    *       [track dispersion, too?  restart average if dispersion too large?]
    *
    *  (1b) minimum sum of absolute differences from sliding average, probably
    *       with window size &lt;= deflate window (usually 32K)
    *
    *   (2) minimum sum of squared differences from zero or running average
    *       (i.e., ~ root-mean-square approach)
    */</code></pre>
                      <p>Реализация в Golang также использует ту же эвристику, как мы увидим ниже.</p>
                      <p>Вот список всех фильтров, которые использует PNG:</p>
                      <ul>
                       <li>
                        <p>None. Ничего не делает.</p></li>
                       <li>
                        <p>Sub. Каждый байт заменяется разницей между текущим и предыдущим пикселем (в той же строке).</p></li>
                       <li>
                        <p>Up. Каждый байт заменяется разницей между текущим пикселем и пикселем, расположенным непосредственно над ним.</p></li>
                       <li>
                        <p>Average. Каждый байт заменяется средним значением пикселя слева и пикселя сверху.</p></li>
                       <li>
                        <p>Paeth. Каждый байт заменяется разницей между текущим пикселем и лучшим значением из трех: слева, сверху или по диагонали вверх-влево.</p></li>
                      </ul>
                      <p>Операции фильтрации выполняются на уровне байтов, и в результате на изображениях с малой глубиной (менее 8 бит на пиксель) по умолчанию используется фильтр NONE.</p>
                      <p>Перейдем к делу и рассмотрим <a href="https://github.com/golang/go/blob/608acff8479640b00c85371d91280b64f5ec9594/src/image/png/writer.go#L207">реализацию фильтров в Go</a>.</p>
                      <pre><code class="go">// Chooses the filter to use for encoding the current row, and applies it.
// The return value is the index of the filter and also of the row in cr that has had it applied.
func filter(cr *[nFilter][]byte, pr []byte, bpp int) int {
	// We try all five filter types, and pick the one that minimizes the sum of absolute differences.
	// This is the same heuristic that libpng uses, although the filters are attempted in order of
	// estimated most likely to be minimal (ftUp, ftPaeth, ftNone, ftSub, ftAverage), rather than
	// in their enumeration order (ftNone, ftSub, ftUp, ftAverage, ftPaeth).
	cdat0 := cr[0][1:]
	cdat1 := cr[1][1:]
	cdat2 := cr[2][1:]
	cdat3 := cr[3][1:]
	cdat4 := cr[4][1:]
	pdat := pr[1:]
	n := len(cdat0)

	// The up filter.
	sum := 0
	for i := 0; i &lt; n; i++ {
		cdat2[i] = cdat0[i] - pdat[i]
		sum += abs8(cdat2[i])
	}
	best := sum
	filter := ftUp

	// The Paeth filter.
	sum = 0
	for i := 0; i &lt; bpp; i++ {
		cdat4[i] = cdat0[i] - pdat[i]
		sum += abs8(cdat4[i])
	}
	for i := bpp; i &lt; n; i++ {
		cdat4[i] = cdat0[i] - paeth(cdat0[i-bpp], pdat[i], pdat[i-bpp])
		sum += abs8(cdat4[i])
		if sum &gt;= best {
			break
		}
	}
	if sum &lt; best {
		best = sum
		filter = ftPaeth
	}

	// The none filter.
	sum = 0
	for i := 0; i &lt; n; i++ {
		sum += abs8(cdat0[i])
		if sum &gt;= best {
			break
		}
	}
	if sum &lt; best {
		best = sum
		filter = ftNone
	}

	// The sub filter.
	sum = 0
	for i := 0; i &lt; bpp; i++ {
		cdat1[i] = cdat0[i]
		sum += abs8(cdat1[i])
	}
	for i := bpp; i &lt; n; i++ {
		cdat1[i] = cdat0[i] - cdat0[i-bpp]
		sum += abs8(cdat1[i])
		if sum &gt;= best {
			break
		}
	}
	if sum &lt; best {
		best = sum
		filter = ftSub
	}

	// The average filter.
	sum = 0
	for i := 0; i &lt; bpp; i++ {
		cdat3[i] = cdat0[i] - pdat[i]/2
		sum += abs8(cdat3[i])
	}
	for i := bpp; i &lt; n; i++ {
		cdat3[i] = cdat0[i] - uint8((int(cdat0[i-bpp])+int(pdat[i]))/2)
		sum += abs8(cdat3[i])
		if sum &gt;= best {
			break
		}
	}
	if sum &lt; best {
		filter = ftAverage
	}

	return filter
}</code></pre>
                      <p>Функция принимает аргументы <code>cr *[nFilter][]byte, pr []byte, bpp int. cr</code> — это массив массивов (я буду использовать массив и срез как взаимозаменяемые), он представляет текущий ряд, для которого мы хотим выбрать фильтр (возвращаемое значение — это индекс/тип фильтра).</p>
                      <p>Каждый результат фильтрации записывается внутри массива <code>cr[filterNb]</code>. Как сказано в комментарии, фильтры тестируются в порядке наиболее вероятных кандидатов на минимальную сумму разностей, это делается для того, чтобы иметь возможность прервать работу последующего фильтра, как только сумма превысит текущее лучшее значение. <code>pr</code> — предыдущий ряд. Первый байт массива байтов каждой строки содержит тип фильтра, поэтому <code>pdat = pr[1:]</code> — это данные предыдущей строки без типа фильтра. Давайте разберем фильтр <code>up</code>.</p>
                      <pre><code class="go">	// The up filter.
	sum := 0
	for i := 0; i &lt; n; i++ { // loop over the row pixels
		cdat2[i] = cdat0[i] - pdat[i] // subsctract the previous row's pixel at the same position i.e. the pixel above
		sum += abs8(cdat2[i]) // add the absolute difference to our sum which we are trying to minimize
	}</code></pre>
                      <p>Как насчет субфильтра?</p>
                      <pre><code class="go">	// The sub filter.
	// bpp is bytes per pixel. For RGB, it's 3. For gray scale, it's 1.
	sum = 0
	for i := 0; i &lt; bpp; i++ {
		cdat1[i] = cdat0[i]
		sum += abs8(cdat1[i])
	}
	for i := bpp; i &lt; n; i++ {
		cdat1[i] = cdat0[i] - cdat0[i-bpp] // subtract each byte within a pixel from corresponding byte in previous pixel
		sum += abs8(cdat1[i])
		if sum &gt;= best { // break early if this is worse than previous filter
			break
		}
	}</code></pre>
                      <p><code>bpp </code>играет здесь решающую роль. Обратите внимание, что при вычитании <code>cdat1[i] = cdat0[i] - cdat0[i - bpp]</code> мы вычитаем пиксель на <code>bpp</code> позиций раньше текущего пикселя. В случае RGB это означает, что из текущего значения красного цвета вычитается красный предыдущего пикселя, из текущего зелёного — зелёный предыдущего и так далее.</p>
                      <p>Мы вычисляем сумму для каждого фильтра и берем <code>min</code> — это и будет наш выбранный фильтр, который, предположительно, обеспечит максимальное сжатие алгоритмом DEFLATE. Результат применения выбранного фильтра будет находиться в массиве <code>cr[chosenFilter]</code>.</p>
                      <h4>Кодирование</h4>
                      <p>Рассмотрим метод <code>Encode</code>, используемый для кодирования изображений PNG.</p>
                      <pre><code class="go">// Encode writes the Image m to w in PNG format.
func (enc *Encoder) Encode(w io.Writer, m image.Image) error {
	// Obviously, negative widths and heights are invalid. Furthermore, the PNG
	// spec section 11.2.2 says that zero is invalid. Excessively large images are
	// also rejected.
	mw, mh := int64(m.Bounds().Dx()), int64(m.Bounds().Dy())
	if mw &lt;= 0 || mh &lt;= 0 || mw &gt;= 1&lt;&lt;32 || mh &gt;= 1&lt;&lt;32 {
		return FormatError("invalid image size: " + strconv.FormatInt(mw, 10) + "x" + strconv.FormatInt(mh, 10))
	}

	e := &amp;encoder{}
	//....

	e.enc = enc
	e.w = w
	e.m = m

	var pal color.Palette
	// cbP8 encoding needs PalettedImage's ColorIndexAt method.
	if _, ok := m.(image.PalettedImage); ok {
		pal, _ = m.ColorModel().(color.Palette)
	}
	if pal != nil {
		if len(pal) &lt;= 2 {
			e.cb = cbP1
		} else if len(pal) &lt;= 4 {
			e.cb = cbP2
		} else if len(pal) &lt;= 16 {
			e.cb = cbP4
		} else {
			e.cb = cbP8
		}
	} else {
		switch m.ColorModel() {
		case color.GrayModel:
			e.cb = cbG8
		case color.Gray16Model:
			e.cb = cbG16
		case color.RGBAModel, color.NRGBAModel, color.AlphaModel:
			if opaque(m) {
				e.cb = cbTC8
			} else {
				e.cb = cbTCA8
			}
		default:
			if opaque(m) {
				e.cb = cbTC16
			} else {
				e.cb = cbTCA16
			}
		}
	}

	_, e.err = io.WriteString(w, pngHeader)
	e.writeIHDR()
	if pal != nil {
		e.writePLTEAndTRNS(pal)
	}
	e.writeIDATs()
	e.writeIEND()
	return e.err
}</code></pre>
                      <p>Многое предстоит распаковать. Весело! Одна из причин, по которой я люблю читать код, это комментарии вроде «Очевидно, что отрицательные значения ширины и высоты недействительны». Он просто красиво звучит.</p>
                      <p>Мы начинаем с проверки размеров наших изображений, затем инициализируем наш энкодер, который определяется как:</p>
                      <pre><code class="go">type encoder struct {
	enc     *Encoder
	w       io.Writer
	m       image.Image
	cb      int //  a combination of color type and bit depth.
	err     error
	header  [8]byte
	footer  [4]byte
	tmp     [4 * 256]byte
	cr      [nFilter][]uint8 // stores the current row and possible filter
	pr      []uint8          // previous row
	zw      *zlib.Writer     // used of compression
	zwLevel int              // compression level
	bw      *bufio.Writer
}</code></pre>
                      <p>Затем пытаемся преобразовать наше изображение в <code>image.PalettedImage</code> и извлечь из него <code>Palette</code> (которая является псевдонимом для <code>[]Color</code>). Если это удаётся, значит, изображение палитровое, и мы определяем глубину цвета (количество бит) в зависимости от количества цветов в палитре. Если нет, то, основываясь на возвращаемом типе <code>ColorModel</code>, присваиваем наш <code>cb</code>. GrayModel, Gray16Model, RGBAModel, AlphaModel — всё это именно то, о чем говорят их названия.</p>
                      <p>Как только мы узнаем тип и глубину цвета, оставшийся код становится практически простым текстом.</p>
                      <pre><code class="go">	_, e.err = io.WriteString(w, pngHeader) // write magic "\x89PNG\r\n\x1a\n"
	e.writeIHDR() // write the actual header 
	if pal != nil {
		e.writePLTEAndTRNS(pal) // write the palette, if there is one
	}
	e.writeIDATs() // the image data
	e.writeIEND() // write the footer: `IEND`</code></pre>
                      <p>Вот функция <code>writeIHDR</code>, перед которой идут определения типов цвета:</p>
                      <pre><code class="go">// Color type, as per the PNG spec.
const (
	ctGrayscale      = 0
	ctTrueColor      = 2
	ctPaletted       = 3
	ctGrayscaleAlpha = 4
	ctTrueColorAlpha = 6
)

func (e *encoder) writeIHDR() {
	b := e.m.Bounds()
	// Write image dimensions in BigEndian (most significant byte at the smallest memory address)
	binary.BigEndian.PutUint32(e.tmp[0:4], uint32(b.Dx())) // image width
	binary.BigEndian.PutUint32(e.tmp[4:8], uint32(b.Dy())) // image height
	// Set bit depth and color type.
	switch e.cb {
	case cbG8:
		e.tmp[8] = 8
		e.tmp[9] = ctGrayscale
	case cbTC8:
		e.tmp[8] = 8
		e.tmp[9] = ctTrueColor
	case cbP8:
		e.tmp[8] = 8
		e.tmp[9] = ctPaletted
	case cbP4:
		e.tmp[8] = 4
		e.tmp[9] = ctPaletted
	case cbP2:
		e.tmp[8] = 2
		e.tmp[9] = ctPaletted
	case cbP1:
		e.tmp[8] = 1 // 1 bit per Pixel !!!!
		e.tmp[9] = ctPaletted
	case cbTCA8:
		e.tmp[8] = 8
		e.tmp[9] = ctTrueColorAlpha
	case cbG16:
		e.tmp[8] = 16
		e.tmp[9] = ctGrayscale
	case cbTC16:
		e.tmp[8] = 16
		e.tmp[9] = ctTrueColor
	case cbTCA16:
		e.tmp[8] = 16
		e.tmp[9] = ctTrueColorAlpha
	}
	e.tmp[10] = 0 // default compression method
	e.tmp[11] = 0 // default filter method
	e.tmp[12] = 0 // non-interlaced
	e.writeChunk(e.tmp[:13], "IHDR")
}
</code></pre>
                      <p>Мы подготавливаем массив заголовка размером 13 байт и записываем его как блок <code>IHDR </code>с помощью функции <a href="https://github.com/golang/go/blob/37f27fbecd422da9fefb8ae1cc601bc5b4fec44b/src/image/png/writer.go#L96"><code>writeChunk</code></a>:</p>
                      <pre><code class="go">func (e *encoder) writeChunk(b []byte, name string) {
	if e.err != nil {
		return
	}
	// 4 Gib max chunk size
	n := uint32(len(b))
	if int(n) != len(b) {
		e.err = UnsupportedError(name + " chunk is too large: " + strconv.Itoa(len(b)))
		return
	}
	// add the chunk length
	binary.BigEndian.PutUint32(e.header[:4], n)
	// chunk name
	e.header[4] = name[0]
	e.header[5] = name[1]
	e.header[6] = name[2]
	e.header[7] = name[3]
	crc := crc32.NewIEEE()
	// CRC check for the name + actual chunk data
	crc.Write(e.header[4:8])
	crc.Write(b)
	binary.BigEndian.PutUint32(e.footer[:4], crc.Sum32())

	// write header (length + name)
	_, e.err = e.w.Write(e.header[:8])
	if e.err != nil {
		return
	}
	// actual data
	_, e.err = e.w.Write(b)
	if e.err != nil {
		return
	}
	// CRC
	_, e.err = e.w.Write(e.footer[:4])
}</code></pre>
                      <p>Я добавил комментарии, но код довольно прост. Он записывает длину и имя чанка, затем сами данные, а в конце добавляет контрольную сумму (CRC).</p>
                      <p>Если в нашей цветовой схеме есть палитра, мы пишем чанк <code>PLTE</code>, используя:</p>
                      <pre><code class="go">func (e *encoder) writePLTEAndTRNS(p color.Palette) {
	if len(p) &lt; 1 || len(p) &gt; 256 {
		e.err = FormatError("bad palette length: " + strconv.Itoa(len(p)))
		return
	}
	last := -1
	for i, c := range p {
		c1 := color.NRGBAModel.Convert(c).(color.NRGBA)
		e.tmp[3*i+0] = c1.R
		e.tmp[3*i+1] = c1.G
		e.tmp[3*i+2] = c1.B
		if c1.A != 0xff {
			last = i
		}
		e.tmp[3*256+i] = c1.A
	}
	e.writeChunk(e.tmp[:3*len(p)], "PLTE")
	if last != -1 {
		e.writeChunk(e.tmp[3*256:3*256+1+last], "tRNS")
	}
}</code></pre>
                      <p>Чанк <code>PLTE</code> всегда хранит цвета палитры с использованием 3 байтов, независимо от типа цвета, то есть даже цвета в градациях серого (1 байт) используют 3 байта. Чанк <code>tRNS</code> хранит информацию о прозрачности, причем альфа-байт для каждой цветовой палитры располагается после байтов цвета палитры.</p>
                      <p>И наконец, собственно данные изображения, записанные с помощью <code>writeIDATs</code>:</p>
                      <pre><code class="go">// Write the actual image data to one or more IDAT chunks.
func (e *encoder) writeIDATs() {
	if e.err != nil {
		return
	}
	if e.bw == nil {
		e.bw = bufio.NewWriterSize(e, 1&lt;&lt;15)
	} else {
		e.bw.Reset(e)
	}
	e.err = e.writeImage(e.bw, e.m, e.cb, levelToZlib(e.enc.CompressionLevel))
	if e.err != nil {
		return
	}
	e.err = e.bw.Flush()
}</code></pre>
                      <p>Его суть заключается в цикле внутри <code>writeImage</code>:</p>
                      <pre><code class="go">	for y := b.Min.Y; y &lt; b.Max.Y; y++ {
		// Convert from colors to bytes.
		i := 1
		switch cb {
		case cbG8:
			if gray != nil {
				offset := (y - b.Min.Y) * gray.Stride
				copy(cr[0][1:], gray.Pix[offset:offset+b.Dx()])
			} else {
				for x := b.Min.X; x &lt; b.Max.X; x++ {
					c := color.GrayModel.Convert(m.At(x, y)).(color.Gray)
					cr[0][i] = c.Y
					i++
				}
			}
		// omitted ...
		case cbTC8:
			// We have previously verified that the alpha value is fully opaque.

			// omitted ...
				for x := b.Min.X; x &lt; b.Max.X; x++ {
					r, g, b, _ := m.At(x, y).RGBA()
					cr0[i+0] = uint8(r &gt;&gt; 8)
					cr0[i+1] = uint8(g &gt;&gt; 8)
					cr0[i+2] = uint8(b &gt;&gt; 8)
					i += 3
				}
		
		case cbP8:
			// omitted ...
				pi := m.(image.PalettedImage)
				for x := b.Min.X; x &lt; b.Max.X; x++ {
					cr[0][i] = pi.ColorIndexAt(x, y)
					i += 1
				}

		// omitted ...
		}

		// Apply the filter.
		// Skip filter for NoCompression and paletted images (cbP8) as
		// "filters are rarely useful on palette images" and will result
		// in larger files (see http://www.libpng.org/pub/png/book/chapter09.html).
		f := ftNone
		if level != zlib.NoCompression &amp;&amp; cb != cbP8 &amp;&amp; cb != cbP4 &amp;&amp; cb != cbP2 &amp;&amp; cb != cbP1 {
			// Since we skip paletted images we don't have to worry about
			// bitsPerPixel not being a multiple of 8
			bpp := bitsPerPixel / 8
			f = filter(&amp;cr, pr, bpp)
		}

		// Write the compressed bytes.
		if _, err := e.zw.Write(cr[f]); err != nil {
			return err
		}

		// The current row for y is the previous row for y+1.
		pr, cr[0] = cr[0], pr
	}</code></pre>
                      <p>Я оставил только случаи для оттенков серого, RGB (истинного цвета) и 256-цветной палитры <code>cbP8</code>. Как вы можете видеть, мы перебираем строки изображения: <code>y := b.Min.Y; y &lt; b.Max.Y; y++</code>. Для каждой строки, если это градации серого (<code>cbG8</code>), мы копируем по 1 байту для каждого цвета. Если это RGB, то копируем 3 байта. Для палитры мы просто записываем индекс палитры.</p>
                      <p>Затем, если сжатие включено (<code>level != zlib.NoCompression</code>) — нет необходимости фильтровать, если мы не будем сжимать, — и мы не используем палитры, мы выбираем фильтр для данных изображения с помощью функции <code>filter </code>, которую изучили ранее. Затем передаем отфильтрованные (или неотфильтрованные) байты в LZ-writer, и наши сжатые данные изображения готовы к записи.</p>
                      <p>Наконец, добавляем последний чанк с помощью функции <code>writeIEND</code>, короткой и приятной:</p>
                      <p><code>func (e *encoder) writeIEND() { e.writeChunk(nil, "IEND") }</code></p>
                      <p>И в этом вся суть PNG!</p>
                      <h2>Изображения с потерями</h2>
                      <h3>JPEG</h3>
                      <p>JPEG, Joint Photographic Experts Group (что за название!), чрезвычайно распространён в Интернете. Каждый, кто работал с изображениями на компьютере, наверняка сталкивался с PNG либо с JPEG. Этот формат позволяет достичь высокой степени сжатия, уменьшая исходное изображение до +90% от его размера при сохранении приемлемого качества. Степень сжатия варьируется от 5:1 до 50:1. Качество настраивается, и мы можем выбрать компромисс между коэффициентом сжатия и качеством изображения.</p>
                      <p>JPEG — это волшебный инженерный подвиг, состоящий из множества аспектов. Попробуем исследовать некоторые из его основных идей и посмотреть на код. Далее поговорим о цветовой субдискретизации, DCT (дискретное косинусное преобразование) и квантовании.</p>
                      <h4>YCbCr и цветовая субдискретизация</h4>
                      <p>Этот шаг основан на следующей идее: человеческий глаз более чувствителен к яркости (luma) и зелёному цвету, чем к красному и синему (chroma).</p>
                      <p>Если мы преобразуем наш цвет RGB в эквивалент, который изолирует яркость от красных и синих компонентов, мы сможем сохранить биты luma (к которым наш глаз более чувствителен), одновременно сжимая (субдискретизируя) chroma (красный и синий), к которому мы менее чувствительны.</p>
                      <p>Такое преобразование называется <strong>YCbCr (Y: Luma, Cb: Chroma Blue, Cr: Chroma Red)</strong>; оно отделяет яркость (Y) от цветовой информации (Cb и Cr).</p>
                      <p>Учитывая, что наши глаза более чувствительны к яркости, чем к цветам, мы можем сжать исходное изображение, выбрав меньше компонентов CbCr и оставив все компоненты яркости. Это называется <strong>цветовой субдискретизацией</strong>, т. е. мы берем меньше информации о цветах. Для каждого набора из 4 пикселей мы делаем субдискретизацию, заменяя их одним пикселем (например, усредняя или беря левый верхний пиксель). Заменяя 4 пикселя на 1 для Cb и Cr, мы уменьшаем исходный размер на 50 %.</p>
                      <p>JPEG работает с блоками 8x8 пикселей. Вот функция, которую использует стандартная библиотека Go для <a href="https://github.com/golang/go/blob/37f27fbecd422da9fefb8ae1cc601bc5b4fec44b/src/image/jpeg/writer.go#L390-L391">преобразования в YCbCr</a>:</p>
                      <pre><code class="go">const blockSize = 64
type block [blockSize]int32 // block holds 64 (8x8) pixels

// toYCbCr converts the 8x8 region of m whose top-left corner is p to its
// YCbCr values.
func toYCbCr(m image.Image, p image.Point, yBlock, cbBlock, crBlock *block) {
	b := m.Bounds()
	xmax := b.Max.X - 1
	ymax := b.Max.Y - 1
	for j := 0; j &lt; 8; j++ { // 8x8 pixel blocks
		for i := 0; i &lt; 8; i++ {
			r, g, b, _ := m.At(min(p.X+i, xmax), min(p.Y+j, ymax)).RGBA()
			yy, cb, cr := color.RGBToYCbCr(uint8(r&gt;&gt;8), uint8(g&gt;&gt;8), uint8(b&gt;&gt;8))
			yBlock[8*j+i] = int32(yy)
			cbBlock[8*j+i] = int32(cb)
			crBlock[8*j+i] = int32(cr)
		}
	}
}</code></pre>
                      <p>Волшебное преобразование происходит внутри <a href="https://github.com/golang/go/blob/37f27fbecd422da9fefb8ae1cc601bc5b4fec44b/src/image/color/ycbcr.go#L8">RGBToYCbCr</a>:</p>
                      <pre><code class="go">// RGBToYCbCr converts an RGB triple to a Y'CbCr triple.
func RGBToYCbCr(r, g, b uint8) (uint8, uint8, uint8) {
	// The JFIF specification says:
	//	Y' =  0.2990*R + 0.5870*G + 0.1140*B
	//	Cb = -0.1687*R - 0.3313*G + 0.5000*B + 128
	//	Cr =  0.5000*R - 0.4187*G - 0.0813*B + 128
	// https://www.w3.org/Graphics/JPEG/jfif3.pdf says Y but means Y'.

	yy := (19595*r1 + 38470*g1 + 7471*b1 + 1&lt;&lt;15) &gt;&gt; 16
	// omitted ...
	cb := -11056*r1 - 21712*g1 + 32768*b1 + 257&lt;&lt;15
	// omitted ...
	cr := 32768*r1 - 27440*g1 - 5328*b1 + 257&lt;&lt;15
	// omitted ...
	return uint8(yy), uint8(cb), uint8(cr)
}</code></pre>
                      <p>Это просто линейное преобразование. Мы замечаем, что Y в основном зелёный, но в нём также есть немного красного и синего. Как мы уже говорили, это luma, и наш глаз наиболее чувствителен к ней; она представляет собой яркость изображения. Cb и Cr можно интерпретировать как цветовые отличия синего и красного относительно яркости.</p>
                      <p>В <a href="https://youtu.be/5S4XblwZzCY?si=rke1SIt3deDSvZhE">этой потрясающей лекции</a> (я обожаю весь цикл лекций, а профессор просто восхитителен) показано множество примеров и того, как изменение различных значений RGB и YCbCr может повлиять на итоговое изображение. Удивительно, как уменьшение глубины (меньшее количество битов/информации) для Cb и Cr имеет гораздо меньший эффект, чем уменьшение синего или красного в пространстве RGB.</p>
                      <p>Это пересечение нейробиологии и инженерии.</p>
                      <p>Один из интересных выводов из этого — насколько мир оптимизирован под биологию человека. Это похоже на то, как очки создаются для человеческого лица, ушей и глаз. Это также заставляет меня думать, что роботов лучше всего делать гуманоидными, чтобы они были наиболее эффективными, поскольку наш мир спроектирован для нас.</p>
                      <p>Ладно, хватит философствовать, как на самом деле происходит цветовая субдискретизация?</p>
                      <p>Вот цикл, который записывает данные изображения в JPEG:</p>
                      <pre><code class="go">	cb, cr [4]block
	// omitted
	for y := bounds.Min.Y; y &lt; bounds.Max.Y; y += 16 {
			for x := bounds.Min.X; x &lt; bounds.Max.X; x += 16 {
				for i := 0; i &lt; 4; i++ {
					xOff := (i &amp; 1) * 8
					yOff := (i &amp; 2) * 4
					p := image.Pt(x+xOff, y+yOff)
					// omitted ..
					toYCbCr(m, p, &amp;b, &amp;cb[i], &amp;cr[i])
					prevDCY = e.writeBlock(&amp;b, 0, prevDCY)
				}
				scale(&amp;b, &amp;cb)
				prevDCCb = e.writeBlock(&amp;b, 1, prevDCCb)
				scale(&amp;b, &amp;cr)
				prevDCCr = e.writeBlock(&amp;b, 1, prevDCCr)
			}
		}</code></pre>
                      <p><code>cb</code> и <code>cr</code> содержат по 4 блока пикселей Cb и Cr размером 8x8. Мы проходим по области 16x16 из исходного изображения, которая состоит из 4 блоков 8x8. Эти блоки размещаются в переменных <code>cb</code> и <code>cr</code>.</p>
                      <p>В самом внутреннем цикле есть довольно интересный трюк. Обратите внимание на <code>xOff := (i &amp; 1) * 8</code><em> и </em><code>yOff := (i &amp; 2) * 4</code>. Их значения для <code>i = [0,1,2,3]</code> будут: <code>(xOff, yOff) = [(0,0), (8,0), (0,8), (8,8)]</code>. Это позволяет двигаться по блоку 16x16: сначала сдвигаемся слева направо по верхнему ряду, затем смещаемся на 8 (переход к следующему блоку 8x8 вправо), а затем переходим к следующей <em>строке </em>и выполняем то же самое.</p>
                      <p>Таким образом, мы имеем значения Cb и Cr в 4 блоках 8x8. Субдискретизация происходит в функции <code>scale</code>:</p>
                      <pre><code class="go">// scale scales the 16x16 region represented by the 4 src blocks to the 8x8
// dst block.
func scale(dst *block, src *[4]block) {
	for i := 0; i &lt; 4; i++ {
		dstOff := (i&amp;2)&lt;&lt;4 | (i&amp;1)&lt;&lt;2
		for y := 0; y &lt; 4; y++ {
			for x := 0; x &lt; 4; x++ {
				j := 16*y + 2*x
				sum := src[i][j] + src[i][j+1] + src[i][j+8] + src[i][j+9]
				dst[8*y+x+dstOff] = (sum + 2) &gt;&gt; 2
			}
		}
	}
}</code></pre>
                      <p>Это нечто! Во-первых, обратите внимание, что мы берем исходный <code>block</code> размером [4] и преобразуем его в <code>block</code> dst. Напоминаю, что <code>block</code> — это просто массив размером 64 (8x8).</p>
                      <p><code>i</code> представляет собой верхний левый, верхний правый, нижний левый и нижний правый блоки 8x8 в области 16x16 входных данных. Каждый из блоков 8x8 будет отображаться в блок 4x4 (уменьшение на 1/4). Каждый пиксель блока 4x4 обозначается x и y. Как вычисляется значение каждого пикселя?</p>
                      <pre><code class="go">j := 16*y + 2*x // top left point of the 4 pixel square
sum := src[i][j] + src[i][j+1] + src[i][j+8] + src[i][j+9] // sum of pixel square values starting at j
dst[8*y+x+dstOff] = (sum + 2) &gt;&gt; 2 // divide by 4 (&gt;&gt;2) to get the average but add 2 before to round up instead of down</code></pre>
                      <p>Это просто усреднение значений 4 пикселей с помощью 2-битного сдвига вправо и округления в большую сторону путем добавления 2 перед сдвигом.</p>
                      <p>Значение <code>dstOff</code> интригует. Для <code>i=[0,1,2,3]</code> мы получаем <code>dstOff=[0,4,32,36]</code>. Что они означают?</p>
                      <p>Давайте вспомним, что каждый <code>i</code> представляет собой 4x4 блок внутри нашей целевой 8x8 области, которая представляет собой уменьшенную версию 16x16. Если представить матрицу 8x8, то левый верхний блок начинается в точке (0,0). Правый верхний блок начинается в точке (4,0). Левый нижний блок начинается в точке (4,0), а правый нижний —&nbsp;в точке (4,4). Если мы переведем их в одномерное представление с помощью <code>x + 8y</code>, то получим:</p>
                      <pre><code>0 + 0 * 8 = 0 
4 + 0 * 8 = 4
0 + 4 * 8 = 32
4 + 4 * 8 = 36</code></pre>
                      <p>Который представляет собой начало каждого блока 4x4. Это вычисление причудливым образом производится с помощью <code>dstOff := (i&amp;2)&lt;&lt;4 | (i&amp;1)&lt;&lt;2</code>.</p>
                      <p><code>(i&amp;2)&lt;&lt;4</code> даст 32 для значений, у которых второй бит равен единице, то есть для 2 (10) и 3 (11) (вторая строка), а <code>(i&amp;1)&lt;&lt;2</code> даст 4 для значений 1 (01) и 3 (11). Настоящая бинарная магия!</p>
                      <p>Если вы задаётесь вопросом, зачем делать всё это и получать 4 блока из области 16x16 вместо того, чтобы обрабатывать их по отдельности, то причина в том, что в итоге мы хотим получить блок 8x8, аналогичный компоненту Y (luma). Это гарантирует, что следующий шаг JPEG, а именно дискретное косинусное преобразование (DCT), будет работать с теми же размерами.</p>
                      <p>В общем, функция <code>scale</code> — это просто усреднение 4 пикселей в 1, что позволяет уменьшить 4 блока 8x8 до одного.</p>
                      <h4>Прямое косинусное преобразование</h4>
                      <p>Итак, мы достигли приличного 50-процентного сжатия, используя YCbCr. Однако всё ещё далеки от раскрытия всего потенциала JPEG.</p>
                      <p>Следующий шаг в процессе — дискретное косинусное преобразование (DCT). Вкратце, DCT выделяет и идентифицирует части изображения, которые можно обрезать или отбросить без существенного ухудшения качества.</p>
                      <p>Мы можем представить себе изображение как функцию. Каждый пиксель на изображении соответствует позиции (x, y) со значением, указывающим на интенсивность его цвета. Мы можем представить это как <code>F(x, y) = pixelValue</code>. Если мы хотим обходить изображение слева направо и сверху вниз, мы можем упростить задачу, используя одну переменную <code>x'</code>, где <code>x' = x + len(row) * y</code> (по сути, это то, что делает реализация Golang со своими 64-битными блоками беззнаковых целых чисел).</p>
                      <p>Другими словами, изображение — это функция.<strong> </strong>И что с того? — спросите вы. А что, если есть способ аппроксимировать эту функцию с помощью набора компонентов разной важности и сэкономить место, отбросив наименее важные из них?</p>
                      <p>Представьте, что у нас есть набор кортежей типа <code>(1, 2), (2, 4), ..., (10, 20), (1000, 2000)</code>. Мы можем хранить 2 * 1000 чисел, а можем понять, что эти отношения следуют простой схеме: <code>f(x) = 2x</code>. Вместо того чтобы хранить все точки, мы могли бы хранить только формулу, что дало бы значительную экономию места.</p>
                      <p>DCT позволяет представить функцию изображения в виде суммы известных косинусных функций возрастающей частоты. Математически доказано, что это возможно.</p>
                      <p>Что действительно поразительно в этом представлении, так это то, что человеческий глаз (биология снова наносит удар) менее чувствителен к высокочастотным деталям, чем к низкочастотным. Еще интереснее то, что высокочастотные компоненты соответствуют резким изменениям на изображении, а на практике изображения в основном состоят из низкочастотных компонентов. Другими словами, цвета в изображениях обычно не меняются резко.</p>
                      <p>Говоря иначе, любой блок размером 8x8 пикселей можно выразить как взвешенную сумму следующих 64 блоков:</p>
                      <figure class="">
                       <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/1d1/907/ed6/1d1907ed6d1adef2f9d47bd249658993.png" width="250" height="250" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/getpro/habr/upload_files/1d1/907/ed6/1d1907ed6d1adef2f9d47bd249658993.png 780w,
       https://habrastorage.org/r/w1560/getpro/habr/upload_files/1d1/907/ed6/1d1907ed6d1adef2f9d47bd249658993.png 781w" loading="lazy" decode="async">
                      </figure>
                      <p>Давайте подумаем об этом ещё раз. Любой блок 8x8 может быть выражен как комбинация этих 64 блоков. И чем больше мы приближаемся к правому нижнему углу, тем выше частота соответствующего компонента — и тем менее различим он для человеческого глаза.</p>
                      <p>Поэтому, если мы представим наш блок 8x8 только несколькими весами этих низкочастотных блоков DCT — скажем, сохраним всего 16 или 32 (вместо 64 пикселей), мы добьемся большой экономии места без заметной потери качества.</p>
                      <p>Чтобы мой плагин Mathjax не пылился без дела а мои рассуждения были подкреплены наукой, давайте посмотрим на фактическую формулу:</p><img class="formula" source="X_{k}=\sum _{n=0}^{N-1}x_{n}\cos \left[\,{\tfrac {\,\pi \,}{N}}\left(n+{\tfrac {1}{2}}\right)k\,\right]\qquad {\text{ for }}~k=0,\ \dots \ N-1~" alt="X_{k}=\sum _{n=0}^{N-1}x_{n}\cos \left[\,{\tfrac {\,\pi \,}{N}}\left(n+{\tfrac {1}{2}}\right)k\,\right]\qquad {\text{ for }}~k=0,\ \dots \ N-1~" src="https://habrastorage.org/getpro/habr/formulas/b/bf/bf3/bf38f5a536aeb76b2b417069a2a8d9ba.svg" width="auto" height="auto" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/getpro/habr/formulas/b/bf/bf3/bf38f5a536aeb76b2b417069a2a8d9ba.svg 780w,
       https://habrastorage.org/getpro/habr/formulas/b/bf/bf3/bf38f5a536aeb76b2b417069a2a8d9ba.svg 781w" loading="lazy" decode="async">
                      <p>Так мы вычисляем коэффициент K-й косинусной функции.</p>
                      <p>Будет удобно представить себе это уравнение как скалярное произведение между нашими N значениями пикселей и N выборками косинусной функции:</p><img class="formula" source="\cos \left[\,{\tfrac {\,\pi \,}{N}}\left(n+{\tfrac {1}{2}}\right)k\,\right]" alt="\cos \left[\,{\tfrac {\,\pi \,}{N}}\left(n+{\tfrac {1}{2}}\right)k\,\right]" src="https://habrastorage.org/getpro/habr/upload_files/ec5/c0e/eeb/ec5c0eeebf57605c976be679d83baf05.svg" width="153" height="27" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/getpro/habr/upload_files/ec5/c0e/eeb/ec5c0eeebf57605c976be679d83baf05.svg 780w,
       https://habrastorage.org/getpro/habr/upload_files/ec5/c0e/eeb/ec5c0eeebf57605c976be679d83baf05.svg 781w" loading="lazy" decode="async">
                      <p>частота которых увеличивается с ростом k.</p>
                      <p>Коэффициент представляет собой степень сходства (т. е. скалярное произведение) между нашими значениями пикселей и соответствующей косинусной функцией.</p>
                      <p>Для наших целей мы работаем с одним из 64 блоков (обратите внимание, что приведённая выше косинусная функция является одномерной, а блок — двумерным, поэтому данное объяснение применимо только к одному из измерений).</p>
                      <p>Например, если у нас есть сетка входных пикселей 8x8, которая идеально совпадает с одним из косинусных шаблонов, то соответствующий коэффициент будет равен 1, а коэффициенты для других блоков будут равны 0. Это происходит потому, что только этого блока достаточно для представления входных данных.</p>
                      <p>Еще раз: взвешенная комбинация низкочастотных блоков (ближе к левому верхнему углу) с большей вероятностью сможет хорошо представить исходный блок 8x8 пикселей. Поэтому, когда мы представляем наше изображение в виде 64 коэффициентов, мы можем отбросить высокочастотные не сильно теряя в качестве.</p>
                      <p>Итак, теперь мы готовы к двумерной формуле:</p><img class="formula" source="X_{k,l} = \sum_{n=0}^{N-1} \sum_{m=0}^{N-1} x_{n,m} \cos\left[\frac{\pi}{N} \left(n + \frac{1}{2}\right) k \right] \cos\left[\frac{\pi}{N} \left(m + \frac{1}{2}\right) l \right]" alt="X_{k,l} = \sum_{n=0}^{N-1} \sum_{m=0}^{N-1} x_{n,m} \cos\left[\frac{\pi}{N} \left(n + \frac{1}{2}\right) k \right] \cos\left[\frac{\pi}{N} \left(m + \frac{1}{2}\right) l \right]" src="https://habrastorage.org/getpro/habr/formulas/e/e4/e45/e459c803c13c363f7bd03e9d332e9119.svg" width="auto" height="auto" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/getpro/habr/formulas/e/e4/e45/e459c803c13c363f7bd03e9d332e9119.svg 780w,
       https://habrastorage.org/getpro/habr/formulas/e/e4/e45/e459c803c13c363f7bd03e9d332e9119.svg 781w" loading="lazy" decode="async">
                      <p>Переведя в код, получим следующее:</p>
                      <pre><code class="go">    for i := 0; i &lt; N; i++ {
        for j := 0; j &lt; N; j++ {
            temp := 0.0
            for x := 0; x &lt; N; x++ {
                for y := 0; y &lt; N; y++ {
                    temp += Cosines[x][i] * Cosines[y][j] * Pixel[x][y]
                }
            }
            temp *= math.Sqrt(2 * float64(N)) * Coefficient[i][j]
            DCT[i][j] = int(math.Round(temp))
        }
    }</code></pre>
                      <p>Массив cosines уже содержит предварительно вычисленные значения. Мы просто итерируемся по пикселям и вычисляем выходные коэффициенты, которые зависят от значений пикселей и косинусов.</p>
                      <p>Однако, как видно, уровень вложенности 4 для циклов не так уж хорош для производительности. В практических реализациях используется оптимизированная версия, известная как <a href="https://dl.acm.org/doi/pdf/10.1145/212066.212071">Fast DCT</a>, которая более эффективна с вычислительной точки зрения.</p>
                      <h4>Квантование</h4>
                      <p>Вместо того чтобы сразу удалять высокочастотные коэффициенты, мы уменьшаем их точность, используя меньшее количество бит для их хранения. Этот процесс называется квантованием. В результате важные низкочастотные коэффициенты сохраняются с большей точностью, а высокочастотные коэффициенты квантуются для экономии места.</p>
                      <p>Как это происходит на практике?</p>
                      <p>Результаты DCT делятся на Q таблицу, уменьшая количество необходимых бит. Например, если результат DCT равен 31, а значение Q - 2, <code>Round(31/Q)</code> дает 16. Если Q равно 4, <code>Round(31/Q)</code> дает 8. Чтобы восстановить исходные значения, мы умножаем квантованный результат на Q, хотя восстановленное значение будет приблизительным.</p>
                      <p>Стандарт JPEG определяет таблицу для квантования каждого из 64 коэффициентов, полученных после применения DCT к блоку 8x8 пикселей.</p>
                      <p>Поскольку компоненты цветности (Yb и Yr) оказывают меньшее влияние на наше восприятие, их таблицы квантования более агрессивны, чем таблицы, используемые для яркости (Y). Вот эти таблицы:</p>
                      <pre><code class="go">var unscaledQuant = [nQuantIndex][blockSize]byte{
	// Luminance.
	{
		16, 11, 12, 14, 12, 10, 16, 14,
		13, 14, 18, 17, 16, 19, 24, 40,
		26, 24, 22, 22, 24, 49, 35, 37,
		29, 40, 58, 51, 61, 60, 57, 51,
		56, 55, 64, 72, 92, 78, 64, 68,
		87, 69, 55, 56, 80, 109, 81, 87,
		95, 98, 103, 104, 103, 62, 77, 113,
		121, 112, 100, 120, 92, 101, 103, 99,
	},
	// Chrominance.
	{
		17, 18, 18, 24, 21, 24, 47, 26,
		26, 47, 99, 66, 56, 66, 99, 99,
		99, 99, 99, 99, 99, 99, 99, 99,
		99, 99, 99, 99, 99, 99, 99, 99,
		99, 99, 99, 99, 99, 99, 99, 99,
		99, 99, 99, 99, 99, 99, 99, 99,
		99, 99, 99, 99, 99, 99, 99, 99,
		99, 99, 99, 99, 99, 99, 99, 99,
	},
}</code></pre>
                      <p>Можно заметить, что низкие частоты (вверху слева) делятся на меньшие значения, чтобы сохранить более высокую точность, в то время как высокие частоты (внизу справа) делятся на большие значения из таблицы Q, что приводит к очень маленьким результатам (близким к 0 или 1). Эти малые значения являются идеальными кандидатами для методов сжатия без потерь, таких как LZ77 или кодирование длин серий.</p>
                      <p>Чтобы добиться максимальной эффективности сжатия, блок обходится в зигзагообразном порядке. Как видно из таблицы квантования, увеличение значений Q (и, соответственно, результата квантования) не происходит по типичной схеме слева направо, сверху вниз. Напротив, оно происходит от левого верхнего края к правому нижнему.</p>
                      <p>Это означает, что значения, которые, скорее всего, похожи и, следовательно, более сжимаемы, следуют друг за другом по диагонали. Зигзагообразный обход эффективно группирует эти похожие значения, оптимизируя сжатие.</p>
                      <figure class="">
                       <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/b1e/55d/6d0/b1e55d6d0a5df517246250eb504dca6c.png" width="360" height="360" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/getpro/habr/upload_files/b1e/55d/6d0/b1e55d6d0a5df517246250eb504dca6c.png 780w,
       https://habrastorage.org/r/w1560/getpro/habr/upload_files/b1e/55d/6d0/b1e55d6d0a5df517246250eb504dca6c.png 781w" loading="lazy" decode="async">
                      </figure>
                      <p>Зигзагообразный обход выполняется довольно хитро: используется массив из 64 элементов, который сопоставляет каждый обычный индекс с его зигзагообразным порядком.</p>
                      <pre><code class="go">// unzig maps from the zig-zag ordering to the natural ordering. For example,
// unzig[3] is the column and row of the fourth element in zig-zag order. The
// value is 16, which means first column (16%8 == 0) and third row (16/8 == 2).
var unzig = [blockSize]int{
	0, 1, 8, 16, 9, 2, 3, 10,
	17, 24, 32, 25, 18, 11, 4, 5,
	12, 19, 26, 33, 40, 48, 41, 34,
	27, 20, 13, 6, 7, 14, 21, 28,
	35, 42, 49, 56, 57, 50, 43, 36,
	29, 22, 15, 23, 30, 37, 44, 51,
	58, 59, 52, 45, 38, 31, 39, 46,
	53, 60, 61, 54, 47, 55, 62, 63,
}
</code></pre>
                      <p>Если собрать все части вместе, получится, что основной цикл JPEG — это:</p>
                      <pre><code class="go">// writeBlock writes a block of pixel data using the given quantization table,
// returning the post-quantized DC value of the DCT-transformed block. b is in
// natural (not zig-zag) order.
func (e *encoder) writeBlock(b *block, q quantIndex, prevDC int32) int32 {
	fdct(b) // apply DCT
	// ...
	for zig := 1; zig &lt; blockSize; zig++ {
		ac := div(b[unzig[zig]], 8*int32(e.quant[q][zig])) // divide zigzag DCT result by quantization number
		if ac == 0 {
			// quantization result is 0, increase RLE
			runLength++
		} else {
			// ...
			// write the current RLE sequence
			e.emitHuffRLE(h, runLength, ac)
			runLength = 0
		}
	}
	//...
}
</code></pre>
                      <p>Мы опустили довольно много деталей, но всё же можем видеть, как применяются различные идеи, которые мы рассмотрели.</p>
                      <p>JPEG — настоящая сокровищница восхитительных инженерных решений, и то, что мы здесь обсудили, — лишь верхушка айсберга. Но я надеюсь, что это было познавательно и увлекательно.</p>
                      <p>На этом пока все. Ценю, что вы присоединились ко мне в этом путешествии.</p>
                      <p>Спасибо!</p>
                      <hr>
                      <p><a href="https://t.me/sravni_tech"><strong>ТГ-канал инженерного сообщества Sravni Tech</strong></a></p>
                     </div>
                    </div>
                   </div><!----><!---->
                  </div><!----><!---->
                 </div><!--]--><!---->
                 <div class="tm-article-presenter__meta" data-test-id="article-meta-links">
                  <div class="tm-separated-list tm-article-presenter__meta-list">
                   <span class="tm-separated-list__title">Теги:</span>
                   <ul class="tm-separated-list__list">
                    <!--[-->
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[jpeg]" class="tm-tags-list__link"><span>jpeg</span></a><!--]--></li>
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[png]" class="tm-tags-list__link"><span>png</span></a><!--]--></li>
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[gif]" class="tm-tags-list__link"><span>gif</span></a><!--]--></li>
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[golang]" class="tm-tags-list__link"><span>golang</span></a><!--]--></li>
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F]" class="tm-tags-list__link"><span>изображения</span></a><!--]--></li>
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[go]" class="tm-tags-list__link"><span>go</span></a><!--]--></li>
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B8]" class="tm-tags-list__link"><span>картинки</span></a><!--]--></li><!--]--><!---->
                   </ul>
                  </div>
                  <div class="tm-separated-list tm-article-presenter__meta-list">
                   <span class="tm-separated-list__title">Хабы:</span>
                   <ul class="tm-separated-list__list">
                    <!--[-->
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/companies/sravni/articles/" class="tm-hubs-list__link"><!--[--><span>Блог компании Сравни</span><!--]--></a><!--]--></li>
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/hubs/go/" class="tm-hubs-list__link"><!--[--><span>Go</span><!--]--></a><!--]--></li>
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/hubs/programming/" class="tm-hubs-list__link"><!--[--><span>Программирование</span><!--]--></a><!--]--></li>
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/hubs/image_processing/" class="tm-hubs-list__link"><!--[--><span>Обработка изображений</span><!--]--></a><!--]--></li><!--]--><!---->
                   </ul>
                  </div>
                 </div><!----><!--]-->
                </article><!--]-->
               </div><!---->
              </div>
              <div style="" class="tm-article-sticky-panel" data-test-id="article-sticky-panel">
               <div class="tm-data-icons tm-data-icons tm-data-icons_space-big tm-article-sticky-panel__icons" data-test-id="article-stats-icons">
                <div class="article-rating tm-data-icons__item" data-v-86aec4a7>
                 <div class="tm-votes-lever tm-votes-lever tm-votes-lever_appearance-article votes-switcher" title="Всего голосов 21: ↑21 и ↓0" data-v-86aec4a7>
                  <button class="tm-votes-lever__button" data-test-id="votes-lever-upvote-button" title="Нравится" type="button">
                   <svg class="tm-svg-img tm-votes-lever__icon" height="24" width="24">
                    <title>
                     Нравится
                    </title><use xlink:href="/img/megazord-v28.7909a852..svg#counter-vote"></use>
                   </svg></button>
                  <div class="tm-votes-lever__score tm-votes-lever__score_appearance-article tm-votes-lever__score">
                   <!--[--><span><span class="tm-votes-lever__score-counter tm-votes-lever__score-counter_positive tm-votes-lever__score-counter" data-test-id="votes-score-counter">+30</span></span><!--]-->
                  </div>
                  <button class="tm-votes-lever__button" data-test-id="votes-lever-downvote-button" title="Не нравится" type="button">
                   <svg class="tm-svg-img tm-votes-lever__icon tm-votes-lever__icon_arrow-down" height="24" width="24">
                    <title>
                     Не нравится
                    </title><use xlink:href="/img/megazord-v28.7909a852..svg#counter-vote"></use>
                   </svg></button>
                 </div><!--teleport start--><!--teleport end--><!---->
                </div><!----><!---->
                <button class="bookmarks-button tm-data-icons__item" title="Добавить в закладки" type="button"><span class="tm-svg-icon__wrapper bookmarks-button__icon">
                  <svg class="tm-svg-img tm-svg-icon" height="24" width="24">
                   <title>
                    Добавить в закладки
                   </title><use xlink:href="/img/megazord-v28.7909a852..svg#counter-favorite"></use>
                  </svg></span><span class="bookmarks-button__counter" title="Количество пользователей, добавивших публикацию в закладки">61</span></button>
                <div class="tm-sharing tm-data-icons__item" title="Поделиться">
                 <button class="tm-sharing__button" type="button">
                  <svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="tm-sharing__icon">
                   <path fill="currentColor" d="M13.8 13.8V18l7.2-6.6L13.8 5v3.9C5 8.9 3 18.6 3 18.6c2.5-4.4 6-4.8 10.8-4.8z"></path>
                  </svg></button><!--teleport start--><!--teleport end-->
                </div>
                <div class="tm-article-comments-counter-link tm-data-icons__item" title="Читать комментарии">
                 <a href="/ru/companies/sravni/articles/906964/comments/" class="tm-article-comments-counter-link__link" data-test-id="counter-comments"><!--[-->
                  <svg class="tm-svg-img tm-article-comments-counter-link__icon" height="24" width="24">
                   <title>
                    Комментарии
                   </title><use xlink:href="/img/megazord-v28.7909a852..svg#counter-comments"></use>
                  </svg><span class="tm-article-comments-counter-link__value">7</span><!--]--></a><!---->
                </div><!--[--><!--[--><!--[--><!----><!--]--><!--]--><!--]--><!--teleport start--><!--teleport end--><!---->
               </div>
              </div>
             </div><!--[--><!--]-->
             <div class="tm-article-presenter__footer">
              <!--[--><!--[-->
              <div class="tm-article-blocks">
               <!----><!--[-->
               <section class="tm-block tm-block tm-block_spacing-bottom">
                <!----><!--[-->
                <div class="tm-block__body tm-block__body tm-block__body_variant-balanced">
                 <!--[-->
                 <div class="tm-article-author" data-test-id="article-author-info" data-async-called="true">
                  <!--[--><!--[-->
                  <div class="tm-article-author__company">
                   <div class="tm-article-author__company-card">
                    <div class="tm-company-snippet">
                     <a href="/ru/companies/sravni/profile/" class="tm-company-snippet__logo-link">
                      <div class="tm-entity-image">
                       <img alt="" class="tm-entity-image__pic" height="40" src="//habrastorage.org/getpro/habr/company/1cd/7c2/e10/1cd7c2e105e5f65ce3c80c6d03495ea3.png" width="40">
                      </div></a>
                     <div class="tm-company-snippet__info">
                      <a href="/ru/companies/sravni/profile/" class="tm-company-snippet__title" data-test-id="company-title"><span>Сравни</span></a>
                      <div class="tm-company-snippet__description">
                       Компания
                      </div>
                     </div>
                    </div>
                    <div class="tm-article-author__buttons">
                     <!----><!---->
                    </div>
                   </div>
                   <div class="tm-article-author__company-contacts">
                    <!--[--><a class="tm-article-author__contact" href="https://www.sravni.ru" rel="noopener" target="_blank">Сайт</a><!--]-->
                   </div>
                   <div class="tm-article-author__separator"></div>
                  </div><!--]--><!--]-->
                  <div class="tm-user-card tm-user-card tm-user-card_variant-article tm-article-author__user-card" data-async-called="true">
                   <div class="tm-user-card__info-container">
                    <div class="tm-user-card__header">
                     <div class="tm-user-card__header-data">
                      <a href="/ru/users/Sravni_Tech/" class="tm-user-card__userpic tm-user-card__userpic_size-40">
                       <div class="tm-entity-image">
                        <img alt="" class="tm-entity-image__pic" src="//habrastorage.org/getpro/habr/avatars/792/688/0ad/7926880ade16dd9cb3033561888f4093.png">
                       </div></a>
                      <div class="tm-user-card__meta">
                       <div class="tm-counter-container karma" title=" 60 голосов " data-v-f7c0e283>
                        <div class="tm-counter-container__header">
                         <!--[-->
                         <div class="karma-display positive" data-v-f7c0e283 data-v-7635202e>
                          50
                         </div><!----><!--]-->
                        </div>
                        <div class="tm-counter-container__footer">
                         <!--[-->
                         <div class="karma-text" data-v-f7c0e283>
                          Карма
                         </div><!--teleport start--><!--teleport end--><!--]-->
                        </div>
                       </div>
                       <div class="tm-counter-container" title="Рейтинг пользователя">
                        <div class="tm-counter-container__header">
                         <!--[--><!--[--><!--]-->
                         <div class="tm-votes-lever tm-votes-lever tm-votes-lever_appearance-rating">
                          <!---->
                          <div class="tm-votes-lever__score tm-votes-lever__score_appearance-rating tm-votes-lever__score">
                           <!--[--><span><span class="tm-votes-lever__score-counter tm-votes-lever__score-counter_rating tm-votes-lever__score-counter" data-test-id="votes-score-counter">12.9</span></span><!--]-->
                          </div><!---->
                         </div><!--]-->
                        </div>
                        <div class="tm-counter-container__footer">
                         <!--[--><span class="tm-rating__text tm-rating__text">Рейтинг</span><!--]-->
                        </div>
                       </div>
                      </div>
                     </div>
                    </div>
                    <div class="tm-user-card__info tm-user-card__info_variant-article tm-user-card__info">
                     <div class="tm-user-card__title tm-user-card__title_variant-article tm-user-card__title">
                      <!----><a href="/ru/users/Sravni_Tech/" class="tm-user-card__nickname tm-user-card__nickname tm-user-card__nickname_variant-article"> @Sravni_Tech</a><!---->
                     </div>
                     <p class="tm-user-card__short-info tm-user-card__short-info_variant-article tm-user-card__short-info" data-test-id="user-card-speciality">Пользователь</p>
                    </div>
                   </div><!---->
                   <div class="tm-user-card__buttons tm-user-card__buttons_variant-article tm-user-card__buttons">
                    <!---->
                    <div class="tm-user-card__button">
                     <div class="tm-button-follow tm-user-card__button-follow">
                      <!---->
                      <button class="tm-button-follow__button tm-button-follow__button_big" data-test-id="follow-button" type="button">Подписаться</button>
                     </div>
                    </div><!---->
                    <div class="tm-user-card__button tm-user-card__button_write" data-test-id="user-card-conversations">
                     <svg class="tm-svg-img tm-user-card__button-icon" height="16" width="16">
                      <title>
                       Отправить сообщение
                      </title><use xlink:href="/img/megazord-v28.7909a852..svg#mail"></use>
                     </svg>
                    </div><!---->
                   </div><!---->
                  </div>
                  <div class="tm-article-author__user-contacts" data-test-id="author-contacts">
                   <!----><!----><!---->
                  </div>
                 </div><!--]-->
                </div><!--]--><!---->
               </section><!----><!--[-->
               <div class="banner-wrapper leaderboard tm-company-article__banner" style="--38f3d936:200px;--78a3cd06:auto;" data-v-f4bf0d24>
                <!--[-->
                <div class="placeholder-wrapper placeholder" data-v-f4bf0d24>
                 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->
                 <div class="adfox-banner-placeholder leaderboard" data-v-12f7bcca>
                  <div class="image loads" data-v-12f7bcca></div>
                  <div class="lines" data-v-12f7bcca>
                   <div class="line loads" data-v-12f7bcca></div>
                   <div class="line loads" data-v-12f7bcca></div>
                   <div class="line loads" data-v-12f7bcca></div>
                  </div>
                 </div><!----><!----><!---->
                </div>
                <div id="adfox_164725660339535756" class="tm-adfox-banner" data-v-f4bf0d24></div><!--]-->
               </div><!----><!--]--><!--]-->
               <div class="tm-article-blocks__comments">
                <div id="publication-comments" class="tm-article-page-comments">
                 <div>
                  <!--[-->
                  <div class="tm-article-comments-counter-link tm-article-comments-counter-button">
                   <a href="/ru/companies/sravni/articles/906964/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style" data-test-id="counter-comments"><!--[-->
                    <svg class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted" height="24" width="24">
                     <title>
                      Комментарии
                     </title><use xlink:href="/img/megazord-v28.7909a852..svg#counter-comments"></use>
                    </svg><span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted"> Комментарии 7 </span><!--]--></a><!---->
                  </div><!--]-->
                 </div>
                </div>
               </div><!--[--><!--[--><!--]-->
               <section class="tm-block tm-block tm-block_spacing-bottom">
                <header class="tm-block__header tm-block__header tm-block__header_variant-borderless">
                 <div class="tm-block__header-container">
                  <h2 class="tm-block__title tm-block__title tm-block__title_variant-large">Публикации</h2><!--[--><!--]-->
                 </div><!---->
                </header><!--[-->
                <div class="tm-block__body tm-block__body tm-block__body_variant-condensed-slim">
                 <!--[--><!--[-->
                 <div class="tm-tabs tm-tabs">
                  <div class="">
                   <!--[--><span class="tm-tabs__tab-item">
                    <button class="tm-tabs__tab-link tm-tabs__tab-link_active tm-tabs__tab-link_slim tm-tabs__tab-link">Лучшие за сутки</button></span><span class="tm-tabs__tab-item">
                    <button class="tm-tabs__tab-link tm-tabs__tab-link_slim tm-tabs__tab-link">Похожие</button></span><!--]-->
                  </div><!---->
                 </div>
                 <div class="similar-and-daily__tab-view">
                  <div class="placeholder-wrapper">
                   <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->
                   <div class="tm-placeholder-article-cards">
                    <!--[-->
                    <div class="tm-placeholder-article-card">
                     <div class="tm-placeholder__user">
                      <div class="tm-placeholder__user-pic loads"></div>
                      <div class="tm-placeholder__user-date loads"></div>
                     </div>
                     <div class="tm-placeholder-article-card__title">
                      <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div>
                      <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div>
                     </div>
                     <div class="tm-placeholder-article-card__icons tm-placeholder__counters">
                      <!--[-->
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div><!--]-->
                     </div>
                    </div>
                    <div class="tm-placeholder-article-card">
                     <div class="tm-placeholder__user">
                      <div class="tm-placeholder__user-pic loads"></div>
                      <div class="tm-placeholder__user-date loads"></div>
                     </div>
                     <div class="tm-placeholder-article-card__title">
                      <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div>
                      <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div>
                     </div>
                     <div class="tm-placeholder-article-card__icons tm-placeholder__counters">
                      <!--[-->
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div><!--]-->
                     </div>
                    </div>
                    <div class="tm-placeholder-article-card">
                     <div class="tm-placeholder__user">
                      <div class="tm-placeholder__user-pic loads"></div>
                      <div class="tm-placeholder__user-date loads"></div>
                     </div>
                     <div class="tm-placeholder-article-card__title">
                      <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div>
                      <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div>
                     </div>
                     <div class="tm-placeholder-article-card__icons tm-placeholder__counters">
                      <!--[-->
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div><!--]-->
                     </div>
                    </div>
                    <div class="tm-placeholder-article-card">
                     <div class="tm-placeholder__user">
                      <div class="tm-placeholder__user-pic loads"></div>
                      <div class="tm-placeholder__user-date loads"></div>
                     </div>
                     <div class="tm-placeholder-article-card__title">
                      <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div>
                      <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div>
                     </div>
                     <div class="tm-placeholder-article-card__icons tm-placeholder__counters">
                      <!--[-->
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div><!--]-->
                     </div>
                    </div>
                    <div class="tm-placeholder-article-card">
                     <div class="tm-placeholder__user">
                      <div class="tm-placeholder__user-pic loads"></div>
                      <div class="tm-placeholder__user-date loads"></div>
                     </div>
                     <div class="tm-placeholder-article-card__title">
                      <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div>
                      <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div>
                     </div>
                     <div class="tm-placeholder-article-card__icons tm-placeholder__counters">
                      <!--[-->
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div><!--]-->
                     </div>
                    </div><!--]-->
                   </div><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->
                  </div><!---->
                 </div><!--]--><!--]-->
                </div><!--]--><!---->
               </section><!--[--><!--[-->
               <div>
                <div class="placeholder-wrapper">
                 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->
                 <div class="tm-placeholder-promo">
                  <div class="tm-placeholder-promo__header">
                   <div class="tm-placeholder__line tm-placeholder__line_promo-title"></div>
                  </div>
                  <div class="tm-placeholder-promo__body">
                   <div class="tm-placeholder-promo__posts">
                    <div class="tm-placeholder-promo__post">
                     <div class="tm-placeholder-promo__image"></div>
                     <div class="tm-placeholder__line tm-placeholder__line_post-title"></div>
                    </div>
                    <div class="tm-placeholder-promo__post">
                     <div class="tm-placeholder-promo__image"></div>
                     <div class="tm-placeholder__line tm-placeholder__line_post-title"></div>
                    </div>
                    <div class="tm-placeholder-promo__post">
                     <div class="tm-placeholder-promo__image"></div>
                     <div class="tm-placeholder__line tm-placeholder__line_post-title"></div>
                    </div>
                   </div>
                   <div class="tm-placeholder-promo__dots">
                    <div class="tm-placeholder-promo__dot"></div>
                    <div class="tm-placeholder-promo__dot"></div>
                    <div class="tm-placeholder-promo__dot"></div>
                   </div>
                  </div>
                 </div><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->
                </div>
               </div>
               <div>
                <div class="placeholder-wrapper">
                 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->
                 <div class="tm-placeholder-inset tm-placeholder-salary">
                  <div class="tm-placeholder-inset__header">
                   <div class="tm-placeholder__line tm-placeholder__line_inset-header loads"></div>
                  </div>
                  <div class="tm-placeholder-salary__body">
                   <div class="tm-placeholder-salary__text">
                    <div class="tm-placeholder__line tm-placeholder__line_salary_average"></div>
                    <div class="tm-placeholder-salary__description">
                     <div class="tm-placeholder__line loads"></div>
                     <div class="tm-placeholder__line loads"></div>
                     <div class="tm-placeholder__line loads"></div>
                     <div class="tm-placeholder__line loads"></div>
                    </div>
                   </div>
                   <div class="tm-placeholder-salary__image loads"></div>
                  </div>
                  <div class="tm-placeholder-inset__footer tm-placeholder-inset__footer_salary">
                   <div class="tm-placeholder__line tm-placeholder__line_inset-footer loads"></div>
                  </div>
                 </div><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->
                </div>
               </div><!--]--><!--]--><!----><!--[--><!--]--><!--]-->
              </div><!--]--><!--]-->
             </div>
            </div><!--]--><!--]-->
           </div>
          </div>
          <div class="tm-page__sidebar">
           <!--[-->
           <div class="tm-layout-sidebar">
            <div class="tm-layout-sidebar__placeholder_initial"></div>
            <div class="tm-sexy-sidebar_initial tm-sexy-sidebar" style="margin-top:0px;">
             <!--[--><!--]--><!---->
             <div class="tm-layout-sidebar__ads_initial tm-layout-sidebar__ads">
              <div class="banner-wrapper half-page tm-layout-sidebar__banner tm-layout-sidebar__banner_top" style="--38f3d936:600px;--78a3cd06:auto;" data-v-f4bf0d24>
               <!--[-->
               <div class="placeholder-wrapper placeholder" data-v-f4bf0d24>
                <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->
                <div class="adfox-banner-placeholder half-page" data-v-12f7bcca>
                 <div class="image loads" data-v-12f7bcca></div>
                 <div class="lines" data-v-12f7bcca>
                  <div class="line loads" data-v-12f7bcca></div>
                  <div class="line loads" data-v-12f7bcca></div>
                  <div class="line loads" data-v-12f7bcca></div>
                 </div>
                </div><!----><!----><!---->
               </div>
               <div id="adfox_164725680533065327" class="tm-adfox-banner" data-v-f4bf0d24></div><!--]-->
              </div>
             </div><!--[-->
             <section class="tm-block tm-block tm-block_spacing-bottom">
              <header class="tm-block__header tm-block__header">
               <div class="tm-block__header-container">
                <h2 class="tm-block__title tm-block__title">Информация</h2><!--[--><!--]-->
               </div><!---->
              </header><!--[-->
              <div class="tm-block__body tm-block__body">
               <!--[-->
               <div class="tm-company-basic-info">
                <dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap">
                 <dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">
                  Сайт
                 </dt>
                 <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body">
                  <!--[--><a class="tm-company-basic-info__link" href="https://www.sravni.ru" target="_blank">www.sravni.ru</a><!--]-->
                 </dd>
                </dl>
                <dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap">
                 <dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">
                  Дата регистрации
                 </dt>
                 <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body">
                  <!--[--><time datetime="2022-01-11T12:13:19.000Z" title="2022-01-11, 15:13">11 января 2022</time><!--]-->
                 </dd>
                </dl>
                <dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap">
                 <dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">
                  Дата основания
                 </dt>
                 <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body">
                  <!--[--><span>2009</span><!--]-->
                 </dd>
                </dl>
                <dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap">
                 <dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">
                  Численность
                 </dt>
                 <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body">
                  <!--[-->501–1 000 человек<!--]-->
                 </dd>
                </dl>
                <dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap">
                 <dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">
                  Местоположение
                 </dt>
                 <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body">
                  <!--[-->Россия<!--]-->
                 </dd>
                </dl><!---->
               </div><!--]-->
              </div><!--]--><!---->
             </section>
             <div class="tm-company-widgets">
              <!--[--><!--]-->
             </div><!---->
             <div></div><!--]-->
             <div class="banner-wrapper medium-rectangle tm-layout-sidebar__banner tm-layout-sidebar__banner_bottom" style="--38f3d936:250px;--78a3cd06:auto;" data-v-f4bf0d24>
              <!--[-->
              <div class="placeholder-wrapper placeholder" data-v-f4bf0d24>
               <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->
               <div class="adfox-banner-placeholder medium-rectangle" data-v-12f7bcca>
                <div class="image loads" data-v-12f7bcca></div>
                <div class="lines" data-v-12f7bcca>
                 <div class="line loads" data-v-12f7bcca></div>
                 <div class="line loads" data-v-12f7bcca></div>
                 <div class="line loads" data-v-12f7bcca></div>
                </div>
               </div><!----><!----><!---->
              </div>
              <div id="adfox_164725691003361602" class="tm-adfox-banner" data-v-f4bf0d24></div><!--]-->
             </div>
            </div>
           </div><!--]-->
          </div>
         </div><!----><!--]-->
        </div>
       </div>
      </main><!---->
     </div>
     <div class="tm-footer-menu">
      <div class="tm-page-width">
       <!--[-->
       <div class="tm-footer-menu__container">
        <!--[-->
        <div class="tm-footer-menu__block">
         <p class="tm-footer-menu__block-title">Ваш аккаунт</p>
         <div class="tm-footer-menu__block-content">
          <ul class="tm-footer-menu__list">
           <!--[-->
           <li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/companies/sravni/articles/906964/&amp;hl=ru" rel="nofollow" target="_self">Войти</a></li>
           <li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/companies/sravni/articles/906964/&amp;hl=ru" rel="nofollow" target="_self">Регистрация</a></li><!--]-->
          </ul>
         </div>
        </div>
        <div class="tm-footer-menu__block">
         <p class="tm-footer-menu__block-title">Разделы</p>
         <div class="tm-footer-menu__block-content">
          <ul class="tm-footer-menu__list">
           <!--[-->
           <li class="tm-footer-menu__list-item"><a href="/ru/articles/" class="footer-menu__item-link">Статьи</a></li>
           <li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">Новости</a></li>
           <li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">Хабы</a></li>
           <li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">Компании</a></li>
           <li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">Авторы</a></li>
           <li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">Песочница</a></li><!--]-->
          </ul>
         </div>
        </div>
        <div class="tm-footer-menu__block">
         <p class="tm-footer-menu__block-title">Информация</p>
         <div class="tm-footer-menu__block-content">
          <ul class="tm-footer-menu__list">
           <!--[-->
           <li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">Устройство сайта</a></li>
           <li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">Для авторов</a></li>
           <li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">Для компаний</a></li>
           <li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">Документы</a></li>
           <li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement/?hl=ru_RU" target="_blank">Соглашение</a></li>
           <li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/?hl=ru_RU" target="_blank">Конфиденциальность</a></li><!--]-->
          </ul>
         </div>
        </div>
        <div class="tm-footer-menu__block">
         <p class="tm-footer-menu__block-title">Услуги</p>
         <div class="tm-footer-menu__block-content">
          <ul class="tm-footer-menu__list">
           <!--[-->
           <li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/corporate-blogs/" target="_blank">Корпоративный блог</a></li>
           <li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/advertising/" target="_blank">Медийная реклама</a></li>
           <li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/native-special/" target="_blank">Нативные проекты</a></li>
           <li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/education-programs/" target="_blank">Образовательные программы</a></li>
           <li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/hello-startup/" target="_blank">Стартапам</a></li><!--]-->
          </ul>
         </div>
        </div><!--]-->
       </div><!--]-->
      </div>
     </div>
     <div class="tm-footer">
      <div class="tm-page-width">
       <!--[-->
       <div class="tm-footer__container">
        <!---->
        <div class="tm-footer__social">
         <!--[--><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank">
          <svg class="tm-svg-img tm-svg-icon" height="24" width="24">
           <title>
            Facebook
           </title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-facebook"></use>
          </svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank">
          <svg class="tm-svg-img tm-svg-icon" height="24" width="24">
           <title>
            Twitter
           </title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-twitter"></use>
          </svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank">
          <svg class="tm-svg-img tm-svg-icon" height="24" width="24">
           <title>
            VK
           </title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-vk"></use>
          </svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank">
          <svg class="tm-svg-img tm-svg-icon" height="24" width="24">
           <title>
            Telegram
           </title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-telegram"></use>
          </svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank">
          <svg class="tm-svg-img tm-svg-icon" height="24" width="24">
           <title>
            Youtube
           </title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-youtube"></use>
          </svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://dzen.ru/habr" rel="nofollow noopener noreferrer" target="_blank">
          <svg class="tm-svg-img tm-svg-icon" height="24" width="24">
           <title>
            Яндекс Дзен
           </title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-dzen"></use>
          </svg></a><!--]-->
        </div><!--teleport start--><!--teleport end-->
        <button class="tm-footer__link"><!----> Настройка языка</button><a href="/ru/feedback/" class="tm-footer__link">Техническая поддержка</a>
        <div class="tm-footer-copyright">
         <span class="tm-copyright"><span class="tm-copyright__years">© 2006–2025, </span><span class="tm-copyright__name"><a class="tm-copyright__link" href="https://company.habr.com/" rel="noopener" target="_blank">Habr</a></span></span>
        </div>
       </div><!--]-->
      </div>
     </div><!----><!--]-->
    </div><!---->
   </div>
   <script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"906964":{"id":"906964","timePublished":"2025-05-06T11:47:10+00:00","isCorporative":true,"lang":"ru","titleHtml":"Как на самом деле хранятся изображения?","leadData":{"textHtml":"\u003Cp\u003EЭтот пост — погружение в кроличью нору. Разработчик Монсеф Аббад задумался о изображениях — вероятно, после \u003Ca href=\"https:\u002F\u002Fcefboud.com\u002Fposts\u002Fcompression\u002F\"\u003Eнедавнего изучения\u003C\u002Fa\u003E им некоторых схем компрессии. Общеизвестно, что изображения бывают либо полутоновыми, либо RGB, когда новые цвета создаются на основе смешения красного, зелёного и синего. Но для хранения изображения требуется нечто большее, чем просто выравнивание трехбайтовых значений RGB. \u003C\u002Fp\u003E\u003Cp\u003EЧто-то в этой идее пробудило любопытство автора, поэтому в статье он попытался удовлетворить его и ответить на вопрос: как на самом деле хранятся изображения?\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fc9d\u002Fb2d\u002Fc46\u002Fc9db2dc468e3c319b54d1ad8599f8898.jpg","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fc9d\u002Fb2d\u002Fc46\u002Fc9db2dc468e3c319b54d1ad8599f8898.jpg","fit":"cover","positionY":0,"positionX":0}},"editorVersion":"2.0","postType":"article","postLabels":[{"type":"translation","typeOf":"system","title":"Перевод","data":{"originalAuthorName":"Moncef Abboud","originalUrl":"https:\u002F\u002Fcefboud.com\u002Fposts\u002Fimage-formats\u002F"}}],"author":{"id":"3773112","alias":"Sravni_Tech","fullname":null,"avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F792\u002F688\u002F0ad\u002F7926880ade16dd9cb3033561888f4093.png","speciality":null,"scoreStats":{"score":50,"votesCount":60},"rating":12.9,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"donationsMethod":null,"isInBlacklist":null,"careerProfile":null},"statistics":{"commentsCount":7,"favoritesCount":61,"readingCount":2974,"score":30,"votesCount":21,"votesCountPlus":21,"votesCountMinus":0},"hubs":[{"id":"22885","alias":"sravni","type":"corporative","title":"Блог компании Сравни","titleHtml":"Блог компании Сравни","isProfiled":false,"relatedData":null},{"id":"17748","alias":"go","type":"collective","title":"Go","titleHtml":"Go","isProfiled":true,"relatedData":null},{"id":"359","alias":"programming","type":"collective","title":"Программирование","titleHtml":"Программирование","isProfiled":true,"relatedData":null},{"id":"17175","alias":"image_processing","type":"collective","title":"Обработка изображений","titleHtml":"Обработка изображений","isProfiled":true,"relatedData":null}],"flows":[{"id":"1","alias":"develop","title":"Разработка","titleHtml":"Разработка"}],"relatedData":{"vote":null,"unreadCommentsCount":0,"bookmarked":false,"canComment":false,"canEdit":false,"canViewVotes":false,"votePlus":{"canVote":false,"isChargeEnough":false,"isKarmaEnough":false,"isVotingOver":false,"isPublicationLimitEnough":false},"voteMinus":{"canVote":false,"isChargeEnough":false,"isKarmaEnough":false,"isVotingOver":false,"isPublicationLimitEnough":false},"canModerateComments":false,"trackerSubscribed":false,"emailSubscribed":false},"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fcd5\u002Ff36\u002Fc82\u002Fcd5f36c82acd0a23a6e25dc2f8785b41.jpg\" width=\"1920\" height=\"1080\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fcd5\u002Ff36\u002Fc82\u002Fcd5f36c82acd0a23a6e25dc2f8785b41.jpg 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fcd5\u002Ff36\u002Fc82\u002Fcd5f36c82acd0a23a6e25dc2f8785b41.jpg 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EЭтот пост — погружение в кроличью нору. Разработчик Монсеф Аббад задумался о изображениях — вероятно, после \u003Ca href=\"https:\u002F\u002Fcefboud.com\u002Fposts\u002Fcompression\u002F\"\u003Eнедавнего изучения\u003C\u002Fa\u003E им некоторых схем компрессии. Общеизвестно, что изображения бывают либо полутоновыми, либо RGB, когда новые цвета создаются на основе смешения красного, зелёного и синего. Но для хранения изображения требуется нечто большее, чем просто выравнивание трехбайтовых значений RGB. \u003C\u002Fp\u003E\u003Cp\u003EЧто-то в этой идее пробудило любопытство автора, поэтому в статье он попытался удовлетворить его и ответить на вопрос: как на самом деле хранятся изображения?\u003C\u002Fp\u003E\u003Chr\u002F\u003E\u003Ch2\u003EОсновы  \u003C\u002Fh2\u003E\u003Cp\u003EИзображение — это набор пикселей. Пиксель —  наименьшая единица цвета в изображении. Рассмотрим следующее изображение из известного \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FMNIST_database\"\u003Eдатасета MNIST\u003C\u002Fa\u003E:\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F1a7\u002Fed6\u002F521\u002F1a7ed652160402b799d4121884ea8648.png\" width=\"3164\" height=\"1660\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F1a7\u002Fed6\u002F521\u002F1a7ed652160402b799d4121884ea8648.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F1a7\u002Fed6\u002F521\u002F1a7ed652160402b799d4121884ea8648.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EЭто изображение состоит из 28x28 пикселей (или квадратов). Оно выполнено в градациях серого, то есть каждый пиксель имеет значение от 0 до 255, где 0 — чёрный, а 255 — белый.\u003C\u002Fp\u003E\u003Cp\u003EА как насчет цветных изображений? В них также используются пиксели, но каждый пиксель хранится в виде RGB-триплета. Для каждого пикселя 3 байта представляют его цвет: красный, зеленый и синий. (0, 0, 0) — это чёрный цвет, а (255, 255, 255) — белый. Суть в том, что при отсутствии светлого (0, 0, 0), цвет — чёрный, а смешивая максимальное количество каждого цвета, вы получаете белый. Красный — это (255, 0, 0), зеленый — (0, 255, 0), а синий — (0, 0, 255).\u003C\u002Fp\u003E\u003Cp\u003ERGB может иметь четвёртый компонент, называемый альфа, что делает его RGBA. Альфа указывает на непрозрачность или прозрачность пикселя. Он полезен при создании изображений, поскольку определяет, как обрабатывается прозрачность. Чем прозрачнее пиксель, тем меньше он скрывает фон за ним. При наложении двух изображений альфа-значение каждого пикселя определяет видимость фонового изображения через соответствующий пиксель изображения переднего плана.\u003C\u002Fp\u003E\u003Cp\u003EРассмотрим знаменитый клетчатый узор, который часто используется для обозначения прозрачности. В левой части изображения непрозрачность высокая (альфа-значение высокое), что делает фон невидимым. Напротив, в правой части, где непрозрачность ниже (альфа низкая), клетчатый фон становится видимым.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F340\u002F53d\u002F973\u002F34053d9735f43dc00fc27c27074e7179.jpg\" width=\"800\" height=\"532\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F340\u002F53d\u002F973\u002F34053d9735f43dc00fc27c27074e7179.jpg 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F340\u002F53d\u002F973\u002F34053d9735f43dc00fc27c27074e7179.jpg 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EЕсли мы храним цветное изображение (3 байта на пиксель) размером 1920x1080 без сжатия, то только для одного изображения нам потребуется 1920x1080x3 = 6 220 800 байт (около 6 МБ)!\u003C\u002Fp\u003E\u003Cp\u003E1080p — обычное дело для видео, в то время как 240p (разрешение VHS) считается низким качеством. 480p — это нормально и соответствует качеству DVD.\u003C\u002Fp\u003E\u003Cp\u003EЕсли бы мы передавали несжатое видео 1080p с частотой 24 кадра в секунду, это потребовало бы более 1 гигабита в секунду, что просто колоссально! Поэтому, если не использовать сжатие и другие ухищрения, потоковая передача высококачественного видео будет невозможна.\u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fcefboud.com\u002Fposts\u002Fcompression\u002F\"\u003EАлгоритмы сжатия без потерь\u003C\u002Fa\u003E обычно достигают коэффициента сжатия в лучшем случае 3:4. Алгоритмы, которые достигают таких высоких коэффициентов, часто требуют больших вычислительных затрат и работают медленно, что делает их непригодными для потоковой передачи в реальном времени. Даже коэффициента 3:4 недостаточно для передачи видео высокого разрешения с высокой частотой кадров.\u003C\u002Fp\u003E\u003Cp\u003EИменно здесь на помощь приходит сжатие с потерями. Отбрасывая часть данных, мы можем добиться гораздо лучшего коэффициента сжатия. Схемы сжатия с потерями часто включают параметр качества, указывающий, в какой степени мы готовы пожертвовать качеством в обмен на лучший коэффициент сжатия.\u003C\u002Fp\u003E\u003Ch2\u003EФорматы без потерь\u003C\u002Fh2\u003E\u003Ch3\u003EGIF\u003C\u002Fh3\u003E\u003Cp\u003EGraphical Interchange Format, GIF (произносится как «gif» от «gift») — это формат сжатия изображений без потерь. В нем используется фиксированная палитра из 256 цветов, каждый из которых задается 3 байтами для RGB. И вместо того, чтобы использовать 3 байта для кодирования каждого пикселя, мы используем индекс, указывающий на один из цветов в палитре. Идея здесь в том, что палитра содержит достаточно оттенков для передачи изображения. Таким образом, при 256 цветах нам нужен всего 1 байт для хранения индекса и коэффициент сжатия составляет 3:1. Хотя маловероятно, что изображение в реальном мире имеет только 256 цветов, некоторая форма сжатия должна была произойти раньше. Однако сам GIF не отвечает за это сжатие.\u003C\u002Fp\u003E\u003Cp\u003EИзображения хранятся в виде массива w × h 8-битных индексов палитры, которые затем кодируются с помощью техники \u003Ca href=\"https:\u002F\u002Fcefboud.com\u002Fposts\u002Fcompression\u002F#primer-on-compression\"\u003ELZ \u003C\u002Fa\u003E(повторяющиеся последовательности с обратной ссылкой).\u003C\u002Fp\u003E\u003Cp\u003EРазумеется, GIF известен тем, что может хранить несколько изображений в одном файле, что позволяет создавать анимированные изображения.\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2e0\u002Fb3c\u002Fb52\u002F2e0b3cb525620acc688b87f5a39940cb.gif\" width=\"330\" height=\"216\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2e0\u002Fb3c\u002Fb52\u002F2e0b3cb525620acc688b87f5a39940cb.gif 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2e0\u002Fb3c\u002Fb52\u002F2e0b3cb525620acc688b87f5a39940cb.gif 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EДавайте посмотрим на реализацию GIF в стандартной библиотеке Go. Полагаю, изучение того, как список изображений и задержки между ними используются для создания правильного GIF, поможет лучше понять этот формат:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003Eimages := []*image.Paletted{...}\n\u002F\u002F The successive delay times, one per frame, in 100ths of a second\n\u002F\u002F In this example, we have three images with 0.5 second delay between each\ndelays := []int{50,50,50} \nf, _ := os.OpenFile(\"amazing.gif\", os.O_WRONLY|os.O_CREATE, 0600)\ndefer f.Close()\ngif.EncodeAll(f, &amp;gif.GIF{\n    Image: images,\n    Delay: delays, \n})\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EAPI для создания GIF в Go достаточно прост: нужно передать список изображений с палитрой и задержки между ними и сохранить результат в нужный нам файл.\u003C\u002Fp\u003E\u003Cp\u003EВзглянем на структуру \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fgolang\u002Fgo\u002Fblob\u002Ff6d17c540024418ca8a92371931b1b4fb076d2b6\u002Fsrc\u002Fimage\u002Fimage.go#L1148-L1159\"\u003EPaletted\u003C\u002Fa\u003E:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage image\n\n\u002F\u002F Paletted is an in-memory image of uint8 indices into a given palette.\ntype Paletted struct {\n\t\u002F\u002F Pix holds the image's pixels, as palette indices. The pixel at\n\t\u002F\u002F (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1].\n\tPix []uint8\n\t\u002F\u002F Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n\tStride int\n\t\u002F\u002F Rect is the image's bounds.\n\tRect Rectangle\n\t\u002F\u002F Palette is the image's palette.\n\tPalette color.Palette\n}\n\ntype Palette []Color\n\n\u002F\u002F Color can convert itself to alpha-premultiplied 16-bits per channel RGBA.\n\u002F\u002F The conversion may be lossy.\ntype Color interface {\n\t\u002F\u002F RGBA returns the alpha-premultiplied red, green, blue and alpha values\n\t\u002F\u002F for the color. Each value ranges within [0, 0xffff], but is represented\n\t\u002F\u002F by a uint32 so that multiplying by a blend factor up to 0xffff will not\n\t\u002F\u002F overflow.\n\t\u002F\u002F\n\t\u002F\u002F An alpha-premultiplied color component c has been scaled by alpha (a),\n\t\u002F\u002F so has valid values 0 &lt;= c &lt;= a.\n\tRGBA() (r, g, b, a uint32)\n}\n\n\u002F\u002F A Rectangle contains the points with Min.X &lt;= X &lt; Max.X, Min.Y &lt;= Y &lt; Max.Y.\n\u002F\u002F It is well-formed if Min.X &lt;= Max.X and likewise for Y. Points are always\n\u002F\u002F well-formed. A rectangle's methods always return well-formed outputs for\n\u002F\u002F well-formed inputs.\ntype Rectangle struct {\n\tMin, Max Point\n}\n\n\u002F\u002F A Point is an X, Y coordinate pair. The axes increase right and down.\ntype Point struct {\n\tX, Y int\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПалитра определяется следующими полями:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003ERectangle\u003C\u002Fstrong\u003E, который определяется верхней левой точкой (min) и нижней правой точкой (max). Просто и эффективно! Чтобы упростить задачу, предположим, что \u003Ccode\u003EMin = (0, 0)\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Ecolor.Palette\u003C\u002Fstrong\u003E — массив интерфейсов \u003Ccode\u003EColor\u003C\u002Fcode\u003E, служащий, по сути, хранилищем для используемых RGB-цветов.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EStride \u003C\u002Fstrong\u003E— расстояние между двумя вертикально соседними пикселями; часто это длина строки, т. е. \u003Ccode\u003EMax.X - Min.X\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EPix \u003C\u002Fstrong\u003E— фактические данные изображения в виде индексов цветовой палитры. Массив одномерный, но представляет собой двумерное изображение. Допустим, \u003Ccode\u003EMin = (0, 0)\u003C\u002Fcode\u003E. Эффективная прогрессия выглядит так:\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003E(0, 0)\u003C\u002Fcode\u003E, \u003Ccode\u003E(1, 0)\u003C\u002Fcode\u003E, …, \u003Ccode\u003E(Max.X-1, 0)\u003C\u002Fcode\u003E,\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003E(0, 1)\u003C\u002Fcode\u003E, \u003Ccode\u003E(1, 1)\u003C\u002Fcode\u003E, …, \u003Ccode\u003E(Max.X-1, 1)\u003C\u002Fcode\u003E,\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E…,\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003E(0, Max.Y-1)\u003C\u002Fcode\u003E, \u003Ccode\u003E(1, Max.Y-1)\u003C\u002Fcode\u003E, …, \u003Ccode\u003E(Max.X-1, Max.Y-1)\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EПроще говоря, \u003Ccode\u003Eimage.Paletted\u003C\u002Fcode\u003E — это список цветов и список пикселей, ссылающихся на эти цвета.\u003C\u002Fp\u003E\u003Cp\u003EПалитризованные изображения и задержки используются для инициализации GIF-структуры. Взглянем на неё:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003E\u002F\u002F GIF represents the possibly multiple images stored in a GIF file.\ntype GIF struct {\n\tImage []*image.Paletted \u002F\u002F The successive images.\n\tDelay []int             \u002F\u002F The successive delay times, one per frame, in 100ths of a second.\n\t\u002F\u002F LoopCount controls the number of times an animation will be\n\t\u002F\u002F restarted during display.\n\t\u002F\u002F A LoopCount of 0 means to loop forever.\n\t\u002F\u002F A LoopCount of -1 means to show each frame only once.\n\t\u002F\u002F Otherwise, the animation is looped LoopCount+1 times.\n\tLoopCount int\n\t\u002F\u002F Disposal is the successive disposal methods, one per frame. For\n\t\u002F\u002F backwards compatibility, a nil Disposal is valid to pass to EncodeAll,\n\t\u002F\u002F and implies that each frame's disposal method is 0 (no disposal\n\t\u002F\u002F specified).\n\tDisposal []byte\n\t\u002F\u002F Config is the global color table (palette), width and height. A nil or\n\t\u002F\u002F empty-color.Palette Config.ColorModel means that each frame has its own\n\t\u002F\u002F color table and there is no global color table. Each frame's bounds must\n\t\u002F\u002F be within the rectangle defined by the two points (0, 0) and\n\t\u002F\u002F (Config.Width, Config.Height).\n\t\u002F\u002F\n\t\u002F\u002F For backwards compatibility, a zero-valued Config is valid to pass to\n\t\u002F\u002F EncodeAll, and implies that the overall GIF's width and height equals\n\t\u002F\u002F the first frame's bounds' Rectangle.Max point.\n\tConfig image.Config\n\t\u002F\u002F BackgroundIndex is the background index in the global color table, for\n\t\u002F\u002F use with the DisposalBackground disposal method.\n\tBackgroundIndex byte\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EОтметим, что количество повторов (циклов) настраивается и по умолчанию равно бесконечности, если \u003Ccode\u003ELoopCount == -1\u003C\u002Fcode\u003E. Также мы видим, что ширина и высота GIF либо задаются явно, либо определяются из размеров первого изображения. Это означает, что изображения внутри GIF могут иметь разные размеры, и здесь становятся важными значения \u003Ccode\u003EMin \u003C\u002Fcode\u003Eи \u003Ccode\u003EMax \u003C\u002Fcode\u003Eв прямоугольнике каждого изображения: они не обязательно должны быть равны глобальным \u003Ccode\u003EMin \u003C\u002Fcode\u003Eи \u003Ccode\u003EMax\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003EDisposal \u003C\u002Fcode\u003Eуказывает, как следует обрабатывать предыдущий кадр. Этот параметр напрямую связан с альфа-каналом RGBA, то есть с параметром прозрачности. Основные методы удаления предыдущего кадра такие:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EUnspecified (Ничего)\u003C\u002Fstrong\u003E. Полностью заменить одно полноразмерное непрозрачное изображение другим.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EDo Not Dispose (Оставить как есть)\u003C\u002Fstrong\u003E. Все пиксели, не покрытые следующим кадром, продолжают отображаться.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003ERestore to Background (Восстановить фон)\u003C\u002Fstrong\u003E. Показать изображение, указанное в \u003Ccode\u003EBackgroundIndex\u003C\u002Fcode\u003E, через прозрачные пиксели нового кадра.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E\u003Ccode\u003EConfig\u003C\u002Fcode\u003E также может содержать \u003Ccode\u003Ecolor.Palette\u003C\u002Fcode\u003E, которая является глобальной палитрой, общей для всех изображений. У каждого изображения может быть своя палитра, или они могут использовать одну для экономии места, если они достаточно похожи.\u003C\u002Fp\u003E\u003Cp\u003EИтак. Теперь, когда мы знаем, как выглядят наши структуры, перейдем к \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fgolang\u002Fgo\u002Fblob\u002Ff6d17c540024418ca8a92371931b1b4fb076d2b6\u002Fsrc\u002Fimage\u002Fgif\u002Fwriter.go#L364\"\u003Eсамому процессу кодинга\u003C\u002Fa\u003E:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003E\u002F\u002F EncodeAll writes the images in g to w in GIF format with the\n\u002F\u002F given loop count and delay between frames.\nfunc EncodeAll(w io.Writer, g *GIF) error {\n\tif len(g.Image) == 0 {\n\t\treturn errors.New(\"gif: must provide at least one image\")\n\t}\n\tif len(g.Image) != len(g.Delay) {\n\t\treturn errors.New(\"gif: mismatched image and delay lengths\")\n\t}\n\te := encoder{g: *g}\n    \u002F\u002F ...\n\n    \n\tif e.g.Config == (image.Config{}) {\n        \u002F\u002F If the image has no Config, we use the first image dimensions.\n\t\tp := g.Image[0].Bounds().Max\n\t\te.g.Config.Width = p.X\n\t\te.g.Config.Height = p.Y\n\t} else if e.g.Config.ColorModel != nil {\n\t\tif _, ok := e.g.Config.ColorModel.(color.Palette); !ok {\n\t\t\treturn errors.New(\"gif: GIF color model must be a color.Palette\")\n\t\t}\n\t}\n\n    \u002F\u002F ensure we have a proper write to send our data to\n\tif ww, ok := w.(writer); ok {\n\t\te.w = ww\n\t} else {\n\t\te.w = bufio.NewWriter(w)\n\t}\n\n\te.writeHeader()\n\tfor i, pm := range g.Image {\n\t\tdisposal := uint8(0)\n\t\tif g.Disposal != nil {\n\t\t\tdisposal = g.Disposal[i]\n\t\t}\n\t\te.writeImageBlock(pm, g.Delay[i], disposal)\n\t}\n\te.writeByte(sTrailer) \u002F\u002F sTrailer = 0x3B =&gt; ascii semi-colon to signify EOF\n\te.flush()\n\treturn e.err\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EМне нравится такой код! Читается как обычный абзац. Проверка на ошибки, установка конфига, запись заголовка, затем запись каждого блока изображения и, наконец, запись символа EOF и сброс буфера.\u003C\u002Fp\u003E\u003Cp\u003EВот \u003Ccode\u003EwriteHeader\u003C\u002Fcode\u003E с некоторыми дополнительными комментариями от меня:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003Efunc (e *encoder) writeHeader() {\n\tif e.err != nil {\n\t\treturn\n\t}\n\t_, e.err = io.WriteString(e.w, \"GIF89a\") \u002F\u002F Magic byte\n\tif e.err != nil {\n\t\treturn\n\t}\n\n\t\u002F\u002F Logical screen width and height.\n\t\u002F\u002F written in Little Endian\n\tbyteorder.LEPutUint16(e.buf[0:2], uint16(e.g.Config.Width))\n\tbyteorder.LEPutUint16(e.buf[2:4], uint16(e.g.Config.Height))\n\te.write(e.buf[:4])\n\n    \n\tif p, ok := e.g.Config.ColorModel.(color.Palette); ok &amp;&amp; len(p) &gt; 0 {\n\t\t\u002F\u002F write the global palette if we have it\n\t\tpaddedSize := log2(len(p)) \u002F\u002F Size of Global Color Table: 2^(1+n).\n\t\te.buf[0] = fColorTable | uint8(paddedSize)\n\t\te.buf[1] = e.g.BackgroundIndex\n\t\te.buf[2] = 0x00 \u002F\u002F Pixel Aspect Ratio.\n\t\te.write(e.buf[:3])\n\t\tvar err error\n\t\te.globalCT, err = encodeColorTable(e.globalColorTable[:], p, paddedSize)\n\t\tif err != nil &amp;&amp; e.err == nil {\n\t\t\te.err = err\n\t\t\treturn\n\t\t}\n\t\te.write(e.globalColorTable[:e.globalCT])\n\t} else {\n\t\t\u002F\u002F All frames have a local color table, so a global color table\n\t\t\u002F\u002F is not needed.\n\t\te.buf[0] = 0x00\n\t\te.buf[1] = 0x00 \u002F\u002F Background Color Index.\n\t\te.buf[2] = 0x00 \u002F\u002F Pixel Aspect Ratio.\n\t\te.write(e.buf[:3])\n\t}\n\n\t\u002F\u002F Add animation info if necessary.\n\tif len(e.g.Image) &gt; 1 &amp;&amp; e.g.LoopCount &gt;= 0 {\n\t\te.buf[0] = 0x21 \u002F\u002F Extension Introducer.\n\t\te.buf[1] = 0xff \u002F\u002F Application Label.\n\t\te.buf[2] = 0x0b \u002F\u002F Block Size.\n\t\te.write(e.buf[:3])\n\t\t_, err := io.WriteString(e.w, \"NETSCAPE2.0\") \u002F\u002F Application Identifier.\n\t\tif err != nil &amp;&amp; e.err == nil {\n\t\t\te.err = err\n\t\t\treturn\n\t\t}\n\t\te.buf[0] = 0x03 \u002F\u002F Block Size.\n\t\te.buf[1] = 0x01 \u002F\u002F Sub-block Index.\n\t\tbyteorder.LEPutUint16(e.buf[2:4], uint16(e.g.LoopCount))\n\t\te.buf[4] = 0x00 \u002F\u002F Block Terminator.\n\t\te.write(e.buf[:5])\n\t}\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВот цикл, который кодирует таблицу Palette:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003E\tfor i, c := range p {\n\t\tif c == nil {\n\t\t\treturn 0, errors.New(\"gif: cannot encode color table with nil entries\")\n\t\t}\n\t\tvar r, g, b uint8\n\t\t\u002F\u002F It is most likely that the palette is full of color.RGBAs, so they\n\t\t\u002F\u002F get a fast path.\n\t\tif rgba, ok := c.(color.RGBA); ok {\n\t\t\tr, g, b = rgba.R, rgba.G, rgba.B\n\t\t} else {\n\t\t\trr, gg, bb, _ := c.RGBA()\n\t\t\tr, g, b = uint8(rr&gt;&gt;8), uint8(gg&gt;&gt;8), uint8(bb&gt;&gt;8)\n\t\t}\n\t\tdst[3*i+0] = r\n\t\tdst[3*i+1] = g\n\t\tdst[3*i+2] = b\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EНичего сложного. Мы проходим по цветам и последовательно кодируем красные, синие и зелёные байты в целевой буфер.\u003C\u002Fp\u003E\u003Cp\u003EСобственно данные изображения записываются в \u003Ccode\u003EwriteImageBlock\u003C\u002Fcode\u003E. Он немного длинноват, но самый интересный, на мой взгляд, фрагмент:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003E\tfor i, c := range p {\n\t\tif c == nil {\n\t\t\treturn 0, errors.New(\"gif: cannot encode color table with nil entries\")\n\t\t}\n\t\tvar r, g, b uint8\n\t\t\u002F\u002F It is most likely that the palette is full of color.RGBAs, so they\n\t\t\u002F\u002F get a fast path.\n\t\tif rgba, ok := c.(color.RGBA); ok {\n\t\t\tr, g, b = rgba.R, rgba.G, rgba.B\n\t\t} else {\n\t\t\trr, gg, bb, _ := c.RGBA()\n\t\t\tr, g, b = uint8(rr&gt;&gt;8), uint8(gg&gt;&gt;8), uint8(bb&gt;&gt;8)\n\t\t}\n\t\tdst[3*i+0] = r\n\t\tdst[3*i+1] = g\n\t\tdst[3*i+2] = b\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВ оригинальном коде \u003Ccode\u003Erect \u003C\u002Fcode\u003Eимеет имя \u003Ccode\u003Eb\u003C\u002Fcode\u003E. Я переименовал его для наглядности.\u003C\u002Fp\u003E\u003Cp\u003EМы берем массив \u003Ccode\u003EPix \u003C\u002Fcode\u003Eиз нашей палитры изображения, где каждое значение представляет собой индекс в массиве цветов, затем сжимаем его по схеме \u003Ccode\u003Elzww \u003C\u002Fcode\u003Eи записываем.\u003C\u002Fp\u003E\u003Cp\u003EВуаля! В этом и заключается магия кодирования GIF.\u003C\u002Fp\u003E\u003Cp\u003EЯ считаю, что декодер, который отображает GIF-изображение, — то, в чём кроется истинная магия формата. Но это небольшое исследование должно дать нам представление о том, как устроены под капотом все эти реакционные мемы, которые лично я использую слишком часто.\u003C\u002Fp\u003E\u003Cp\u003EНапоследок в этом разделе сделаем до смешного простой GIF: 3 кадра синего, зелёного и красного цвета с 1-секундной задержкой. Запустив \u003Ccode\u003Ego run main.go\u003C\u002Fcode\u003E, мы создадим файл \u003Ccode\u003Ergb.gif\u003C\u002Fcode\u003E, который будет зацикливать эти цвета.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport (\n\t\"fmt\"\n\t\"image\"\n\t\"image\u002Fcolor\"\n\t\"image\u002Fgif\"\n\t\"os\"\n)\n\nfunc main() {\n\tvar w, h int = 240, 240\n\tfileName := \"rgb.gif\"\n\n\tvar palette = []color.Color{\n\t\tcolor.RGBA{0x00, 0x00, 0xff, 0xff}, \u002F\u002F Blue\n\t\tcolor.RGBA{0x00, 0xff, 0x00, 0xff}, \u002F\u002F Green\n\t\tcolor.RGBA{0xff, 0x00, 0x00, 0xff}, \u002F\u002F Red\n\t}\n\n\tvar images []*image.Paletted\n\tvar delays []int\n\tfor frame := 0; frame &lt; len(palette); frame++ {\n\t\timg := image.NewPaletted(image.Rect(0, 0, w, h), palette)\n\t\tpaletteIndex := uint8(frame) \u002F\u002F paletteIndex 0 is blue, 1 is green and 2 is red\n\t\tfor p := 0; p &lt; 240*240; p++ {\n\t\t\timg.Pix[p] = paletteIndex\n\t\t}\n\n\t\timages = append(images, img)\n\t\tdelays = append(delays, 100) \u002F\u002F 1 second delay between frames\n\t}\n\n\tf, _ := os.OpenFile(fileName, os.O_WRONLY|os.O_CREATE, 0600)\n\tdefer f.Close()\n\tgif.EncodeAll(f, &amp;gif.GIF{\n\t\tImage: images,\n\t\tDelay: delays,\n\t})\n\tfmt.Printf(\"Created '%v'.\\n\", fileName)\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F5c7\u002Ff05\u002Fd2d\u002F5c7f05d2d5c4dd3eab5848bcbd8e04f3.gif\" width=\"240\" height=\"240\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F5c7\u002Ff05\u002Fd2d\u002F5c7f05d2d5c4dd3eab5848bcbd8e04f3.gif 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F5c7\u002Ff05\u002Fd2d\u002F5c7f05d2d5c4dd3eab5848bcbd8e04f3.gif 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Ch3\u003EPNG  \u003C\u002Fh3\u003E\u003Cp\u003EPortable Network Graphic (PNG) был разработан как преемник GIF. В отличие от своего предшественника, PNG поддерживает цвета без палитры, то есть фактически хранит RGB или RGBA для каждого цвета. Но он также поддерживает оттенки серого и палитры размером 3 байта RGB или 4 байта RGBA.\u003C\u002Fp\u003E\u003Cp\u003EКаждый файл PNG начинается с сигнатуры:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E89 50 4E 47 0D 0A 1A 0A\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЗатем следует список чанков. Существуют различные типы чанков:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EIHDR (заголовок изображения). Этот чанк должен идти первым и содержит важные метаданные изображения, такие как ширина, высота, битовая глубина, тип цвета и т. д.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EIDAT (данные изображения): В этом чанке хранятся данные изображения, сжатые с помощью \u003Ca href=\"https:\u002F\u002Fcefboud.com\u002Fposts\u002Fcompression\u002F#deflate-algorithm\"\u003Eалгоритма Deflate\u003C\u002Fa\u003E (GZIP). Данные изображения могут быть разделены на несколько IDAT-чанков, особенно для больших изображений.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EIEND (End Chunk). Этот чанк отмечает конец файла PNG.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EЯ не большой поклонник этих аббревиатур (IHDR, IDAT), для меня они звучат излишне вычурно.\u003C\u002Fp\u003E\u003Cp\u003EТак или иначе, PNG использует \u003Ca href=\"https:\u002F\u002Fcefboud.com\u002Fposts\u002Fcompression\u002F#gzip\"\u003Eизвестный алгоритм DEFLATE\u003C\u002Fa\u003E, применяемый в GZIP для сжатия данных изображения.\u003C\u002Fp\u003E\u003Ch4\u003EФильтрация  \u003C\u002Fh4\u003E\u003Cp\u003EПиксели не всегда охотно поддаются сжатию. Они могут проявлять некоторое упрямство. Например, значения пикселей могут следовать определённому шаблону (2,4,6,8 и т. д.). Этот шаблон, к сожалению, не поддаётся сжатию LZ. Хоть мы и знаем, что существует повторяющееся поведение, которое управляет значениями пикселей, мы не можем просто использовать ссылки на предыдущие данные.\u003C\u002Fp\u003E\u003Cp\u003EРешение? Преобразовать данные. Скажем, мы будем вычитать из каждого пикселя значение его соседа слева. В нашем примере мы получим (2,2,2,2,2 и т. д.). Это легко сжимается. Такая техника называется \u003Ccode\u003ESub Filter\u003C\u002Fcode\u003E. Иногда закономерность проявляется по вертикали, а не по горизонтали. Например, пиксели в строке N - (12,18,44,89), а чуть ниже, в строке N+1, - (13,19,45,90). Это не так уж и маловероятно, потому что часто мы имеем градиент или плавные переходы цветов. Если мы применим фильтр \u003Ccode\u003EUp Filter\u003C\u002Fcode\u003E, то есть вычтем из каждого пикселя значение пикселя сверху, то получим аккуратный (1,1,1,1), что отлично поддаётся сжатию.\u003C\u002Fp\u003E\u003Cp\u003EPNG применяет фильтры по строкам. Как выбрать фильтр? Идеального способа не существует, но используется такой эвристический подход: \u003Cstrong\u003Eминимизируем сумму абсолютных разностей между пикселями оригинала и пикселями фильтра (вверх, до и т. д.)\u003C\u002Fstrong\u003E. Почему? Если сумма абсолютных разностей минимальна, то вполне вероятно, что у нас много близких или одинаковых значений, которые, скорее всего, более сжимаемы, чем «разрозненные» значения. Я понимаю, что можно придумать контрпример: например, массив (100, 100, 100, 100, 100, 100, 100), сумма которого равна 600, более сжимаем, чем (1,2,3,4,5,6), сумма которого намного меньше. Но это эвристика, и, судя по всему, она показала хорошие эмпирические результаты. Существуют и другие методы. В \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fpnggroup\u002Flibpng\u002Fblob\u002F0024abd279d3a06435c0309a3f4172eed7c7a19a\u002Fpngwutil.c#L2615\"\u003Elibpng \u003C\u002Fa\u003E(канонической реализации PNG) есть следующий комментарий:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003E    * The prediction method we use is to find which method provides the\n    * smallest value when summing the absolute values of the distances\n    * from zero, using anything &gt;= 128 as negative numbers.  This is known\n    * as the \"minimum sum of absolute differences\" heuristic.  Other\n    * heuristics are the \"weighted minimum sum of absolute differences\"\n    * (experimental and can in theory improve compression), and the \"zlib\n    * predictive\" method (not implemented yet), which does test compressions\n    * of lines using different filter methods, and then chooses the\n    * (series of) filter(s) that give minimum compressed data size (VERY\n    * computationally expensive).\n    *\n    * GRR 980525:  consider also\n    *\n    *   (1) minimum sum of absolute differences from running average (i.e.,\n    *       keep running sum of non-absolute differences &amp; count of bytes)\n    *       [track dispersion, too?  restart average if dispersion too large?]\n    *\n    *  (1b) minimum sum of absolute differences from sliding average, probably\n    *       with window size &lt;= deflate window (usually 32K)\n    *\n    *   (2) minimum sum of squared differences from zero or running average\n    *       (i.e., ~ root-mean-square approach)\n    *\u002F\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EРеализация в Golang также использует ту же эвристику, как мы увидим ниже.\u003C\u002Fp\u003E\u003Cp\u003EВот список всех фильтров, которые использует PNG:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003ENone. Ничего не делает.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003ESub. Каждый байт заменяется разницей между текущим и предыдущим пикселем (в той же строке).\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EUp. Каждый байт заменяется разницей между текущим пикселем и пикселем, расположенным непосредственно над ним.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EAverage. Каждый байт заменяется средним значением пикселя слева и пикселя сверху.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EPaeth. Каждый байт заменяется разницей между текущим пикселем и лучшим значением из трех: слева, сверху или по диагонали вверх-влево.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EОперации фильтрации выполняются на уровне байтов, и в результате на изображениях с малой глубиной (менее 8 бит на пиксель) по умолчанию используется фильтр NONE.\u003C\u002Fp\u003E\u003Cp\u003EПерейдем к делу и рассмотрим \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fgolang\u002Fgo\u002Fblob\u002F608acff8479640b00c85371d91280b64f5ec9594\u002Fsrc\u002Fimage\u002Fpng\u002Fwriter.go#L207\"\u003Eреализацию фильтров в Go\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003E\u002F\u002F Chooses the filter to use for encoding the current row, and applies it.\n\u002F\u002F The return value is the index of the filter and also of the row in cr that has had it applied.\nfunc filter(cr *[nFilter][]byte, pr []byte, bpp int) int {\n\t\u002F\u002F We try all five filter types, and pick the one that minimizes the sum of absolute differences.\n\t\u002F\u002F This is the same heuristic that libpng uses, although the filters are attempted in order of\n\t\u002F\u002F estimated most likely to be minimal (ftUp, ftPaeth, ftNone, ftSub, ftAverage), rather than\n\t\u002F\u002F in their enumeration order (ftNone, ftSub, ftUp, ftAverage, ftPaeth).\n\tcdat0 := cr[0][1:]\n\tcdat1 := cr[1][1:]\n\tcdat2 := cr[2][1:]\n\tcdat3 := cr[3][1:]\n\tcdat4 := cr[4][1:]\n\tpdat := pr[1:]\n\tn := len(cdat0)\n\n\t\u002F\u002F The up filter.\n\tsum := 0\n\tfor i := 0; i &lt; n; i++ {\n\t\tcdat2[i] = cdat0[i] - pdat[i]\n\t\tsum += abs8(cdat2[i])\n\t}\n\tbest := sum\n\tfilter := ftUp\n\n\t\u002F\u002F The Paeth filter.\n\tsum = 0\n\tfor i := 0; i &lt; bpp; i++ {\n\t\tcdat4[i] = cdat0[i] - pdat[i]\n\t\tsum += abs8(cdat4[i])\n\t}\n\tfor i := bpp; i &lt; n; i++ {\n\t\tcdat4[i] = cdat0[i] - paeth(cdat0[i-bpp], pdat[i], pdat[i-bpp])\n\t\tsum += abs8(cdat4[i])\n\t\tif sum &gt;= best {\n\t\t\tbreak\n\t\t}\n\t}\n\tif sum &lt; best {\n\t\tbest = sum\n\t\tfilter = ftPaeth\n\t}\n\n\t\u002F\u002F The none filter.\n\tsum = 0\n\tfor i := 0; i &lt; n; i++ {\n\t\tsum += abs8(cdat0[i])\n\t\tif sum &gt;= best {\n\t\t\tbreak\n\t\t}\n\t}\n\tif sum &lt; best {\n\t\tbest = sum\n\t\tfilter = ftNone\n\t}\n\n\t\u002F\u002F The sub filter.\n\tsum = 0\n\tfor i := 0; i &lt; bpp; i++ {\n\t\tcdat1[i] = cdat0[i]\n\t\tsum += abs8(cdat1[i])\n\t}\n\tfor i := bpp; i &lt; n; i++ {\n\t\tcdat1[i] = cdat0[i] - cdat0[i-bpp]\n\t\tsum += abs8(cdat1[i])\n\t\tif sum &gt;= best {\n\t\t\tbreak\n\t\t}\n\t}\n\tif sum &lt; best {\n\t\tbest = sum\n\t\tfilter = ftSub\n\t}\n\n\t\u002F\u002F The average filter.\n\tsum = 0\n\tfor i := 0; i &lt; bpp; i++ {\n\t\tcdat3[i] = cdat0[i] - pdat[i]\u002F2\n\t\tsum += abs8(cdat3[i])\n\t}\n\tfor i := bpp; i &lt; n; i++ {\n\t\tcdat3[i] = cdat0[i] - uint8((int(cdat0[i-bpp])+int(pdat[i]))\u002F2)\n\t\tsum += abs8(cdat3[i])\n\t\tif sum &gt;= best {\n\t\t\tbreak\n\t\t}\n\t}\n\tif sum &lt; best {\n\t\tfilter = ftAverage\n\t}\n\n\treturn filter\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EФункция принимает аргументы \u003Ccode\u003Ecr *[nFilter][]byte, pr []byte, bpp int. cr\u003C\u002Fcode\u003E — это массив массивов (я буду использовать массив и срез как взаимозаменяемые), он представляет текущий ряд, для которого мы хотим выбрать фильтр (возвращаемое значение — это индекс\u002Fтип фильтра).\u003C\u002Fp\u003E\u003Cp\u003EКаждый результат фильтрации записывается внутри массива \u003Ccode\u003Ecr[filterNb]\u003C\u002Fcode\u003E. Как сказано в комментарии, фильтры тестируются в порядке наиболее вероятных кандидатов на минимальную сумму разностей, это делается для того, чтобы иметь возможность прервать работу последующего фильтра, как только сумма превысит текущее лучшее значение. \u003Ccode\u003Epr\u003C\u002Fcode\u003E — предыдущий ряд. Первый байт массива байтов каждой строки содержит тип фильтра, поэтому \u003Ccode\u003Epdat = pr[1:]\u003C\u002Fcode\u003E — это данные предыдущей строки без типа фильтра. Давайте разберем фильтр \u003Ccode\u003Eup\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003E\t\u002F\u002F The up filter.\n\tsum := 0\n\tfor i := 0; i &lt; n; i++ { \u002F\u002F loop over the row pixels\n\t\tcdat2[i] = cdat0[i] - pdat[i] \u002F\u002F subsctract the previous row's pixel at the same position i.e. the pixel above\n\t\tsum += abs8(cdat2[i]) \u002F\u002F add the absolute difference to our sum which we are trying to minimize\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EКак насчет субфильтра?\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003E\t\u002F\u002F The sub filter.\n\t\u002F\u002F bpp is bytes per pixel. For RGB, it's 3. For gray scale, it's 1.\n\tsum = 0\n\tfor i := 0; i &lt; bpp; i++ {\n\t\tcdat1[i] = cdat0[i]\n\t\tsum += abs8(cdat1[i])\n\t}\n\tfor i := bpp; i &lt; n; i++ {\n\t\tcdat1[i] = cdat0[i] - cdat0[i-bpp] \u002F\u002F subtract each byte within a pixel from corresponding byte in previous pixel\n\t\tsum += abs8(cdat1[i])\n\t\tif sum &gt;= best { \u002F\u002F break early if this is worse than previous filter\n\t\t\tbreak\n\t\t}\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Ccode\u003Ebpp \u003C\u002Fcode\u003Eиграет здесь решающую роль. Обратите внимание, что при вычитании \u003Ccode\u003Ecdat1[i] = cdat0[i] - cdat0[i - bpp]\u003C\u002Fcode\u003E мы вычитаем пиксель на \u003Ccode\u003Ebpp\u003C\u002Fcode\u003E позиций раньше текущего пикселя. В случае RGB это означает, что из текущего значения красного цвета вычитается красный предыдущего пикселя, из текущего зелёного — зелёный предыдущего и так далее.\u003C\u002Fp\u003E\u003Cp\u003EМы вычисляем сумму для каждого фильтра и берем \u003Ccode\u003Emin\u003C\u002Fcode\u003E — это и будет наш выбранный фильтр, который, предположительно, обеспечит максимальное сжатие алгоритмом DEFLATE. Результат применения выбранного фильтра будет находиться в массиве \u003Ccode\u003Ecr[chosenFilter]\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Ch4\u003EКодирование  \u003C\u002Fh4\u003E\u003Cp\u003EРассмотрим метод \u003Ccode\u003EEncode\u003C\u002Fcode\u003E, используемый для кодирования изображений PNG.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003E\u002F\u002F Encode writes the Image m to w in PNG format.\nfunc (enc *Encoder) Encode(w io.Writer, m image.Image) error {\n\t\u002F\u002F Obviously, negative widths and heights are invalid. Furthermore, the PNG\n\t\u002F\u002F spec section 11.2.2 says that zero is invalid. Excessively large images are\n\t\u002F\u002F also rejected.\n\tmw, mh := int64(m.Bounds().Dx()), int64(m.Bounds().Dy())\n\tif mw &lt;= 0 || mh &lt;= 0 || mw &gt;= 1&lt;&lt;32 || mh &gt;= 1&lt;&lt;32 {\n\t\treturn FormatError(\"invalid image size: \" + strconv.FormatInt(mw, 10) + \"x\" + strconv.FormatInt(mh, 10))\n\t}\n\n\te := &amp;encoder{}\n\t\u002F\u002F....\n\n\te.enc = enc\n\te.w = w\n\te.m = m\n\n\tvar pal color.Palette\n\t\u002F\u002F cbP8 encoding needs PalettedImage's ColorIndexAt method.\n\tif _, ok := m.(image.PalettedImage); ok {\n\t\tpal, _ = m.ColorModel().(color.Palette)\n\t}\n\tif pal != nil {\n\t\tif len(pal) &lt;= 2 {\n\t\t\te.cb = cbP1\n\t\t} else if len(pal) &lt;= 4 {\n\t\t\te.cb = cbP2\n\t\t} else if len(pal) &lt;= 16 {\n\t\t\te.cb = cbP4\n\t\t} else {\n\t\t\te.cb = cbP8\n\t\t}\n\t} else {\n\t\tswitch m.ColorModel() {\n\t\tcase color.GrayModel:\n\t\t\te.cb = cbG8\n\t\tcase color.Gray16Model:\n\t\t\te.cb = cbG16\n\t\tcase color.RGBAModel, color.NRGBAModel, color.AlphaModel:\n\t\t\tif opaque(m) {\n\t\t\t\te.cb = cbTC8\n\t\t\t} else {\n\t\t\t\te.cb = cbTCA8\n\t\t\t}\n\t\tdefault:\n\t\t\tif opaque(m) {\n\t\t\t\te.cb = cbTC16\n\t\t\t} else {\n\t\t\t\te.cb = cbTCA16\n\t\t\t}\n\t\t}\n\t}\n\n\t_, e.err = io.WriteString(w, pngHeader)\n\te.writeIHDR()\n\tif pal != nil {\n\t\te.writePLTEAndTRNS(pal)\n\t}\n\te.writeIDATs()\n\te.writeIEND()\n\treturn e.err\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EМногое предстоит распаковать. Весело! Одна из причин, по которой я люблю читать код, это комментарии вроде «Очевидно, что отрицательные значения ширины и высоты недействительны». Он просто красиво звучит.\u003C\u002Fp\u003E\u003Cp\u003EМы начинаем с проверки размеров наших изображений, затем инициализируем наш энкодер, который определяется как:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003Etype encoder struct {\n\tenc     *Encoder\n\tw       io.Writer\n\tm       image.Image\n\tcb      int \u002F\u002F  a combination of color type and bit depth.\n\terr     error\n\theader  [8]byte\n\tfooter  [4]byte\n\ttmp     [4 * 256]byte\n\tcr      [nFilter][]uint8 \u002F\u002F stores the current row and possible filter\n\tpr      []uint8          \u002F\u002F previous row\n\tzw      *zlib.Writer     \u002F\u002F used of compression\n\tzwLevel int              \u002F\u002F compression level\n\tbw      *bufio.Writer\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЗатем пытаемся преобразовать наше изображение в \u003Ccode\u003Eimage.PalettedImage\u003C\u002Fcode\u003E и извлечь из него \u003Ccode\u003EPalette\u003C\u002Fcode\u003E (которая является псевдонимом для \u003Ccode\u003E[]Color\u003C\u002Fcode\u003E). Если это удаётся, значит, изображение палитровое, и мы определяем глубину цвета (количество бит) в зависимости от количества цветов в палитре. Если нет, то, основываясь на возвращаемом типе \u003Ccode\u003EColorModel\u003C\u002Fcode\u003E, присваиваем наш \u003Ccode\u003Ecb\u003C\u002Fcode\u003E. GrayModel, Gray16Model, RGBAModel, AlphaModel — всё это именно то, о чем говорят их названия.\u003C\u002Fp\u003E\u003Cp\u003EКак только мы узнаем тип и глубину цвета, оставшийся код становится практически простым текстом.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003E\t_, e.err = io.WriteString(w, pngHeader) \u002F\u002F write magic \"\\x89PNG\\r\\n\\x1a\\n\"\n\te.writeIHDR() \u002F\u002F write the actual header \n\tif pal != nil {\n\t\te.writePLTEAndTRNS(pal) \u002F\u002F write the palette, if there is one\n\t}\n\te.writeIDATs() \u002F\u002F the image data\n\te.writeIEND() \u002F\u002F write the footer: `IEND`\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВот функция \u003Ccode\u003EwriteIHDR\u003C\u002Fcode\u003E, перед которой идут определения типов цвета:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003E\u002F\u002F Color type, as per the PNG spec.\nconst (\n\tctGrayscale      = 0\n\tctTrueColor      = 2\n\tctPaletted       = 3\n\tctGrayscaleAlpha = 4\n\tctTrueColorAlpha = 6\n)\n\nfunc (e *encoder) writeIHDR() {\n\tb := e.m.Bounds()\n\t\u002F\u002F Write image dimensions in BigEndian (most significant byte at the smallest memory address)\n\tbinary.BigEndian.PutUint32(e.tmp[0:4], uint32(b.Dx())) \u002F\u002F image width\n\tbinary.BigEndian.PutUint32(e.tmp[4:8], uint32(b.Dy())) \u002F\u002F image height\n\t\u002F\u002F Set bit depth and color type.\n\tswitch e.cb {\n\tcase cbG8:\n\t\te.tmp[8] = 8\n\t\te.tmp[9] = ctGrayscale\n\tcase cbTC8:\n\t\te.tmp[8] = 8\n\t\te.tmp[9] = ctTrueColor\n\tcase cbP8:\n\t\te.tmp[8] = 8\n\t\te.tmp[9] = ctPaletted\n\tcase cbP4:\n\t\te.tmp[8] = 4\n\t\te.tmp[9] = ctPaletted\n\tcase cbP2:\n\t\te.tmp[8] = 2\n\t\te.tmp[9] = ctPaletted\n\tcase cbP1:\n\t\te.tmp[8] = 1 \u002F\u002F 1 bit per Pixel !!!!\n\t\te.tmp[9] = ctPaletted\n\tcase cbTCA8:\n\t\te.tmp[8] = 8\n\t\te.tmp[9] = ctTrueColorAlpha\n\tcase cbG16:\n\t\te.tmp[8] = 16\n\t\te.tmp[9] = ctGrayscale\n\tcase cbTC16:\n\t\te.tmp[8] = 16\n\t\te.tmp[9] = ctTrueColor\n\tcase cbTCA16:\n\t\te.tmp[8] = 16\n\t\te.tmp[9] = ctTrueColorAlpha\n\t}\n\te.tmp[10] = 0 \u002F\u002F default compression method\n\te.tmp[11] = 0 \u002F\u002F default filter method\n\te.tmp[12] = 0 \u002F\u002F non-interlaced\n\te.writeChunk(e.tmp[:13], \"IHDR\")\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EМы подготавливаем массив заголовка размером 13 байт и записываем его как блок \u003Ccode\u003EIHDR \u003C\u002Fcode\u003Eс помощью функции \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fgolang\u002Fgo\u002Fblob\u002F37f27fbecd422da9fefb8ae1cc601bc5b4fec44b\u002Fsrc\u002Fimage\u002Fpng\u002Fwriter.go#L96\"\u003E\u003Ccode\u003EwriteChunk\u003C\u002Fcode\u003E\u003C\u002Fa\u003E:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003Efunc (e *encoder) writeChunk(b []byte, name string) {\n\tif e.err != nil {\n\t\treturn\n\t}\n\t\u002F\u002F 4 Gib max chunk size\n\tn := uint32(len(b))\n\tif int(n) != len(b) {\n\t\te.err = UnsupportedError(name + \" chunk is too large: \" + strconv.Itoa(len(b)))\n\t\treturn\n\t}\n\t\u002F\u002F add the chunk length\n\tbinary.BigEndian.PutUint32(e.header[:4], n)\n\t\u002F\u002F chunk name\n\te.header[4] = name[0]\n\te.header[5] = name[1]\n\te.header[6] = name[2]\n\te.header[7] = name[3]\n\tcrc := crc32.NewIEEE()\n\t\u002F\u002F CRC check for the name + actual chunk data\n\tcrc.Write(e.header[4:8])\n\tcrc.Write(b)\n\tbinary.BigEndian.PutUint32(e.footer[:4], crc.Sum32())\n\n\t\u002F\u002F write header (length + name)\n\t_, e.err = e.w.Write(e.header[:8])\n\tif e.err != nil {\n\t\treturn\n\t}\n\t\u002F\u002F actual data\n\t_, e.err = e.w.Write(b)\n\tif e.err != nil {\n\t\treturn\n\t}\n\t\u002F\u002F CRC\n\t_, e.err = e.w.Write(e.footer[:4])\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЯ добавил комментарии, но код довольно прост. Он записывает длину и имя чанка, затем сами данные, а в конце добавляет контрольную сумму (CRC).\u003C\u002Fp\u003E\u003Cp\u003EЕсли в нашей цветовой схеме есть палитра, мы пишем чанк \u003Ccode\u003EPLTE\u003C\u002Fcode\u003E, используя:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003Efunc (e *encoder) writePLTEAndTRNS(p color.Palette) {\n\tif len(p) &lt; 1 || len(p) &gt; 256 {\n\t\te.err = FormatError(\"bad palette length: \" + strconv.Itoa(len(p)))\n\t\treturn\n\t}\n\tlast := -1\n\tfor i, c := range p {\n\t\tc1 := color.NRGBAModel.Convert(c).(color.NRGBA)\n\t\te.tmp[3*i+0] = c1.R\n\t\te.tmp[3*i+1] = c1.G\n\t\te.tmp[3*i+2] = c1.B\n\t\tif c1.A != 0xff {\n\t\t\tlast = i\n\t\t}\n\t\te.tmp[3*256+i] = c1.A\n\t}\n\te.writeChunk(e.tmp[:3*len(p)], \"PLTE\")\n\tif last != -1 {\n\t\te.writeChunk(e.tmp[3*256:3*256+1+last], \"tRNS\")\n\t}\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЧанк \u003Ccode\u003EPLTE\u003C\u002Fcode\u003E всегда хранит цвета палитры с использованием 3 байтов, независимо от типа цвета, то есть даже цвета в градациях серого (1 байт) используют 3 байта. Чанк \u003Ccode\u003EtRNS\u003C\u002Fcode\u003E хранит информацию о прозрачности, причем альфа-байт для каждой цветовой палитры располагается после байтов цвета палитры.\u003C\u002Fp\u003E\u003Cp\u003EИ наконец, собственно данные изображения, записанные с помощью \u003Ccode\u003EwriteIDATs\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003E\u002F\u002F Write the actual image data to one or more IDAT chunks.\nfunc (e *encoder) writeIDATs() {\n\tif e.err != nil {\n\t\treturn\n\t}\n\tif e.bw == nil {\n\t\te.bw = bufio.NewWriterSize(e, 1&lt;&lt;15)\n\t} else {\n\t\te.bw.Reset(e)\n\t}\n\te.err = e.writeImage(e.bw, e.m, e.cb, levelToZlib(e.enc.CompressionLevel))\n\tif e.err != nil {\n\t\treturn\n\t}\n\te.err = e.bw.Flush()\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЕго суть заключается в цикле внутри \u003Ccode\u003EwriteImage\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003E\tfor y := b.Min.Y; y &lt; b.Max.Y; y++ {\n\t\t\u002F\u002F Convert from colors to bytes.\n\t\ti := 1\n\t\tswitch cb {\n\t\tcase cbG8:\n\t\t\tif gray != nil {\n\t\t\t\toffset := (y - b.Min.Y) * gray.Stride\n\t\t\t\tcopy(cr[0][1:], gray.Pix[offset:offset+b.Dx()])\n\t\t\t} else {\n\t\t\t\tfor x := b.Min.X; x &lt; b.Max.X; x++ {\n\t\t\t\t\tc := color.GrayModel.Convert(m.At(x, y)).(color.Gray)\n\t\t\t\t\tcr[0][i] = c.Y\n\t\t\t\t\ti++\n\t\t\t\t}\n\t\t\t}\n\t\t\u002F\u002F omitted ...\n\t\tcase cbTC8:\n\t\t\t\u002F\u002F We have previously verified that the alpha value is fully opaque.\n\n\t\t\t\u002F\u002F omitted ...\n\t\t\t\tfor x := b.Min.X; x &lt; b.Max.X; x++ {\n\t\t\t\t\tr, g, b, _ := m.At(x, y).RGBA()\n\t\t\t\t\tcr0[i+0] = uint8(r &gt;&gt; 8)\n\t\t\t\t\tcr0[i+1] = uint8(g &gt;&gt; 8)\n\t\t\t\t\tcr0[i+2] = uint8(b &gt;&gt; 8)\n\t\t\t\t\ti += 3\n\t\t\t\t}\n\t\t\n\t\tcase cbP8:\n\t\t\t\u002F\u002F omitted ...\n\t\t\t\tpi := m.(image.PalettedImage)\n\t\t\t\tfor x := b.Min.X; x &lt; b.Max.X; x++ {\n\t\t\t\t\tcr[0][i] = pi.ColorIndexAt(x, y)\n\t\t\t\t\ti += 1\n\t\t\t\t}\n\n\t\t\u002F\u002F omitted ...\n\t\t}\n\n\t\t\u002F\u002F Apply the filter.\n\t\t\u002F\u002F Skip filter for NoCompression and paletted images (cbP8) as\n\t\t\u002F\u002F \"filters are rarely useful on palette images\" and will result\n\t\t\u002F\u002F in larger files (see http:\u002F\u002Fwww.libpng.org\u002Fpub\u002Fpng\u002Fbook\u002Fchapter09.html).\n\t\tf := ftNone\n\t\tif level != zlib.NoCompression &amp;&amp; cb != cbP8 &amp;&amp; cb != cbP4 &amp;&amp; cb != cbP2 &amp;&amp; cb != cbP1 {\n\t\t\t\u002F\u002F Since we skip paletted images we don't have to worry about\n\t\t\t\u002F\u002F bitsPerPixel not being a multiple of 8\n\t\t\tbpp := bitsPerPixel \u002F 8\n\t\t\tf = filter(&amp;cr, pr, bpp)\n\t\t}\n\n\t\t\u002F\u002F Write the compressed bytes.\n\t\tif _, err := e.zw.Write(cr[f]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t\u002F\u002F The current row for y is the previous row for y+1.\n\t\tpr, cr[0] = cr[0], pr\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЯ оставил только случаи для оттенков серого, RGB (истинного цвета) и 256-цветной палитры \u003Ccode\u003EcbP8\u003C\u002Fcode\u003E. Как вы можете видеть, мы перебираем строки изображения: \u003Ccode\u003Ey := b.Min.Y; y &lt; b.Max.Y; y++\u003C\u002Fcode\u003E. Для каждой строки, если это градации серого (\u003Ccode\u003EcbG8\u003C\u002Fcode\u003E), мы копируем по 1 байту для каждого цвета. Если это RGB, то копируем 3 байта. Для палитры мы просто записываем индекс палитры.\u003C\u002Fp\u003E\u003Cp\u003EЗатем, если сжатие включено (\u003Ccode\u003Elevel != zlib.NoCompression\u003C\u002Fcode\u003E) — нет необходимости фильтровать, если мы не будем сжимать, — и мы не используем палитры, мы выбираем фильтр для данных изображения с помощью функции \u003Ccode\u003Efilter \u003C\u002Fcode\u003E, которую изучили ранее. Затем передаем отфильтрованные (или неотфильтрованные) байты в LZ-writer, и наши сжатые данные изображения готовы к записи.\u003C\u002Fp\u003E\u003Cp\u003EНаконец, добавляем последний чанк с помощью функции \u003Ccode\u003EwriteIEND\u003C\u002Fcode\u003E, короткой и приятной:\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Efunc (e *encoder) writeIEND() { e.writeChunk(nil, \"IEND\") }\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003EИ в этом вся суть PNG!\u003C\u002Fp\u003E\u003Ch2\u003EИзображения с потерями\u003C\u002Fh2\u003E\u003Ch3\u003EJPEG\u003C\u002Fh3\u003E\u003Cp\u003EJPEG, Joint Photographic Experts Group (что за название!), чрезвычайно распространён в Интернете. Каждый, кто работал с изображениями на компьютере, наверняка сталкивался с PNG либо с JPEG. Этот формат позволяет достичь высокой степени сжатия, уменьшая исходное изображение до +90% от его размера при сохранении приемлемого качества. Степень сжатия варьируется от 5:1 до 50:1. Качество настраивается, и мы можем выбрать компромисс между коэффициентом сжатия и качеством изображения.\u003C\u002Fp\u003E\u003Cp\u003EJPEG — это волшебный инженерный подвиг, состоящий из множества аспектов. Попробуем исследовать некоторые из его основных идей и посмотреть на код. Далее поговорим о цветовой субдискретизации, DCT (дискретное косинусное преобразование) и квантовании.\u003C\u002Fp\u003E\u003Ch4\u003EYCbCr и цветовая субдискретизация\u003C\u002Fh4\u003E\u003Cp\u003EЭтот шаг основан на следующей идее: человеческий глаз более чувствителен к яркости (luma) и зелёному цвету, чем к красному и синему (chroma).\u003C\u002Fp\u003E\u003Cp\u003EЕсли мы преобразуем наш цвет RGB в эквивалент, который изолирует яркость от красных и синих компонентов, мы сможем сохранить биты luma (к которым наш глаз более чувствителен), одновременно сжимая (субдискретизируя) chroma (красный и синий), к которому мы менее чувствительны.\u003C\u002Fp\u003E\u003Cp\u003EТакое преобразование называется \u003Cstrong\u003EYCbCr (Y: Luma, Cb: Chroma Blue, Cr: Chroma Red)\u003C\u002Fstrong\u003E; оно отделяет яркость (Y) от цветовой информации (Cb и Cr).\u003C\u002Fp\u003E\u003Cp\u003EУчитывая, что наши глаза более чувствительны к яркости, чем к цветам, мы можем сжать исходное изображение, выбрав меньше компонентов CbCr и оставив все компоненты яркости. Это называется \u003Cstrong\u003Eцветовой субдискретизацией\u003C\u002Fstrong\u003E, т. е. мы берем меньше информации о цветах. Для каждого набора из 4 пикселей мы делаем субдискретизацию, заменяя их одним пикселем (например, усредняя или беря левый верхний пиксель). Заменяя 4 пикселя на 1 для Cb и Cr, мы уменьшаем исходный размер на 50 %.\u003C\u002Fp\u003E\u003Cp\u003EJPEG работает с блоками 8x8 пикселей. Вот функция, которую использует стандартная библиотека Go для \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fgolang\u002Fgo\u002Fblob\u002F37f27fbecd422da9fefb8ae1cc601bc5b4fec44b\u002Fsrc\u002Fimage\u002Fjpeg\u002Fwriter.go#L390-L391\"\u003Eпреобразования в YCbCr\u003C\u002Fa\u003E:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003Econst blockSize = 64\ntype block [blockSize]int32 \u002F\u002F block holds 64 (8x8) pixels\n\n\u002F\u002F toYCbCr converts the 8x8 region of m whose top-left corner is p to its\n\u002F\u002F YCbCr values.\nfunc toYCbCr(m image.Image, p image.Point, yBlock, cbBlock, crBlock *block) {\n\tb := m.Bounds()\n\txmax := b.Max.X - 1\n\tymax := b.Max.Y - 1\n\tfor j := 0; j &lt; 8; j++ { \u002F\u002F 8x8 pixel blocks\n\t\tfor i := 0; i &lt; 8; i++ {\n\t\t\tr, g, b, _ := m.At(min(p.X+i, xmax), min(p.Y+j, ymax)).RGBA()\n\t\t\tyy, cb, cr := color.RGBToYCbCr(uint8(r&gt;&gt;8), uint8(g&gt;&gt;8), uint8(b&gt;&gt;8))\n\t\t\tyBlock[8*j+i] = int32(yy)\n\t\t\tcbBlock[8*j+i] = int32(cb)\n\t\t\tcrBlock[8*j+i] = int32(cr)\n\t\t}\n\t}\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВолшебное преобразование происходит внутри \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fgolang\u002Fgo\u002Fblob\u002F37f27fbecd422da9fefb8ae1cc601bc5b4fec44b\u002Fsrc\u002Fimage\u002Fcolor\u002Fycbcr.go#L8\"\u003ERGBToYCbCr\u003C\u002Fa\u003E:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003E\u002F\u002F RGBToYCbCr converts an RGB triple to a Y'CbCr triple.\nfunc RGBToYCbCr(r, g, b uint8) (uint8, uint8, uint8) {\n\t\u002F\u002F The JFIF specification says:\n\t\u002F\u002F\tY' =  0.2990*R + 0.5870*G + 0.1140*B\n\t\u002F\u002F\tCb = -0.1687*R - 0.3313*G + 0.5000*B + 128\n\t\u002F\u002F\tCr =  0.5000*R - 0.4187*G - 0.0813*B + 128\n\t\u002F\u002F https:\u002F\u002Fwww.w3.org\u002FGraphics\u002FJPEG\u002Fjfif3.pdf says Y but means Y'.\n\n\tyy := (19595*r1 + 38470*g1 + 7471*b1 + 1&lt;&lt;15) &gt;&gt; 16\n\t\u002F\u002F omitted ...\n\tcb := -11056*r1 - 21712*g1 + 32768*b1 + 257&lt;&lt;15\n\t\u002F\u002F omitted ...\n\tcr := 32768*r1 - 27440*g1 - 5328*b1 + 257&lt;&lt;15\n\t\u002F\u002F omitted ...\n\treturn uint8(yy), uint8(cb), uint8(cr)\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЭто просто линейное преобразование. Мы замечаем, что Y в основном зелёный, но в нём также есть немного красного и синего. Как мы уже говорили, это luma, и наш глаз наиболее чувствителен к ней; она представляет собой яркость изображения. Cb и Cr можно интерпретировать как цветовые отличия синего и красного относительно яркости.\u003C\u002Fp\u003E\u003Cp\u003EВ \u003Ca href=\"https:\u002F\u002Fyoutu.be\u002F5S4XblwZzCY?si=rke1SIt3deDSvZhE\"\u003Eэтой потрясающей лекции\u003C\u002Fa\u003E (я обожаю весь цикл лекций, а профессор просто восхитителен) показано множество примеров и того, как изменение различных значений RGB и YCbCr может повлиять на итоговое изображение. Удивительно, как уменьшение глубины (меньшее количество битов\u002Fинформации) для Cb и Cr имеет гораздо меньший эффект, чем уменьшение синего или красного в пространстве RGB.\u003C\u002Fp\u003E\u003Cp\u003EЭто пересечение нейробиологии и инженерии.\u003C\u002Fp\u003E\u003Cp\u003EОдин из интересных выводов из этого — насколько мир оптимизирован под биологию человека. Это похоже на то, как очки создаются для человеческого лица, ушей и глаз. Это также заставляет меня думать, что роботов лучше всего делать гуманоидными, чтобы они были наиболее эффективными, поскольку наш мир спроектирован для нас.\u003C\u002Fp\u003E\u003Cp\u003EЛадно, хватит философствовать, как на самом деле происходит цветовая субдискретизация?\u003C\u002Fp\u003E\u003Cp\u003EВот цикл, который записывает данные изображения в JPEG:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003E\tcb, cr [4]block\n\t\u002F\u002F omitted\n\tfor y := bounds.Min.Y; y &lt; bounds.Max.Y; y += 16 {\n\t\t\tfor x := bounds.Min.X; x &lt; bounds.Max.X; x += 16 {\n\t\t\t\tfor i := 0; i &lt; 4; i++ {\n\t\t\t\t\txOff := (i &amp; 1) * 8\n\t\t\t\t\tyOff := (i &amp; 2) * 4\n\t\t\t\t\tp := image.Pt(x+xOff, y+yOff)\n\t\t\t\t\t\u002F\u002F omitted ..\n\t\t\t\t\ttoYCbCr(m, p, &amp;b, &amp;cb[i], &amp;cr[i])\n\t\t\t\t\tprevDCY = e.writeBlock(&amp;b, 0, prevDCY)\n\t\t\t\t}\n\t\t\t\tscale(&amp;b, &amp;cb)\n\t\t\t\tprevDCCb = e.writeBlock(&amp;b, 1, prevDCCb)\n\t\t\t\tscale(&amp;b, &amp;cr)\n\t\t\t\tprevDCCr = e.writeBlock(&amp;b, 1, prevDCCr)\n\t\t\t}\n\t\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Ccode\u003Ecb\u003C\u002Fcode\u003E и \u003Ccode\u003Ecr\u003C\u002Fcode\u003E содержат по 4 блока пикселей Cb и Cr размером 8x8. Мы проходим по области 16x16 из исходного изображения, которая состоит из 4 блоков 8x8. Эти блоки размещаются в переменных \u003Ccode\u003Ecb\u003C\u002Fcode\u003E и \u003Ccode\u003Ecr\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003EВ самом внутреннем цикле есть довольно интересный трюк. Обратите внимание на \u003Ccode\u003ExOff := (i &amp; 1) * 8\u003C\u002Fcode\u003E\u003Cem\u003E и \u003C\u002Fem\u003E\u003Ccode\u003EyOff := (i &amp; 2) * 4\u003C\u002Fcode\u003E. Их значения для \u003Ccode\u003Ei = [0,1,2,3]\u003C\u002Fcode\u003E будут: \u003Ccode\u003E(xOff, yOff) = [(0,0), (8,0), (0,8), (8,8)]\u003C\u002Fcode\u003E. Это позволяет двигаться по блоку 16x16: сначала сдвигаемся слева направо по верхнему ряду, затем смещаемся на 8 (переход к следующему блоку 8x8 вправо), а затем переходим к следующей \u003Cem\u003Eстроке \u003C\u002Fem\u003Eи выполняем то же самое.\u003C\u002Fp\u003E\u003Cp\u003EТаким образом, мы имеем значения Cb и Cr в 4 блоках 8x8. Субдискретизация происходит в функции \u003Ccode\u003Escale\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003E\u002F\u002F scale scales the 16x16 region represented by the 4 src blocks to the 8x8\n\u002F\u002F dst block.\nfunc scale(dst *block, src *[4]block) {\n\tfor i := 0; i &lt; 4; i++ {\n\t\tdstOff := (i&amp;2)&lt;&lt;4 | (i&amp;1)&lt;&lt;2\n\t\tfor y := 0; y &lt; 4; y++ {\n\t\t\tfor x := 0; x &lt; 4; x++ {\n\t\t\t\tj := 16*y + 2*x\n\t\t\t\tsum := src[i][j] + src[i][j+1] + src[i][j+8] + src[i][j+9]\n\t\t\t\tdst[8*y+x+dstOff] = (sum + 2) &gt;&gt; 2\n\t\t\t}\n\t\t}\n\t}\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЭто нечто! Во-первых, обратите внимание, что мы берем исходный \u003Ccode\u003Eblock\u003C\u002Fcode\u003E размером [4] и преобразуем его в \u003Ccode\u003Eblock\u003C\u002Fcode\u003E dst. Напоминаю, что \u003Ccode\u003Eblock\u003C\u002Fcode\u003E — это просто массив размером 64 (8x8).\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Ei\u003C\u002Fcode\u003E представляет собой верхний левый, верхний правый, нижний левый и нижний правый блоки 8x8 в области 16x16 входных данных. Каждый из блоков 8x8 будет отображаться в блок 4x4 (уменьшение на 1\u002F4). Каждый пиксель блока 4x4 обозначается x и y. Как вычисляется значение каждого пикселя?\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003Ej := 16*y + 2*x \u002F\u002F top left point of the 4 pixel square\nsum := src[i][j] + src[i][j+1] + src[i][j+8] + src[i][j+9] \u002F\u002F sum of pixel square values starting at j\ndst[8*y+x+dstOff] = (sum + 2) &gt;&gt; 2 \u002F\u002F divide by 4 (&gt;&gt;2) to get the average but add 2 before to round up instead of down\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЭто просто усреднение значений 4 пикселей с помощью 2-битного сдвига вправо и округления в большую сторону путем добавления 2 перед сдвигом.\u003C\u002Fp\u003E\u003Cp\u003EЗначение \u003Ccode\u003EdstOff\u003C\u002Fcode\u003E интригует. Для \u003Ccode\u003Ei=[0,1,2,3]\u003C\u002Fcode\u003E мы получаем \u003Ccode\u003EdstOff=[0,4,32,36]\u003C\u002Fcode\u003E. Что они означают?\u003C\u002Fp\u003E\u003Cp\u003EДавайте вспомним, что каждый \u003Ccode\u003Ei\u003C\u002Fcode\u003E представляет собой 4x4 блок внутри нашей целевой 8x8 области, которая представляет собой уменьшенную версию 16x16. Если представить матрицу 8x8, то левый верхний блок начинается в точке (0,0). Правый верхний блок начинается в точке (4,0). Левый нижний блок начинается в точке (4,0), а правый нижний — в точке (4,4). Если мы переведем их в одномерное представление с помощью \u003Ccode\u003Ex + 8y\u003C\u002Fcode\u003E, то получим:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E0 + 0 * 8 = 0 \n4 + 0 * 8 = 4\n0 + 4 * 8 = 32\n4 + 4 * 8 = 36\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EКоторый представляет собой начало каждого блока 4x4. Это вычисление причудливым образом производится с помощью \u003Ccode\u003EdstOff := (i&amp;2)&lt;&lt;4 | (i&amp;1)&lt;&lt;2\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E(i&amp;2)&lt;&lt;4\u003C\u002Fcode\u003E даст 32 для значений, у которых второй бит равен единице, то есть для 2 (10) и 3 (11) (вторая строка), а \u003Ccode\u003E(i&amp;1)&lt;&lt;2\u003C\u002Fcode\u003E даст 4 для значений 1 (01) и 3 (11). Настоящая бинарная магия!\u003C\u002Fp\u003E\u003Cp\u003EЕсли вы задаётесь вопросом, зачем делать всё это и получать 4 блока из области 16x16 вместо того, чтобы обрабатывать их по отдельности, то причина в том, что в итоге мы хотим получить блок 8x8, аналогичный компоненту Y (luma). Это гарантирует, что следующий шаг JPEG, а именно дискретное косинусное преобразование (DCT), будет работать с теми же размерами.\u003C\u002Fp\u003E\u003Cp\u003EВ общем, функция \u003Ccode\u003Escale\u003C\u002Fcode\u003E — это просто усреднение 4 пикселей в 1, что позволяет уменьшить 4 блока 8x8 до одного.\u003C\u002Fp\u003E\u003Ch4\u003EПрямое косинусное преобразование\u003C\u002Fh4\u003E\u003Cp\u003EИтак, мы достигли приличного 50-процентного сжатия, используя YCbCr. Однако всё ещё далеки от раскрытия всего потенциала JPEG.\u003C\u002Fp\u003E\u003Cp\u003EСледующий шаг в процессе — дискретное косинусное преобразование (DCT). Вкратце, DCT выделяет и идентифицирует части изображения, которые можно обрезать или отбросить без существенного ухудшения качества.\u003C\u002Fp\u003E\u003Cp\u003EМы можем представить себе изображение как функцию. Каждый пиксель на изображении соответствует позиции (x, y) со значением, указывающим на интенсивность его цвета. Мы можем представить это как \u003Ccode\u003EF(x, y) = pixelValue\u003C\u002Fcode\u003E. Если мы хотим обходить изображение слева направо и сверху вниз, мы можем упростить задачу, используя одну переменную \u003Ccode\u003Ex'\u003C\u002Fcode\u003E, где \u003Ccode\u003Ex' = x + len(row) * y\u003C\u002Fcode\u003E (по сути, это то, что делает реализация Golang со своими 64-битными блоками беззнаковых целых чисел).\u003C\u002Fp\u003E\u003Cp\u003EДругими словами, изображение — это функция.\u003Cstrong\u003E \u003C\u002Fstrong\u003EИ что с того? — спросите вы. А что, если есть способ аппроксимировать эту функцию с помощью набора компонентов разной важности и сэкономить место, отбросив наименее важные из них?\u003C\u002Fp\u003E\u003Cp\u003EПредставьте, что у нас есть набор кортежей типа \u003Ccode\u003E(1, 2), (2, 4), ..., (10, 20), (1000, 2000)\u003C\u002Fcode\u003E. Мы можем хранить 2 * 1000 чисел, а можем понять, что эти отношения следуют простой схеме: \u003Ccode\u003Ef(x) = 2x\u003C\u002Fcode\u003E. Вместо того чтобы хранить все точки, мы могли бы хранить только формулу, что дало бы значительную экономию места.\u003C\u002Fp\u003E\u003Cp\u003EDCT позволяет представить функцию изображения в виде суммы известных косинусных функций возрастающей частоты. Математически доказано, что это возможно.\u003C\u002Fp\u003E\u003Cp\u003EЧто действительно поразительно в этом представлении, так это то, что человеческий глаз (биология снова наносит удар) менее чувствителен к высокочастотным деталям, чем к низкочастотным. Еще интереснее то, что высокочастотные компоненты соответствуют резким изменениям на изображении, а на практике изображения в основном состоят из низкочастотных компонентов. Другими словами, цвета в изображениях обычно не меняются резко.\u003C\u002Fp\u003E\u003Cp\u003EГоворя иначе, любой блок размером 8x8 пикселей можно выразить как взвешенную сумму следующих 64 блоков:\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F1d1\u002F907\u002Fed6\u002F1d1907ed6d1adef2f9d47bd249658993.png\" width=\"250\" height=\"250\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F1d1\u002F907\u002Fed6\u002F1d1907ed6d1adef2f9d47bd249658993.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F1d1\u002F907\u002Fed6\u002F1d1907ed6d1adef2f9d47bd249658993.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EДавайте подумаем об этом ещё раз. Любой блок 8x8 может быть выражен как комбинация этих 64 блоков. И чем больше мы приближаемся к правому нижнему углу, тем выше частота соответствующего компонента — и тем менее различим он для человеческого глаза.\u003C\u002Fp\u003E\u003Cp\u003EПоэтому, если мы представим наш блок 8x8 только несколькими весами этих низкочастотных блоков DCT — скажем, сохраним всего 16 или 32 (вместо 64 пикселей), мы добьемся большой экономии места без заметной потери качества.\u003C\u002Fp\u003E\u003Cp\u003EЧтобы мой плагин Mathjax не пылился без дела а мои рассуждения были подкреплены наукой, давайте посмотрим на фактическую формулу:\u003C\u002Fp\u003E\u003Cimg class=\"formula\" source=\"X_{k}=\\sum _{n=0}^{N-1}x_{n}\\cos \\left[\\,{\\tfrac {\\,\\pi \\,}{N}}\\left(n+{\\tfrac {1}{2}}\\right)k\\,\\right]\\qquad {\\text{ for }}~k=0,\\ \\dots \\ N-1~\" alt=\"X_{k}=\\sum _{n=0}^{N-1}x_{n}\\cos \\left[\\,{\\tfrac {\\,\\pi \\,}{N}}\\left(n+{\\tfrac {1}{2}}\\right)k\\,\\right]\\qquad {\\text{ for }}~k=0,\\ \\dots \\ N-1~\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fb\u002Fbf\u002Fbf3\u002Fbf38f5a536aeb76b2b417069a2a8d9ba.svg\" width=\"auto\" height=\"auto\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fb\u002Fbf\u002Fbf3\u002Fbf38f5a536aeb76b2b417069a2a8d9ba.svg 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fb\u002Fbf\u002Fbf3\u002Fbf38f5a536aeb76b2b417069a2a8d9ba.svg 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cp\u003EТак мы вычисляем коэффициент K-й косинусной функции.\u003C\u002Fp\u003E\u003Cp\u003EБудет удобно представить себе это уравнение как скалярное произведение между нашими N значениями пикселей и N выборками косинусной функции: \u003C\u002Fp\u003E\u003Cimg class=\"formula\" source=\"\\cos \\left[\\,{\\tfrac {\\,\\pi \\,}{N}}\\left(n+{\\tfrac {1}{2}}\\right)k\\,\\right]\" alt=\"\\cos \\left[\\,{\\tfrac {\\,\\pi \\,}{N}}\\left(n+{\\tfrac {1}{2}}\\right)k\\,\\right]\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fec5\u002Fc0e\u002Feeb\u002Fec5c0eeebf57605c976be679d83baf05.svg\" width=\"153\" height=\"27\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fec5\u002Fc0e\u002Feeb\u002Fec5c0eeebf57605c976be679d83baf05.svg 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fec5\u002Fc0e\u002Feeb\u002Fec5c0eeebf57605c976be679d83baf05.svg 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cp\u003Eчастота которых увеличивается с ростом k.\u003C\u002Fp\u003E\u003Cp\u003EКоэффициент представляет собой степень сходства (т. е. скалярное произведение) между нашими значениями пикселей и соответствующей косинусной функцией.\u003C\u002Fp\u003E\u003Cp\u003EДля наших целей мы работаем с одним из 64 блоков (обратите внимание, что приведённая выше косинусная функция является одномерной, а блок — двумерным, поэтому данное объяснение применимо только к одному из измерений).\u003C\u002Fp\u003E\u003Cp\u003EНапример, если у нас есть сетка входных пикселей 8x8, которая идеально совпадает с одним из косинусных шаблонов, то соответствующий коэффициент будет равен 1, а коэффициенты для других блоков будут равны 0. Это происходит потому, что только этого блока достаточно для представления входных данных.\u003C\u002Fp\u003E\u003Cp\u003EЕще раз: взвешенная комбинация низкочастотных блоков (ближе к левому верхнему углу) с большей вероятностью сможет хорошо представить исходный блок 8x8 пикселей. Поэтому, когда мы представляем наше изображение в виде 64 коэффициентов, мы можем отбросить высокочастотные не сильно теряя в качестве.\u003C\u002Fp\u003E\u003Cp\u003EИтак, теперь мы готовы к двумерной формуле:\u003C\u002Fp\u003E\u003Cimg class=\"formula\" source=\"X_{k,l} = \\sum_{n=0}^{N-1} \\sum_{m=0}^{N-1} x_{n,m} \\cos\\left[\\frac{\\pi}{N} \\left(n + \\frac{1}{2}\\right) k \\right] \\cos\\left[\\frac{\\pi}{N} \\left(m + \\frac{1}{2}\\right) l \\right]\" alt=\"X_{k,l} = \\sum_{n=0}^{N-1} \\sum_{m=0}^{N-1} x_{n,m} \\cos\\left[\\frac{\\pi}{N} \\left(n + \\frac{1}{2}\\right) k \\right] \\cos\\left[\\frac{\\pi}{N} \\left(m + \\frac{1}{2}\\right) l \\right]\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fe\u002Fe4\u002Fe45\u002Fe459c803c13c363f7bd03e9d332e9119.svg\" width=\"auto\" height=\"auto\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fe\u002Fe4\u002Fe45\u002Fe459c803c13c363f7bd03e9d332e9119.svg 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fe\u002Fe4\u002Fe45\u002Fe459c803c13c363f7bd03e9d332e9119.svg 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cp\u003EПереведя в код, получим следующее:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003E    for i := 0; i &lt; N; i++ {\n        for j := 0; j &lt; N; j++ {\n            temp := 0.0\n            for x := 0; x &lt; N; x++ {\n                for y := 0; y &lt; N; y++ {\n                    temp += Cosines[x][i] * Cosines[y][j] * Pixel[x][y]\n                }\n            }\n            temp *= math.Sqrt(2 * float64(N)) * Coefficient[i][j]\n            DCT[i][j] = int(math.Round(temp))\n        }\n    }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EМассив cosines уже содержит предварительно вычисленные значения. Мы просто итерируемся по пикселям и вычисляем выходные коэффициенты, которые зависят от значений пикселей и косинусов.\u003C\u002Fp\u003E\u003Cp\u003EОднако, как видно, уровень вложенности 4 для циклов не так уж хорош для производительности. В практических реализациях используется оптимизированная версия, известная как \u003Ca href=\"https:\u002F\u002Fdl.acm.org\u002Fdoi\u002Fpdf\u002F10.1145\u002F212066.212071\"\u003EFast DCT\u003C\u002Fa\u003E, которая более эффективна с вычислительной точки зрения.\u003C\u002Fp\u003E\u003Ch4\u003EКвантование  \u003C\u002Fh4\u003E\u003Cp\u003EВместо того чтобы сразу удалять высокочастотные коэффициенты, мы уменьшаем их точность, используя меньшее количество бит для их хранения. Этот процесс называется квантованием. В результате важные низкочастотные коэффициенты сохраняются с большей точностью, а высокочастотные коэффициенты квантуются для экономии места.\u003C\u002Fp\u003E\u003Cp\u003EКак это происходит на практике?\u003C\u002Fp\u003E\u003Cp\u003EРезультаты DCT делятся на Q таблицу, уменьшая количество необходимых бит. Например, если результат DCT равен 31, а значение Q - 2, \u003Ccode\u003ERound(31\u002FQ)\u003C\u002Fcode\u003E дает 16. Если Q равно 4, \u003Ccode\u003ERound(31\u002FQ)\u003C\u002Fcode\u003E дает 8. Чтобы восстановить исходные значения, мы умножаем квантованный результат на Q, хотя восстановленное значение будет приблизительным.\u003C\u002Fp\u003E\u003Cp\u003EСтандарт JPEG определяет таблицу для квантования каждого из 64 коэффициентов, полученных после применения DCT к блоку 8x8 пикселей.\u003C\u002Fp\u003E\u003Cp\u003EПоскольку компоненты цветности (Yb и Yr) оказывают меньшее влияние на наше восприятие, их таблицы квантования более агрессивны, чем таблицы, используемые для яркости (Y). Вот эти таблицы:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003Evar unscaledQuant = [nQuantIndex][blockSize]byte{\n\t\u002F\u002F Luminance.\n\t{\n\t\t16, 11, 12, 14, 12, 10, 16, 14,\n\t\t13, 14, 18, 17, 16, 19, 24, 40,\n\t\t26, 24, 22, 22, 24, 49, 35, 37,\n\t\t29, 40, 58, 51, 61, 60, 57, 51,\n\t\t56, 55, 64, 72, 92, 78, 64, 68,\n\t\t87, 69, 55, 56, 80, 109, 81, 87,\n\t\t95, 98, 103, 104, 103, 62, 77, 113,\n\t\t121, 112, 100, 120, 92, 101, 103, 99,\n\t},\n\t\u002F\u002F Chrominance.\n\t{\n\t\t17, 18, 18, 24, 21, 24, 47, 26,\n\t\t26, 47, 99, 66, 56, 66, 99, 99,\n\t\t99, 99, 99, 99, 99, 99, 99, 99,\n\t\t99, 99, 99, 99, 99, 99, 99, 99,\n\t\t99, 99, 99, 99, 99, 99, 99, 99,\n\t\t99, 99, 99, 99, 99, 99, 99, 99,\n\t\t99, 99, 99, 99, 99, 99, 99, 99,\n\t\t99, 99, 99, 99, 99, 99, 99, 99,\n\t},\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EМожно заметить, что низкие частоты (вверху слева) делятся на меньшие значения, чтобы сохранить более высокую точность, в то время как высокие частоты (внизу справа) делятся на большие значения из таблицы Q, что приводит к очень маленьким результатам (близким к 0 или 1). Эти малые значения являются идеальными кандидатами для методов сжатия без потерь, таких как LZ77 или кодирование длин серий.\u003C\u002Fp\u003E\u003Cp\u003EЧтобы добиться максимальной эффективности сжатия, блок обходится в зигзагообразном порядке. Как видно из таблицы квантования, увеличение значений Q (и, соответственно, результата квантования) не происходит по типичной схеме слева направо, сверху вниз. Напротив, оно происходит от левого верхнего края к правому нижнему.\u003C\u002Fp\u003E\u003Cp\u003EЭто означает, что значения, которые, скорее всего, похожи и, следовательно, более сжимаемы, следуют друг за другом по диагонали. Зигзагообразный обход эффективно группирует эти похожие значения, оптимизируя сжатие.\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fb1e\u002F55d\u002F6d0\u002Fb1e55d6d0a5df517246250eb504dca6c.png\" width=\"360\" height=\"360\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fb1e\u002F55d\u002F6d0\u002Fb1e55d6d0a5df517246250eb504dca6c.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fb1e\u002F55d\u002F6d0\u002Fb1e55d6d0a5df517246250eb504dca6c.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EЗигзагообразный обход выполняется довольно хитро: используется массив из 64 элементов, который сопоставляет каждый обычный индекс с его зигзагообразным порядком.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003E\u002F\u002F unzig maps from the zig-zag ordering to the natural ordering. For example,\n\u002F\u002F unzig[3] is the column and row of the fourth element in zig-zag order. The\n\u002F\u002F value is 16, which means first column (16%8 == 0) and third row (16\u002F8 == 2).\nvar unzig = [blockSize]int{\n\t0, 1, 8, 16, 9, 2, 3, 10,\n\t17, 24, 32, 25, 18, 11, 4, 5,\n\t12, 19, 26, 33, 40, 48, 41, 34,\n\t27, 20, 13, 6, 7, 14, 21, 28,\n\t35, 42, 49, 56, 57, 50, 43, 36,\n\t29, 22, 15, 23, 30, 37, 44, 51,\n\t58, 59, 52, 45, 38, 31, 39, 46,\n\t53, 60, 61, 54, 47, 55, 62, 63,\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЕсли собрать все части вместе, получится, что основной цикл JPEG — это:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"go\"\u003E\u002F\u002F writeBlock writes a block of pixel data using the given quantization table,\n\u002F\u002F returning the post-quantized DC value of the DCT-transformed block. b is in\n\u002F\u002F natural (not zig-zag) order.\nfunc (e *encoder) writeBlock(b *block, q quantIndex, prevDC int32) int32 {\n\tfdct(b) \u002F\u002F apply DCT\n\t\u002F\u002F ...\n\tfor zig := 1; zig &lt; blockSize; zig++ {\n\t\tac := div(b[unzig[zig]], 8*int32(e.quant[q][zig])) \u002F\u002F divide zigzag DCT result by quantization number\n\t\tif ac == 0 {\n\t\t\t\u002F\u002F quantization result is 0, increase RLE\n\t\t\trunLength++\n\t\t} else {\n\t\t\t\u002F\u002F ...\n\t\t\t\u002F\u002F write the current RLE sequence\n\t\t\te.emitHuffRLE(h, runLength, ac)\n\t\t\trunLength = 0\n\t\t}\n\t}\n\t\u002F\u002F...\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EМы опустили довольно много деталей, но всё же можем видеть, как применяются различные идеи, которые мы рассмотрели.\u003C\u002Fp\u003E\u003Cp\u003EJPEG — настоящая сокровищница восхитительных инженерных решений, и то, что мы здесь обсудили, — лишь верхушка айсберга. Но я надеюсь, что это было познавательно и увлекательно.\u003C\u002Fp\u003E\u003Cp\u003EНа этом пока все. Ценю, что вы присоединились ко мне в этом путешествии.\u003C\u002Fp\u003E\u003Cp\u003EСпасибо!\u003C\u002Fp\u003E\u003Chr\u002F\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Ft.me\u002Fsravni_tech\"\u003E\u003Cstrong\u003EТГ-канал инженерного сообщества Sravni Tech\u003C\u002Fstrong\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"jpeg"},{"titleHtml":"png"},{"titleHtml":"gif"},{"titleHtml":"golang"},{"titleHtml":"изображения"},{"titleHtml":"go"},{"titleHtml":"картинки"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fc9d\u002Fb2d\u002Fc46\u002Fc9db2dc468e3c319b54d1ad8599f8898.jpg","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fc9d\u002Fb2d\u002Fc46\u002Fc9db2dc468e3c319b54d1ad8599f8898.jpg","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompanies\\\u002Fsravni\\\u002Farticles\\\u002F906964\\\u002F\"},\"headline\":\"Как на самом деле хранятся изображения?\",\"datePublished\":\"2025-05-06T14:47:10+03:00\",\"dateModified\":\"2025-05-07T00:14:25+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Sravni_Tech\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Этот пост &mdash; погружение в кроличью нору. Разработчик Монсеф Аббад задумался о изображениях &mdash; вероятно, после недавнего изучения им некоторых схем компрессии. Обще...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompanies\\\u002Fsravni\\\u002Farticles\\\u002F906964\\\u002F#post-content-body\",\"about\":[\"c_sravni\",\"h_go\",\"h_programming\",\"h_image_processing\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F906964\\\u002F250754799c5c4233d05b4de23c29dd58\\\u002F\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fcd5\\\u002Ff36\\\u002Fc82\\\u002Fcd5f36c82acd0a23a6e25dc2f8785b41.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F1a7\\\u002Fed6\\\u002F521\\\u002F1a7ed652160402b799d4121884ea8648.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F340\\\u002F53d\\\u002F973\\\u002F34053d9735f43dc00fc27c27074e7179.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F2e0\\\u002Fb3c\\\u002Fb52\\\u002F2e0b3cb525620acc688b87f5a39940cb.gif\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F5c7\\\u002Ff05\\\u002Fd2d\\\u002F5c7f05d2d5c4dd3eab5848bcbd8e04f3.gif\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F1d1\\\u002F907\\\u002Fed6\\\u002F1d1907ed6d1adef2f9d47bd249658993.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fb\\\u002Fbf\\\u002Fbf3\\\u002Fbf38f5a536aeb76b2b417069a2a8d9ba.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fec5\\\u002Fc0e\\\u002Feeb\\\u002Fec5c0eeebf57605c976be679d83baf05.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fe\\\u002Fe4\\\u002Fe45\\\u002Fe459c803c13c363f7bd03e9d332e9119.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fb1e\\\u002F55d\\\u002F6d0\\\u002Fb1e55d6d0a5df517246250eb504dca6c.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fc9d\\\u002Fb2d\\\u002Fc46\\\u002Fc9db2dc468e3c319b54d1ad8599f8898.jpg\"]}","metaDescription":"Этот пост — погружение в кроличью нору. Разработчик Монсеф Аббад задумался о изображениях — вероятно, после недавнего изучения им некоторых схем компрессии. Общеизвестно, что изображения бывают либо...","mainImageUrl":null,"amp":true,"customTrackerLinks":[]},"polls":[],"commentsEnabled":{"status":true,"reason":null},"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"hasPinnedComments":false,"format":null,"banner":null,"multiwidget":null,"multiwidgetUuid":null,"readingTime":29,"complexity":null,"isEditorial":false,"allowedFeatures":{"isTestTargetAllow":true}}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"postReasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"viewedPosts":[],"myFeedFilter":{"complexity":"all","score":"all","types":["articles","posts","news"]},"myFeedIsApplyFilters":false,"myFeedIsForce":false,"karma":{"userReasonsList":null}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":""},"comments":{"articleComments":{},"articlePinnedComments":{},"searchCommentsResults":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":"","idempotenceKey":""}},"companies":{"companyRefs":{"sravni":{"alias":"sravni","imageUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fcompany\u002F1cd\u002F7c2\u002Fe10\u002F1cd7c2e105e5f65ce3c80c6d03495ea3.png","titleHtml":"Сравни","descriptionHtml":null,"relatedData":null,"statistics":{"subscribersCount":1869,"rating":78.5,"invest":null,"postsCount":49,"threadsCount":24,"newsCount":12,"vacanciesCount":0,"employeesCount":28,"careerRating":4.57},"foundationDate":{"year":"2009","month":null,"day":null},"location":{"city":null,"region":null,"country":{"id":"168","title":"Россия"}},"siteUrl":"https:\u002F\u002Fwww.sravni.ru","staffNumber":"501–1 000 человек","registrationDate":"2022-01-11T12:13:19+00:00","representativeUser":null,"contacts":[{"title":"Сайт","url":"https:\u002F\u002Fwww.sravni.ru","siteTitle":"Сравни - подбор и сравнение вкладов, кредитов, кредитных карт, автострахование, калькулятор ОСАГО и каско, рейтинг страховых компаний","favicon":"https:\u002F\u002Fs91588.cdn.ngenix.net\u002Fshared\u002Fstatic\u002Ffavicon.ico"}],"settings":{"analyticsSettings":[{"type":"ym","trackingId":"96615894"}],"branding":null,"status":"active","isStartup":false,"hasActivePolls":false,"shouldShowHabrAds":true},"metadata":{"titleHtml":"Сравни, Россия -  с 2009 год","title":"Сравни, Россия -  с 2009 год","keywords":["микросервисы","аналитика"],"descriptionHtml":"49 статей от авторов компании Сравни","description":"49 статей от авторов компании Сравни"},"aDeskSettings":null,"careerAlias":"sravni","schoolAlias":null}},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"multiwidgets":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"multiwidgetLoading":false,"vacancies":{},"companiesGalleries":{},"companiesBanners":{},"companiesLandingVacancies":{},"companiesTechnologies":{},"workplaceInfo":null},"companyAdmin":{"companyInfo":null,"companyInfoLoading":false,"faqArticles":null,"brandingPreviewImageUrl":null,"jivoStatus":0,"adminNotifications":null,"availableInvitesCount":{}},"companyAdd":{"currentStep":"","stepsData":{},"uncompletedSteps":[],"isStepLoading":true,"isStepCommitting":false,"isInitialized":false,"agreementContent":""},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"pagesCount":0},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":true},"fixedBanner":{"isArticleStickyPanelVisible":false,"isArticleStickyPanelAtTheBottom":false,"isFixedBannerVisible":false,"isStickyPanelIconsHidden":false},"flows":{"updates":{}},"global":{"isPwa":false,"device":"desktop","isHabrCom":true,"requestId":"82423c14adabbefe4a89f50427b71f93"},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"welcomePage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"query":{},"pathname":"\u002Fru\u002Fcompanies\u002Fsravni\u002Farticles\u002F906964\u002F","path":"\u002Fru\u002Fcompanies\u002Fsravni\u002Farticles\u002F906964\u002F","href":"\u002Fru\u002Fcompanies\u002Fsravni\u002Farticles\u002F906964\u002F"}},"me":{"user":null,"uuid":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null,"userUpdates":{"feeds":{"newPostsCount":null,"newThreadsCount":null,"newNewsCount":null,"newCount":null},"conversationUnreadCount":0},"features":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"onboarding":{"currentStep":null,"stepsData":{},"stepsErrors":{},"completedSteps":[],"isStepCommitting":false,"isCommitDisabled":true},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{"salary":"project-block-company-article"}},"promoData":{"isLoading":false,"hasLoaded":false,"featurer":null,"megaposts":null,"promoLinks":null,"promoPosts":null,"sticker":null},"publicationStatistics":{"statsInfo":{},"statsFunnels":{},"statsGraph":{},"defaultSuggest":{},"suggest":{},"timeTracker":{},"isTrackingActivity":false,"isUserActive":true,"otherPublicationStats":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"search":{"searchQueryError":null},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":true,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"stories":{"stories":null},"technotext":{"years":[],"technotextDocForNominees":null,"technotextDocForWinners":null,"technotextInfo":{},"technotextInfoLoading":false,"technotextWinners":{},"technotextWinnersLoading":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"userVotes":{"karmaVotesList":[],"karmaVotesPagesCount":null,"karmaVotesListLoading":false,"commentsVotesList":[],"commentsVotesPagesCount":null,"commentsVotesListLoading":false,"postsVotesList":[],"postsVotesPagesCount":null,"postsVotesListLoading":false,"userVotesList":[],"userVotesPagesCount":null,"userVotesListLoading":false},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"userSpecialization":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"notificationsLoading":false,"notificationsList":[],"notificationsPageCount":0,"pendingMarkNotificationsRead":[],"publicationsLoading":true,"publicationsList":[],"publicationsPageCount":0,"pendingDeletePublications":false,"pendingMarkPublicationsRead":false},"events":{"eventRefs":{},"eventIds":[],"pagesCount":0,"categories":[],"cities":[],"actualEvents":null,"currentEvent":null,"eventsFilter":{"city":"all","timeStarted":null,"timeEnded":null}},"wysiwyg":{"WYSIWYGRulesRefs":null},"refs":{"specializationRefs":[]},"hint":{"hints":{}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
   <script src="https://assets.habr.com/habr-web/js/chunk-vendors.978df117.js" defer></script>
   <script src="https://assets.habr.com/habr-web/js/app.58b8c457.js" defer></script>
  </div>
  <div id="overlays">
   <!----><!--teleport anchor--><!----><!--teleport anchor--><!----><!--teleport anchor--><!----><!--teleport anchor--><!----><!--teleport anchor--><!----><!--teleport anchor-->
  </div>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-S28W1WC23F"></script>
  <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    </script>
  <script type="text/javascript">
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

  </script>
  <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
 </body>
</html>