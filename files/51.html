<!doctype html>
<html lang="ru">
 <head>
  <title>JavaScript: структуры данных и алгоритмы. Часть 11 / Хабр</title>
  <meta property="fb:app_id" content="444736788986613">
  <meta property="fb:pages" content="472597926099084">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@habr_com">
  <meta property="og:site_name" content="Хабр">
  <link href="https://habr.com/ru/rss/post/903842/?fl=ru" type="application/rss+xml" title rel="alternate" name="rss">
  <link href="https://habr.com/ru/companies/timeweb/articles/903842/" rel="canonical" data-hid="e3fa780">
  <link rel="image_src" href="https://habrastorage.org/webt/ma/po/lv/mapolvqq4uunxfqoaviv3g9km9y.jpeg" data-hid="2a79c45">
  <meta property="og:title" content="JavaScript: структуры данных и алгоритмы. Часть 11">
  <meta name="twitter:title" content="JavaScript: структуры данных и алгоритмы. Часть 11">
  <meta name="aiturec:title" content="JavaScript: структуры данных и алгоритмы. Часть 11">
  <meta name="description" content="Привет, друзья! В этой серии статей мы разбираем структуры данных и алгоритмы, представленные в этом замечательном репозитории . Это одиннадцатая часть серии. Сегодня мы рассмотрим несколько простых,...">
  <meta itemprop="description" content="Привет, друзья! В этой серии статей мы разбираем структуры данных и алгоритмы, представленные в этом замечательном репозитории . Это одиннадцатая часть серии. Сегодня мы рассмотрим несколько простых,...">
  <meta property="og:description" content="Привет, друзья! В этой серии статей мы разбираем структуры данных и алгоритмы, представленные в этом замечательном репозитории . Это одиннадцатая часть серии. Сегодня мы рассмотрим несколько простых,...">
  <meta name="twitter:description" content="Привет, друзья! В этой серии статей мы разбираем структуры данных и алгоритмы, представленные в этом замечательном репозитории . Это одиннадцатая часть серии. Сегодня мы рассмотрим несколько простых,...">
  <meta property="aiturec:description" content="Привет, друзья! В этой серии статей мы разбираем структуры данных и алгоритмы, представленные в этом замечательном репозитории . Это одиннадцатая часть серии. Сегодня мы рассмотрим несколько простых,...">
  <meta itemprop="image" content="https://habrastorage.org/webt/ma/po/lv/mapolvqq4uunxfqoaviv3g9km9y.jpeg">
  <meta property="og:image" content="https://habrastorage.org/webt/ma/po/lv/mapolvqq4uunxfqoaviv3g9km9y.jpeg">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="aiturec:image" content="https://habrastorage.org/webt/ma/po/lv/mapolvqq4uunxfqoaviv3g9km9y.jpeg">
  <meta name="twitter:image" content="https://habrastorage.org/webt/ma/po/lv/mapolvqq4uunxfqoaviv3g9km9y.jpeg">
  <meta property="vk:image" content="https://habrastorage.org/webt/ma/po/lv/mapolvqq4uunxfqoaviv3g9km9y.jpeg?format=vk">
  <meta property="vk:image" content="https://habrastorage.org/webt/ma/po/lv/mapolvqq4uunxfqoaviv3g9km9y.jpeg?format=vk">
  <meta property="aiturec:item_id" content="903842">
  <meta property="aiturec:datetime" content="2025-05-06T10:05:09.000Z">
  <meta content="https://habr.com/ru/companies/timeweb/articles/903842/" property="og:url">
  <meta property="og:type" content="article">
  <meta property="og:locale" content="ru_RU">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta name="keywords" content="timeweb_статьи, javascript, algorithms, data structures, алгоритмы, структуры данных, machine learning, statistics, машинное обучение, статистика">
  <script type="application/ld+json" data-hid="1e0f0a2">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/companies\/timeweb\/articles\/903842\/"},"headline":"JavaScript: структуры данных и алгоритмы. Часть 11","datePublished":"2025-05-06T13:05:09+03:00","dateModified":"2025-05-06T13:37:43+03:00","author":{"@type":"Person","name":"Igor Agapov"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Привет, друзья! В этой серии статей мы разбираем структуры данных и алгоритмы, представленные в этом замечательном репозитории. Это одиннадцатая часть серии. С...","url":"https:\/\/habr.com\/ru\/companies\/timeweb\/articles\/903842\/#post-content-body","about":["c_timeweb","h_javascript","h_algorithms","h_machine_learning","h_statistics","f_develop","f_popsci"],"image":["https:\/\/habr.com\/share\/publication\/903842\/73d84677204d0ca32f3939aa62754a21\/","https:\/\/habrastorage.org\/webt\/ma\/po\/lv\/mapolvqq4uunxfqoaviv3g9km9y.jpeg","https:\/\/habrastorage.org\/webt\/_g\/vw\/oh\/_gvwohoerz92tp_vet1rqqkwpuc.png","https:\/\/habrastorage.org\/webt\/jc\/9j\/h2\/jc9jh2sfgrprioxjlybno6wu7k0.png","https:\/\/habrastorage.org\/webt\/_t\/ln\/sz\/_tlnsz_p-p1dnornwgpazuttcdo.png","https:\/\/habrastorage.org\/webt\/4t\/53\/5d\/4t535dwgswdm5a4lkyivyqobkte.png","https:\/\/habrastorage.org\/webt\/j8\/lu\/4n\/j8lu4nhjzvzkzbkypc8azhqlepi.png","https:\/\/habrastorage.org\/webt\/kc\/rf\/hb\/kcrfhb350xpq2alm_jq9ulcb0z8.png","https:\/\/habrastorage.org\/webt\/i_\/4h\/ql\/i_4hqliq67go16a3922u6nv1b9q.png","https:\/\/habrastorage.org\/webt\/i_\/ow\/ws\/i_owwskzajk-3eyl7ok2cjl4dwg.png","https:\/\/habrastorage.org\/webt\/ar\/gt\/ai\/argtaipkmpfxghwvkauvjqfgl6w.gif","https:\/\/habrastorage.org\/webt\/rb\/y6\/cb\/rby6cbeenzlbh8y5mopfhz7aa9m.png","https:\/\/habrastorage.org\/webt\/y5\/ni\/g9\/y5nig9m7j9ss7n2frdfx_6r23ue.png","https:\/\/habrastorage.org\/webt\/kn\/nr\/ks\/knnrksemprmbzb6bhzwynhhq1p0.png","https:\/\/habrastorage.org\/webt\/yv\/ec\/lv\/yveclvo5luhp1_raoevkpeixwde.png","https:\/\/habrastorage.org\/webt\/zy\/4m\/is\/zy4misoszeia7nn7y1whwvv0h-a.png","https:\/\/habrastorage.org\/webt\/nr\/c9\/zb\/nrc9zbxcz_p_01b2by8llzashbi.png","https:\/\/habrastorage.org\/webt\/u8\/r_\/je\/u8r_je1xoj61zsekympel9fvy8c.png","https:\/\/habrastorage.org\/webt\/gd\/-u\/7b\/gd-u7b4un33ikvsst7yfd2klyfi.gif","https:\/\/habrastorage.org\/webt\/nj\/o8\/og\/njo8og0hl035vwkod3l0tjiskk0.png","https:\/\/habrastorage.org\/webt\/2w\/k8\/mb\/2wk8mbjs5v5ywihp4ddm1boqsig.png","https:\/\/habrastorage.org\/webt\/4z\/m6\/qc\/4zm6qcwanifvkkij-ftmlkuzpgk.png","https:\/\/habrastorage.org\/webt\/e9\/94\/i2\/e994i2o7uknxvrwxlxocf8amr9k.png","https:\/\/habrastorage.org\/webt\/b4\/vf\/m-\/b4vfm-aglfggwqjagfsl9g-uqsq.png","https:\/\/habrastorage.org\/webt\/6r\/9j\/sr\/6r9jsrljpzsgcfyj1jjupubij5e.png"]}</script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover,maximum-scale=1,user-scalable=0">
  <meta name="referrer" content="unsafe-url">
  <style>
      /* cyrillic-ext */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 400;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9E4kDNxMZdWfMOD5VvmojLazX3dGTP.woff2) format('woff2');
        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
      }

      /* cyrillic */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 400;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9E4kDNxMZdWfMOD5Vvk4jLazX3dGTP.woff2) format('woff2');
        unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
      }

      /* latin-ext */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 400;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9E4kDNxMZdWfMOD5VvmYjLazX3dGTP.woff2) format('woff2');
        unicode-range: U+0100-02AF, U+0304, U+0308, U+0329, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
      }

      /* latin */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 400;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9E4kDNxMZdWfMOD5Vvl4jLazX3dA.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
      }

      /* cyrillic-ext */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 500;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnZKveSxf6Xl7Gl3LX.woff2) format('woff2');
        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
      }

      /* cyrillic */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 500;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnZKveQhf6Xl7Gl3LX.woff2) format('woff2');
        unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
      }

      /* latin-ext */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 500;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnZKveSBf6Xl7Gl3LX.woff2) format('woff2');
        unicode-range: U+0100-02AF, U+0304, U+0308, U+0329, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
      }

      /* latin */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 500;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnZKveRhf6Xl7Glw.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
      }

      /* cyrillic-ext */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 700;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnLK3eSxf6Xl7Gl3LX.woff2) format('woff2');
        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
      }

      /* cyrillic */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 700;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnLK3eQhf6Xl7Gl3LX.woff2) format('woff2');
        unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
      }

      /* latin-ext */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 700;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnLK3eSBf6Xl7Gl3LX.woff2) format('woff2');
        unicode-range: U+0100-02AF, U+0304, U+0308, U+0329, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
      }

      /* latin */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 700;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnLK3eRhf6Xl7Glw.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
      }
    </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/theme/light-v1.css" as="style" media="(prefers-color-scheme: light)">
  <link rel="preload" href="https://assets.habr.com/habr-web/css/theme/dark-v1.css" as="style" media="(prefers-color-scheme: dark)">
  <link id="light-colors" rel="stylesheet" href="https://assets.habr.com/habr-web/css/theme/light-v1.css" media="(prefers-color-scheme: light)">
  <link id="dark-colors" rel="stylesheet" href="https://assets.habr.com/habr-web/css/theme/dark-v1.css" media="(prefers-color-scheme: dark)">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.635b6c39236ebd33fa716c71ab0131a0.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  <style>
      .grecaptcha-badge {
        visibility: hidden;
      }
    </style>
  <meta name="habr-version" content="2.241.0">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" type="image/png" sizes="16x16" href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png">
  <link rel="shortcut icon" type="image/png" sizes="32x32" href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png">
  <link rel="apple-touch-icon" type="image/png" sizes="76x76" href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png">
  <link rel="apple-touch-icon" type="image/png" sizes="120x120" href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png">
  <link rel="apple-touch-icon" type="image/png" sizes="152x152" href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png">
  <link rel="apple-touch-icon" type="image/png" sizes="180x180" href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png">
  <link rel="apple-touch-icon" type="image/png" sizes="256x256" href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)" href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)" href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)" href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)" href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)" href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)" href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)" href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png">
  <link rel="apple-touch-startup-image" media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png">
  <link rel="mask-icon" color="#77a2b6" href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg">
  <link crossorigin="use-credentials" href="/manifest.webmanifest" rel="manifest">
  <script async src="https://unpkg.com/pwacompat" crossorigin="anonymous"></script>
  <script>window.yaContextCb = window.yaContextCb || []</script>
  <script src="https://yandex.ru/ads/system/context.js" async></script>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.04465f7c.css" as="style">
  <link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.978df117.js" as="script">
  <link rel="preload" href="https://assets.habr.com/habr-web/css/app.8599692f.css" as="style">
  <link rel="preload" href="https://assets.habr.com/habr-web/js/app.58b8c457.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.04465f7c.css">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.8599692f.css">
 </head>
 <body>
  <div id="mount">
   <div id="app">
    <div class="tm-layout__wrapper">
     <!--[--><!---->
     <div></div><!---->
     <header class="tm-header" data-test-id="header">
      <div class="tm-page-width">
       <!--[-->
       <div class="tm-header__container">
        <!----><span class="tm-header__logo-wrap"><a class="tm-header__logo tm-header__logo_hl-ru tm-header__logo" href="/ru/">
          <svg class="tm-svg-img tm-header__icon" height="16" width="16">
           <title>
            Хабр
           </title><use xlink:href="/img/habr-logo-ru.svg#logo"></use>
          </svg></a><span style="display:none;" class="tm-header__beta-sign">β</span></span><!--[-->
        <div class="tm-dropdown tm-header__projects">
         <div class="tm-dropdown__head">
          <!--[-->
          <button class="tm-header__dropdown-toggle">
           <svg class="tm-svg-img tm-header__icon tm-header__icon_dropdown" height="16" width="16">
            <title>
             Открыть список
            </title><use xlink:href="/img/megazord-v28.7909a852..svg#arrow-down"></use>
           </svg></button><!--]-->
         </div><!---->
        </div><a href="/ru/sandbox/start/" class="tm-header__become-author-btn">Как стать автором</a>
        <div class="tm-feature tm-feature tm-feature_variant-inline tm-header__feature">
         <!---->
        </div><!----><!--]--><!---->
       </div><!--]-->
      </div>
     </header>
     <div class="tm-layout">
      <div class="tm-page-progress-bar"></div>
      <div class="tm-base-layout__header_is-sticky tm-base-layout__header" data-menu-sticky="true">
       <div class="tm-page-width">
        <!--[-->
        <div class="tm-base-layout__header-wrapper">
         <div class="tm-main-menu">
          <div class="tm-main-menu__section">
           <nav class="tm-main-menu__section-content">
            <!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/feed/">Моя лента</a><!--]--><!--[--><a class="tm-main-menu__item" href="/ru/articles/">Все потоки</a><!--]--><!--[--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/develop/">Разработка</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/admin/">Администрирование</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/design/">Дизайн</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/management/">Менеджмент</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/marketing/">Маркетинг</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/popsci/">Научпоп</a><!--]--><!--]-->
           </nav>
          </div>
         </div>
         <div class="tm-header-user-menu tm-base-layout__user-menu">
          <a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search" data-test-id="search-button">
           <svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark" height="24" width="24">
            <title>
             Поиск
            </title><use xlink:href="/img/megazord-v28.7909a852..svg#search"></use>
           </svg></a><!----><!---->
          <div class="tm-header-user-menu__item tm-header-user-menu__write">
           <div>
            <svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_write tm-header-user-menu__icon_dark" height="24" width="24">
             <title>
              Написать публикацию
             </title><use xlink:href="/img/megazord-v28.7909a852..svg#write"></use>
            </svg>
           </div><!---->
          </div><!--[-->
          <div class="tm-header-user-menu__item">
           <button class="tm-header-user-menu__toggle" data-test-id="user-menu-settings">
            <svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_dark" height="24" width="24">
             <title>
              Настройки
             </title><use xlink:href="/img/megazord-v28.7909a852..svg#page-settings"></use>
            </svg></button>
          </div><a href="https://habr.com/kek/v1/auth/habrahabr/?back=/ru/companies/timeweb/articles/903842/&amp;hl=ru" rel="nofollow" class="tm-header-user-menu__item"><!--[-->
           <button class="btn btn_solid btn_small tm-header-user-menu__login" type="button"><!--[-->Войти<!--]--></button><!--]--></a><!--]--><!----><!--teleport start--><!--teleport end--><!---->
         </div>
        </div><!--]-->
       </div>
      </div><!---->
      <div class="tm-page-width">
       <!--[--><!--]-->
      </div>
      <main class="tm-layout__container">
       <div class="tm-page" hl="ru" companyname="timeweb" data-async-called="true" style="--5ab2e5a8:16px;--44c4f6f6:100%;--45ba7a3b:0;">
        <div class="tm-page-width">
         <!--[-->
         <div class="tm-page__header">
          <!--[--><!--]-->
         </div>
         <div class="tm-page__wrapper">
          <div class="tm-page__main_has-sidebar tm-page__main">
           <div class="pull-down">
            <!---->
            <div class="pull-down__header" style="height:0px;">
             <div class="pull-down__content" style="bottom:10px;">
              <svg class="tm-svg-img pull-down__icon pull-down__arrow" height="24" width="24">
               <title>
                Обновить
               </title><use xlink:href="/img/megazord-v28.7909a852..svg#pull-arrow"></use>
              </svg>
             </div>
            </div><!--[--><!--[-->
            <div class="tm-article-presenter">
             <!--[--><!--[--><!---->
             <div class="tm-company-profile-card tm-company-article__profile-card">
              <div class="tm-company-card tm-company-profile-card__info">
               <div class="tm-company-card__header">
                <a href="/ru/companies/timeweb/profile/" class="tm-company-card__avatar">
                 <div class="tm-entity-image">
                  <img alt="" class="tm-entity-image__pic" height="48" src="//habrastorage.org/getpro/habr/company/7dd/ba1/4f4/7ddba14f4fc46943da7d3bbadc46b55a.png" width="48">
                 </div></a><!--[--><!---->
                <div class="tm-counter-container tm-company-card__rating">
                 <div class="tm-counter-container__header">
                  <!--[--><!--[--><!--]-->
                  <div class="tm-votes-lever tm-votes-lever tm-votes-lever_appearance-rating">
                   <!---->
                   <div class="tm-votes-lever__score tm-votes-lever__score_appearance-rating tm-votes-lever__score_no-margin tm-votes-lever__score">
                    <!--[--><span><span class="tm-votes-lever__score-counter tm-votes-lever__score-counter_rating tm-votes-lever__score-counter" data-test-id="votes-score-counter">1524.98</span></span><!--]-->
                   </div><!---->
                  </div><!--]-->
                 </div>
                 <div class="tm-counter-container__footer">
                  <!--[--><span class="tm-rating__text tm-rating__text">Рейтинг</span><!--]-->
                 </div>
                </div><!----><!--]-->
               </div>
               <div class="tm-company-card__info">
                <a href="/ru/companies/timeweb/profile/" class="tm-company-card__name"><span>Timeweb Cloud</span></a>
                <div class="tm-company-card__description">
                 То самое облако
                </div>
               </div>
              </div>
              <div class="tm-company-profile-card__buttons">
               <div class="tm-button-follow tm-company-profile-card__button tm-company-profile-card__button_follow">
                <!---->
                <button class="tm-button-follow__button tm-button-follow__button_big" data-test-id="follow-button" type="button">Подписаться</button>
               </div><!----><!----><!---->
              </div>
             </div><!----><!--]--><!--]-->
             <div class="tm-article-presenter__body" data-test-id="article-body">
              <div class="tm-misprint-area">
               <div class="tm-misprint-area__wrapper">
                <!--[-->
                <article class="tm-article-presenter__content tm-article-presenter__content_narrow">
                 <!--[-->
                 <div class="tm-article-presenter__header">
                  <!--[--><!--]-->
                  <div class="tm-article-snippet tm-article-snippet tm-article-presenter__snippet">
                   <!--[--><!--]-->
                   <div class="tm-article-snippet__meta-container">
                    <div class="tm-article-snippet__meta">
                     <span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/aio350/" class="tm-user-info__userpic" data-test-id="user-info-pic" title="aio350">
                       <div class="tm-entity-image">
                        <img alt="" class="tm-entity-image__pic" height="24" src="//habrastorage.org/r/w48/getpro/habr/avatars/4d3/879/a5a/4d3879a5a72249d5267d1f152ac59d40.jpg" width="24">
                       </div></a><span class="tm-user-info__user tm-user-info__user_appearance-default" data-test-id="user-info-description"><a href="/ru/users/aio350/" class="tm-user-info__username">aio350 <!----></a><!--[--><span class="tm-article-datetime-published"><time datetime="2025-05-06T10:05:09.000Z" title="2025-05-06, 13:05">20 часов назад</time></span><!--]--></span></span>
                    </div><!---->
                   </div>
                   <h1 class="tm-title tm-title_h1" lang="ru" data-test-id="articleTitle"><span>JavaScript: структуры данных и алгоритмы. Часть 11</span></h1>
                   <div class="tm-article-snippet__stats" data-test-id="articleStats">
                    <div class="tm-article-complexity tm-article-complexity_complexity-medium">
                     <span class="tm-svg-icon__wrapper tm-article-complexity__icon">
                      <svg class="tm-svg-img tm-svg-icon" height="24" width="24">
                       <title>
                        Уровень сложности
                       </title><use xlink:href="/img/megazord-v28.7909a852..svg#complexity-medium"></use>
                      </svg></span><span class="tm-article-complexity__label">Средний</span>
                    </div>
                    <div class="tm-article-reading-time">
                     <span class="tm-svg-icon__wrapper tm-article-reading-time__icon">
                      <svg class="tm-svg-img tm-svg-icon" height="24" width="24">
                       <title>
                        Время на прочтение
                       </title><use xlink:href="/img/megazord-v28.7909a852..svg#clock"></use>
                      </svg></span><span class="tm-article-reading-time__label">25 мин</span>
                    </div><span class="tm-icon-counter tm-data-icons__item">
                     <svg class="tm-svg-img tm-icon-counter__icon" height="24" width="24">
                      <title>
                       Количество просмотров
                      </title><use xlink:href="/img/megazord-v28.7909a852..svg#counter-views"></use>
                     </svg><span class="tm-icon-counter__value" title="1531">1.5K</span></span>
                   </div>
                   <div class="tm-publication-hubs__container" data-test-id="articleHubsList">
                    <div class="tm-publication-hubs">
                     <!--[--><span class="tm-publication-hub__link-container"><a href="/ru/companies/timeweb/articles/" class="tm-publication-hub__link"><!--[--><span>Блог компании Timeweb Cloud</span><!----><!--]--></a></span><span class="tm-publication-hub__link-container"><a href="/ru/hubs/javascript/" class="tm-publication-hub__link"><!--[--><span>JavaScript</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><span class="tm-publication-hub__link-container"><a href="/ru/hubs/algorithms/" class="tm-publication-hub__link"><!--[--><span>Алгоритмы</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><span class="tm-publication-hub__link-container"><a href="/ru/hubs/machine_learning/" class="tm-publication-hub__link"><!--[--><span>Машинное обучение</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><span class="tm-publication-hub__link-container"><a href="/ru/hubs/statistics/" class="tm-publication-hub__link"><!--[--><span>Статистика в IT</span><!----><!--]--></a></span><!--]-->
                    </div>
                   </div>
                   <div class="tm-article-labels" data-test-id="articleLabels">
                    <div class="tm-article-labels__container">
                     <div class="tm-publication-label tm-publication-label_variant-review">
                      <span>Обзор</span>
                     </div><!--[--><!--]-->
                    </div>
                   </div><!----><!---->
                  </div>
                 </div><!--[--><!---->
                 <div class="tm-article-body" data-gallery-root lang="ru">
                  <div>
                   <!--[--><!--]-->
                  </div>
                  <div id="post-content-body">
                   <div>
                    <div class="article-formatted-body article-formatted-body article-formatted-body_version-1">
                     <div xmlns="http://www.w3.org/1999/xhtml">
                      <img src="https://habrastorage.org/r/w1560/webt/ma/po/lv/mapolvqq4uunxfqoaviv3g9km9y.jpeg" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/ma/po/lv/mapolvqq4uunxfqoaviv3g9km9y.jpeg 780w,
       https://habrastorage.org/r/w1560/webt/ma/po/lv/mapolvqq4uunxfqoaviv3g9km9y.jpeg 781w" loading="lazy" decode="async">
                      <br>
                      <p><br>
                        Привет, друзья!</p>
                      <br>
                      <p>В этой серии статей мы разбираем структуры данных и алгоритмы, представленные в <a href="https://github.com/trekhleb/javascript-algorithms">этом замечательном репозитории</a>. Это одиннадцатая часть серии.</p>
                      <br>
                      <p>Сегодня мы рассмотрим несколько простых, но интересных алгоритмов машинного обучения, а также один весьма любопытный статистический алгоритм.</p>
                      <br>
                      <p>Код, представленный в этой и других статьях серии, можно найти в <a href="https://github.com/harryheman/algorithms-data-structures">этом репозитории</a>.</p>
                      <br>
                      <p>Интересно? Тогда прошу под кат.</p><a name="habracut"></a>
                      <br>
                      <ul>
                       <li><a href="https://habr.com/ru/companies/timeweb/articles/826424/">Первая часть</a></li>
                       <li><a href="https://habr.com/ru/companies/timeweb/articles/828068/">Вторая часть</a></li>
                       <li><a href="https://habr.com/ru/companies/timeweb/articles/832402/">Третья часть</a></li>
                       <li><a href="https://habr.com/ru/companies/timeweb/articles/836782/">Четвертая часть</a></li>
                       <li><a href="https://habr.com/ru/companies/timeweb/articles/838794/">Пятая часть</a></li>
                       <li><a href="https://habr.com/ru/companies/timeweb/articles/845544/">Шестая часть</a></li>
                       <li><a href="https://habr.com/ru/companies/timeweb/articles/856046/">Седьмая часть</a></li>
                       <li><a href="https://habr.com/ru/companies/timeweb/articles/856046/">Восьмая часть</a></li>
                       <li><a href="https://habr.com/ru/companies/timeweb/articles/856046/">Девятая часть</a></li>
                       <li><a href="https://habr.com/ru/companies/timeweb/articles/856046/">Десятая часть</a></li>
                      </ul>
                      <br>
                      <h1 id="-mashinnoe-obuchenie">❯ Машинное обучение</h1>
                      <br>
                      <h2 id="-nanoneuron">❯ NanoNeuron</h2>
                      <br>
                      <p>NanoNeuron (далее — нейрончик) — это очень упрощенная версия концепции нейронов из нейронных сетей. Нейрончик умеет конвертировать значения температуры из градусов Цельсия в градусы Фаренгейта.</p>
                      <br>
                      <p>Код примера содержит 7 простых функций (затрагивающих предсказание модели, вычисление стоимости, прямое/обратное распространение и обучение), позволяющих понять, как машины на самом деле "обучаются". В коде нет сторонних библиотек, внешних зависимостей или наборов данных, только чистые и простые функции.</p>
                      <br>
                      <p>Эти функции не являются руководством по машинному обучению. Многие концепции машинного обучения отсутствуют и упрощены! Упрощение преследует цель дать читателю самое базовое понимание того, как учатся машины, а также того, что машинное обучение — это не магия, а математика.</p>
                      <br>
                      <p><strong>Чему NanoNeuron будет учиться?</strong></p>
                      <br>
                      <p>Вероятно, вы слышали о нейронах в контексте <a href="https://ru.wikipedia.org/wiki/%D0%9D%D0%B5%D0%B9%D1%80%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B5%D1%82%D1%8C">нейронных сетей</a>. Нейрончик — это как раз такой нейрон, только проще. Мы реализуем его с нуля. Для простоты мы даже не будем создавать сеть из нейрончиков. Он будет работать сам по себе, делая некоторые "магические" предсказания для нас. Мы научим его конвертировать (предсказывать) температуру в градусах Фаренгейта на основе температуры в градусах Цельсия.</p>
                      <br>
                      <p>Кстати, формула для такого преобразования следующая:</p>
                      <br>
                      <pre><code class="plaintext">f = c * 1.8 + 32</code></pre>
                      <br>
                      <p>Но пока наш нейрончик о ней не знает.</p>
                      <br>
                      <p><strong>Модель NanoNeuron</strong></p>
                      <br>
                      <p>Определим функцию моделирования нейрончика. Она реализует базовую линейную зависимость между <code>x</code> и <code>y</code>, которая выглядит как <code>y = w * x + b</code>. Проще говоря, наш нейрончик — это "ребенок" в "школе", который учится рисовать прямую линию в системе координат <code>XY</code>.</p>
                      <br>
                      <p>Переменные <code>w</code> и <code>b</code> — это параметры модели. Нейрончику известны только эти параметры линейной функции. Он "выучит" значения этих параметров в процессе обучения.</p>
                      <br>
                      <p>Единственная вещь, которую умеет делать нейрончик, — это имитация линейной зависимости. В методе <code>predict()</code> он принимает некоторый <code>x</code> и предсказывает <code>y</code>. Никакой магии:</p>
                      <br>
                      <pre><code class="javascript">function NanoNeuron(w, b) {
  this.w = w;
  this.b = b;
  this.predict = (x) =&gt; {
    return x * this.w + this.b;
  }
}</code></pre>
                      <br>
                      <p><a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D0%BD%D0%B5%D0%B9%D0%BD%D0%B0%D1%8F_%D1%80%D0%B5%D0%B3%D1%80%D0%B5%D1%81%D1%81%D0%B8%D1%8F">Линейная регрессия</a> — это ты?🧐</p>
                      <br>
                      <p><strong>Преобразование градусов</strong></p>
                      <br>
                      <pre><code class="javascript">function celsiusToFahrenheit(c) {
  const w = 1.8;
  const b = 32;
  const f = c * w + b;
  return f;
};</code></pre>
                      <br>
                      <p>Мы хотим научить нейрончика имитировать эту функцию, т.е. научить, что <code>w = 1.8</code>, а <code>b = 32</code> без предоставления этих значений.</p>
                      <br>
                      <p>Графически эту функцию можно представить следующим образом:</p>
                      <br><img src="https://habrastorage.org/r/w1560/webt/_g/vw/oh/_gvwohoerz92tp_vet1rqqkwpuc.png" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/_g/vw/oh/_gvwohoerz92tp_vet1rqqkwpuc.png 780w,
       https://habrastorage.org/r/w1560/webt/_g/vw/oh/_gvwohoerz92tp_vet1rqqkwpuc.png 781w" loading="lazy" decode="async">
                      <br>
                      <p><br></p>
                      <br>
                      <p><strong>Генерация наборов данных</strong></p>
                      <br>
                      <p>Перед обучением модели нужно сгенерировать наборы тренировочных и тестовых данных на основе функции <code>celsiusToFahrenheit()</code>. Наборы состоят из пар входных значений и правильно размеченных результатов.</p>
                      <br>
                      <blockquote>
                       В реальной жизни данные, как правило, собираются, а не генерируются. Например, у нас может быть набор изображений с рукописными цифрами и набор соответствующих цифр.
                      </blockquote>
                      <p>Для обучения нейрончика используется тренировочный набор. Перед тем, как нейрончик вырастет и сможет принимать решения самостоятельно, мы должны объяснить ему, что такое хорошо и что такое плохо с помощью тренировочных примеров.</p>
                      <br>
                      <p>Тестовый набор используется для проверки того, насколько хорошо нейрончик обрабатывает данные, которых он не видел в процессе обучения. Это та точка, когда мы видим, что наш "ребенок" вырос и может принимать самостоятельные решения:</p>
                      <br>
                      <pre><code class="javascript">function generateDataSets() {
  // xTrain -&gt; [0, 1, 2, ...],
  // yTrain -&gt; [32, 33.8, 35.6, ...]
  const xTrain = [];
  const yTrain = [];
  for (let x = 0; x &lt; 100; x += 1) {
    const y = celsiusToFahrenheit(x);
    xTrain.push(x);
    yTrain.push(y);
  }

  // xTest -&gt; [0.5, 1.5, 2.5, ...]
  // yTest -&gt; [32.9, 34.7, 36.5, ...]
  const xTest = [];
  const yTest = [];
  // Начиная с 0.5 и используя такой же шаг 1,
  // который мы использовали для тренировочного набора,
  // мы обеспечиваем уникальность данных
  for (let x = 0.5; x &lt; 100; x += 1) {
    const y = celsiusToFahrenheit(x);
    xTest.push(x);
    yTest.push(y);
  }

  return [xTrain, yTrain, xTest, yTest];
}</code></pre>
                      <br>
                      <p><strong>Стоимость (ошибка) предсказания</strong></p>
                      <br>
                      <p>Нам нужен какой-то критерий верности предсказания. Вычисление стоимости (ошибки) между правильным значением <code>y</code> и <code>prediction</code> (предсказанием), сделанным нейрончиком, производится по следующей формуле:</p>
                      <br>
                      <pre><code class="plaintext">predictionCost = (y - prediction) ** 2 * 0.5</code></pre>
                      <br>
                      <p>Это просто разница между двумя значениями. Чем ближе значения друг к другу, тем меньше разница. Мы используем степень <code>2</code> для избавления от отрицательных чисел, поэтому <code>(1 - 2) ** 2</code> = <code>(2 - 1) ** 2</code>. Деление на <code>2</code> выполняется для упрощения дальнейшей формулы обратного распространения (см. ниже):</p>
                      <br>
                      <pre><code class="javascript">function predictionCost(y, prediction) {
  return (y - prediction) ** 2 / 2;
}</code></pre>
                      <br>
                      <p><strong>Прямое распространение</strong></p>
                      <br>
                      <p>Прямое распространение (forward propagation) означает выполнение предсказаний для всех тренировочных примеров из наборов <code>xTrain</code> и <code>yTrain</code> и вычисление средней стоимости этих предсказаний.</p>
                      <br>
                      <p>Мы позволяет нейрончику играть в "угадайку". Он может сильно ошибаться. Средняя стоимость покажет нам, насколько некорректной является наша модель. Эта стоимость очень важна, поскольку влияет на параметры <code>w</code> и <code>b</code>, которыми оперирует нейрончик. Повторное выполнение прямого распространения показывает, стал ли нейрончик умнее после соответствующих изменений.</p>
                      <br>
                      <p>Средняя стоимость вычисляется по такой формуле:</p>
                      <br><img src="https://habrastorage.org/r/w1560/webt/jc/9j/h2/jc9jh2sfgrprioxjlybno6wu7k0.png" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/jc/9j/h2/jc9jh2sfgrprioxjlybno6wu7k0.png 780w,
       https://habrastorage.org/r/w1560/webt/jc/9j/h2/jc9jh2sfgrprioxjlybno6wu7k0.png 781w" loading="lazy" decode="async">
                      <br>
                      <p><br></p>
                      <br>
                      <p>Где <code>m</code> — это количество тренировочных примеров (<code>100</code> в нашем случае).</p>
                      <br>
                      <pre><code class="javascript">function forwardPropagation(model, xTrain, yTrain) {
  const m = xTrain.length;
  const predictions = [];
  let cost = 0;
  for (let i = 0; i &lt; m; i += 1) {
    const prediction = nanoNeuron.predict(xTrain[i]);
    cost += predictionCost(yTrain[i], prediction);
    predictions.push(prediction);
  }
  // Нас интересует средняя стоимость
  cost /= m;
  return [predictions, cost];
}</code></pre>
                      <br>
                      <p><strong>Обратное распространение</strong></p>
                      <br>
                      <p>После того, как мы узнали, насколько верными являются предсказания модели (на основе средней стоимости), как нам сделать их более точными?</p>
                      <br>
                      <p>Ответ — обратное распространение (backward propagation). Обратное распространение — это процесс оценки стоимости предсказания и модификации параметров <code>w</code> и <code>b</code> таким образом, чтобы будущие предсказания были более точными.</p>
                      <br>
                      <p>В этом месте машинное обучение выглядит как магия. Ключевой концепцией здесь является производная (derivative), которая показывает, какой шаг необходимо предпринять, чтобы подобраться к минимальной функции стоимости (minimum cost function).</p>
                      <br>
                      <p>Помните, что нахождение минимальной функции стоимости — это конечная цель обучения. Если мы нашли значения <code>w</code> и <code>b</code>, которые делают среднюю стоимость маленькой, значит, модель будет делать хорошие и точные предсказания.</p>
                      <br>
                      <p>Производные — это большая и отдельная тема, выходящая за рамки нашей беседы. <a href="https://www.mathsisfun.com/calculus/derivatives-introduction.html">MathIsFun</a> — отличный ресурс для начала погружения в эту тему.</p>
                      <br>
                      <p>Производная, по сути, является касательной к кривой функции, которая указывает в направлении минимума функции:</p>
                      <br><img src="https://habrastorage.org/r/w1560/webt/_t/ln/sz/_tlnsz_p-p1dnornwgpazuttcdo.png" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/_t/ln/sz/_tlnsz_p-p1dnornwgpazuttcdo.png 780w,
       https://habrastorage.org/r/w1560/webt/_t/ln/sz/_tlnsz_p-p1dnornwgpazuttcdo.png 781w" loading="lazy" decode="async">
                      <br>
                      <p><br></p>
                      <br>
                      <p>Из приведенного графика следует, что если мы находимся в точке <code>(x=2, y=4)</code>, то кривая "говорит" нам двигаться влево и вниз для достижения минимума функции.</p>
                      <br>
                      <p>Производные функции <code>averageCost()</code> для параметров <code>w</code> и <code>b</code> выглядят так:</p>
                      <br><img src="https://habrastorage.org/r/w1560/webt/4t/53/5d/4t535dwgswdm5a4lkyivyqobkte.png" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/4t/53/5d/4t535dwgswdm5a4lkyivyqobkte.png 780w,
       https://habrastorage.org/r/w1560/webt/4t/53/5d/4t535dwgswdm5a4lkyivyqobkte.png 781w" loading="lazy" decode="async">
                      <br><img src="https://habrastorage.org/r/w1560/webt/j8/lu/4n/j8lu4nhjzvzkzbkypc8azhqlepi.png" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/j8/lu/4n/j8lu4nhjzvzkzbkypc8azhqlepi.png 780w,
       https://habrastorage.org/r/w1560/webt/j8/lu/4n/j8lu4nhjzvzkzbkypc8azhqlepi.png 781w" loading="lazy" decode="async">
                      <br>
                      <p><br></p>
                      <br>
                      <p>Где <code>m</code> — количество тренировочных примеров (<code>100</code> в нашем случае).</p>
                      <br>
                      <pre><code class="javascript">function backwardPropagation(predictions, xTrain, yTrain) {
  const m = xTrain.length;
  // В начале мы не знаем, как менять параметры 'w' и 'b'.
  // Поэтому устанавливаем шаг изменения для каждого параметра в 0
  let dW = 0;
  let dB = 0;
  for (let i = 0; i &lt; m; i += 1) {
    dW += (yTrain[i] - predictions[i]) * xTrain[i];
    dB += yTrain[i] - predictions[i];
  }
  // Нас интересует средняя дельта каждого параметра
  dW /= m;
  dB /= m;
  return [dW, dB];
}</code></pre>
                      <br>
                      <p><strong>Обучение модели</strong></p>
                      <br>
                      <p>Теперь мы знаем, как оценивать корректность модели для всех тренировочных примеров (прямое распространение). Мы также знаем, как применять небольшие модификации параметров <code>w</code> и <code>b</code> модели (обратное распространение). Но проблема состоит в том, что однократного запуска прямого и обратного распространений недостаточно для того, чтобы наша модель извлекла какие-то уроки из тренировочных данных. Это можно сравнить с одним днем обучения ребенка в школе. Ребенок ходит в школу не однажды, а день за днем и год за годом, чтобы чему-нибудь научиться.</p>
                      <br>
                      <p>Поэтому распространения следует повторять много раз. Это как раз то, что делает функция <code>trainModel()</code>. Это как учитель для нашего нейрончика:</p>
                      <br>
                      <ul>
                       <li>он проводит некоторое время (<code>epochs</code>) с нашим глупым нейрончиком и пытается его чему-то научить</li>
                       <li>он использует специальные "книги" (наборы данных <code>xTrain</code> и <code>yTrain</code>) для обучения</li>
                       <li>он заставляет нейрончика учиться усерднее (быстрее) с помощью параметра оценки обучения <code>alpha</code></li>
                      </ul>
                      <br>
                      <p>Несколько слов об <code>alpha</code>. Это просто произведение <code>dW</code> и <code>dB</code>, вычисленных в процессе обратного распространения. Производная указывает нам направление, в котором мы должны двигаться для достижения минимума функции стоимости (положительные/отрицательные знаки <code>dW</code> и <code>dB</code>), а также скорость, с которой мы должны двигаться в этом направлении (абсолютные значения <code>dW</code> и <code>dB</code>). Нам нужно умножить эти шаги на <code>alpha</code>, чтобы ускорить или замедлить наше движение к минимуму. При использовании больших значений для <code>alpha</code> можно просто перепрыгнуть минимум и никогда его не найти.</p>
                      <br>
                      <p>Если использовать аналогию с учителем, то можно сказать, что чем сильнее учитель будет давить на ребенка, тем быстрее он будет учиться, но если учитель будет давить слишком сильно, то у ребенка случится нервный срыв и больше учиться он не сможет 🤯</p>
                      <br>
                      <p>Параметры <code>w</code> и <code>b</code> будут обновляться следующим образом:</p>
                      <br>
                      <pre><code class="plaintext">w = w + alpha * dW
b = b + alpha * dB</code></pre>
                      <br>
                      <p>Функция обучения:</p>
                      <br>
                      <pre><code class="javascript">function trainModel({model, epochs, alpha, xTrain, yTrain}) {
  // История обучения
  const costHistory = [];

  // Перебираем эпохи
  for (let epoch = 0; epoch &lt; epochs; epoch += 1) {
    // Прямое распространение
    const [predictions, cost] = forwardPropagation(model, xTrain, yTrain);
    costHistory.push(cost);

    // Обратное распространение
    const [dW, dB] = backwardPropagation(predictions, xTrain, yTrain);

    // Модифицируем параметры модели для повышения точности предсказаний
    nanoNeuron.w += alpha * dW;
    nanoNeuron.b += alpha * dB;
  }

  return costHistory;
}</code></pre>
                      <br>
                      <p><strong>Вместе веселее</strong></p>
                      <br>
                      <p>Применим созданные функции.</p>
                      <br>
                      <p>Создаем экземпляр <code>NanoNeuron</code>. В данный момент нейрончику неизвестны значения <code>w</code> и <code>b</code>. Устанавливаем их произвольно:</p>
                      <br>
                      <pre><code class="javascript">const w = Math.random(); // например -&gt; 0.9492
const b = Math.random(); // например -&gt; 0.4570
const nanoNeuron = new NanoNeuron(w, b);</code></pre>
                      <br>
                      <p>Генерируем наборы данных:</p>
                      <br>
                      <pre><code class="javascript">const [xTrain, yTrain, xTest, yTest] = generateDataSets();</code></pre>
                      <br>
                      <p>Обучаем модель небольшими шагами (<code>0.0005</code>) на протяжении <code>7000</code> эпох. Эти значения были определены эмпирическим путем, не стесняйтесь их менять:</p>
                      <br>
                      <pre><code class="javascript">const epochs = 70000;
const alpha = 0.0005;
const trainingCostHistory = trainModel({ model: nanoNeuron, epochs, alpha, xTrain, yTrain });</code></pre>
                      <br>
                      <p>Проверяем функцию стоимости в процессе обучения. Мы ожидаем, что стоимость после обучения будет значительно ниже, чем до него. Это будет означать, что нейрончик стал умнее. Противоположное также возможно:</p>
                      <br>
                      <pre><code class="javascript">console.log('Стоимость до обучения:', trainingCostHistory[0]); // например, 4694.3335043
console.log('Стоимость после обучения:', trainingCostHistory[epochs - 1]); // например, 0.0000024</code></pre>
                      <br>
                      <p>Графически снижение стоимости выглядит так (ось <code>x</code> — количество эпох):</p>
                      <br><img src="https://habrastorage.org/r/w1560/webt/kc/rf/hb/kcrfhb350xpq2alm_jq9ulcb0z8.png" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/kc/rf/hb/kcrfhb350xpq2alm_jq9ulcb0z8.png 780w,
       https://habrastorage.org/r/w1560/webt/kc/rf/hb/kcrfhb350xpq2alm_jq9ulcb0z8.png 781w" loading="lazy" decode="async">
                      <br>
                      <p><br></p>
                      <br>
                      <p>Взглянем на параметры модели. Мы ожидаем, что <code>w</code> и <code>b</code> нейрончика будут близки к истинным (<code>w = 1.8</code> и <code>b = 32</code>):</p>
                      <br>
                      <pre><code class="javascript">console.log('Параметры нейрончика:', { w: nanoNeuron.w, b: nanoNeuron.b }); // например -&gt; { w: 1.8, b: 31.99 }</code></pre>
                      <br>
                      <p>Оцениваем точность модели на тестовых данных, чтобы увидеть, как хорошо нейрончик справляется с обработкой неизвестных данных. Мы ожидаем, что стоимость тестовых предсказаний будет близка к стоимости тренировочных предсказаний:</p>
                      <br>
                      <pre><code class="javascript">[testPredictions, testCost] = forwardPropagation(nanoNeuron, xTest, yTest);
console.log('Стоимость тестовых предсказаний:', testCost); // например -&gt; 0.0000023</code></pre>
                      <br>
                      <p>Теперь, поскольку наш "ребенок" хорошо показал себя при обучении в "школе" и научился правильно обрабатывать данные, которых он не видел, мы можем назвать его "умным" и задать ему парочку вопросов. В этом и заключалась цель обучения:</p>
                      <br>
                      <pre><code class="javascript">const tempInCelsius = 70;
const customPrediction = nanoNeuron.predict(tempInCelsius);
console.log(`Нейрончик "думает", что ${tempInCelsius}°C в градусах Фаренгейта:`, customPrediction); // -&gt; 158.0002
console.log('Правильный ответ:', celsiusToFahrenheit(tempInCelsius)); // -&gt; 158</code></pre>
                      <br>
                      <p>Очень близко! Наш нейрончик хорош, но не идеален, как все люди :)</p>
                      <br>
                      <div class="spoiler" role="button" tabindex="0">
                       <b class="spoiler_title">Полный код:</b>
                       <div class="spoiler_text">
                        <pre><code class="javascript">// Модель NanoNeuron (нейрончика).
// Она реализует базовую линейную зависимость между 'x' и 'y': y = w * x + b.
// Проще говоря, наш нейрончик - это "ребенок", умеющий рисовать прямую линию в системе координат XY.
// w, b - параметры модели
class NanoNeuron {
  constructor(w, b) {
    // Нейрончику известны только эти два параметра линейной функции.
    // Значения этих параметров будут определяться нейрончиком в процессе обучения
    this.w = w
    this.b = b
  }
  // Все, что умеет нейрончик, - имитировать линейную зависимость.
  // Он принимает некоторый 'x' и предсказывает 'y'. Никакой магии
  predict(x) {
    return x * this.w + this.b
  }
}

// Конвертирует градусы Цельсия в градусы Фаренгейта по формуле: f = 1.8 * c + 32.
// Мы хотим научить нейрончика имитировать эту функцию, т.е.
// научить, что W = 1.8, а B = 32 без предоставления этих значений.
// c - температура в градусах Цельсия
// f - вычисленная температура в градусах Фаренгейта
const W = 1.8
const B = 32
function celsiusToFahrenheit(c) {
  const f = c * W + B
  return f
}

// Генерирует обучающий и тестовый наборы данных с помощью функции celsiusToFahrenheit().
// Наборы состоят из пар входных значений и правильно размеченных результатов.
// В реальной жизни в большинстве случаев эти данные будут собраны, а не сгенерированы.
// Например, у нас может быть набор изображений рукописных цифр и
// набор соответствующих цифр
function generateDataSets() {
  // Генерируем ТРЕНИРОВОЧНЫЕ данные.
  // Эти данные будут использоваться для обучения модели.
  // Перед тем, как нейрончик вырастет и сможет принимать решения самостоятельно,
  // мы должны объяснить ему, что такое хорошо и что такое плохо с помощью
  // тренировочных примеров.
  // xTrain -&gt; [0, 1, 2, ...],
  // yTrain -&gt; [32, 33.8, 35.6, ...]
  const xTrain = []
  const yTrain = []
  for (let x = 0; x &lt; 100; x += 1) {
    const y = celsiusToFahrenheit(x)
    xTrain.push(x)
    yTrain.push(y)
  }

  // Генерируем ТЕСТОВЫЕ данные.
  // Эти данные будут использоваться для оценки того, насколько хорошо модель работает с данными,
  // которых она не видела в процессе обучения. Здесь мы можем увидеть,
  // что наш "ребенок" вырос и может принимать решения самостоятельно.
  // xTest -&gt; [0.5, 1.5, 2.5, ...]
  // yTest -&gt; [32.9, 34.7, 36.5, ...]
  const xTest = []
  const yTest = []
  // Начиная с 0.5 и используя такой же шаг 1,
  // который мы использовали для тренировочного набора,
  // мы обеспечиваем уникальность данных
  for (let x = 0.5; x &lt; 100; x += 1) {
    const y = celsiusToFahrenheit(x)
    xTest.push(x)
    yTest.push(y)
  }

  return [xTrain, yTrain, xTest, yTest]
}

// Вычисляем стоимость (ошибку) между правильным значением 'y' и
// 'prediction' (предсказанием), сделанным нейрончиком
function predictionCost(y, prediction) {
  // Это просто разница между двумя значениями.
  // Чем ближе значения друг к другу, тем меньше разница.
  // Мы используем здесь степень 2 только для того, чтобы избавиться от отрицательных чисел,
  // поэтому (1 - 2) ^ 2 = (2 - 1) ^ 2.
  // Результат делится на 2 просто для упрощения дальнейшей формулы обратного распространения (см. ниже)
  return (y - prediction) ** 2 / 2 // например -&gt; 235.6
}

// Прямое распространение.
// Эта функция берет все примеры из тренировочных наборов xTrain и yTrain
// и вычисляет предсказания модели для каждого примера из xTrain.
// По пути она также вычисляет среднюю стоимость предсказаний
function forwardPropagation(model, xTrain, yTrain) {
  const m = xTrain.length
  const predictions = []
  let cost = 0
  for (let i = 0; i &lt; m; i += 1) {
    const prediction = model.predict(xTrain[i])
    cost += predictionCost(yTrain[i], prediction)
    predictions.push(prediction)
  }
  // Нас интересует средняя стоимость
  cost /= m
  return [predictions, cost]
}

// Обратное распространение.
// В этом месте машинное обучение выглядит как магия.
// Ключевой концепцией здесь является производная (derivative), которая показывает, какой шаг нужно предпринять, чтобы
// приблизиться к минимуму функции стоимости. Помните, нахождение минимальной функции стоимости -
// конечная цель процесса обучения. Функция стоимости выглядит следующим образом:
// (y - prediction) ^ 2 * 1/2, где prediction = x * w + b.
function backwardPropagation(predictions, xTrain, yTrain) {
  const m = xTrain.length
  // В начале мы не знаем, как менять параметры 'w' и 'b'.
  // Поэтому устанавливаем шаг изменения для каждого параметра в значение 0
  let dW = 0
  let dB = 0
  for (let i = 0; i &lt; m; i += 1) {
    // Это производная функции стоимости параметра 'w'.
    // Она показывает, в каком направлении (положительный/отрицательный знак 'dW') и
    // на сколько (абсолютное значение 'dW') параметр 'w' должен быть изменен
    dW += (yTrain[i] - predictions[i]) * xTrain[i]
    // Это производная функции стоимости параметра 'b'.
    // Она показывает, в каком направлении (знак 'dB') и
    // на сколько (абсолютное значение 'dB') параметр 'b' должен быть изменен
    dB += yTrain[i] - predictions[i]
  }
  // Нас интересуют средняя дельта каждого параметра
  dW /= m
  dB /= m
  return [dW, dB]
}

// Обучает модель.
// Это "учитель" нашего нейрончика:
// - он проводит некоторое время (epochs) с нашим глупым нейрончиком и пытается его чему-то научить,
// - он использует специальные "книги" (наборы данных xTrain и yTrain) для обучения,
// - он заставляет ребенка учиться усерднее (быстрее) с помощью параметра оценки обучения 'alpha'
// (чем сильнее стимул, тем быстрее модель учится, но если учитель будет давить слишком сильно
// у "ребенка" может случиться нервный срыв, и больше он не сможет учиться)
function trainModel(model, epochs, alpha, xTrain, yTrain) {
  // История обучения модели.
  // Она может содержать хорошие или плохие "оценки" (стоимость),
  // полученные в процессе обучения
  const costHistory = []

  // Перебираем эпохи
  for (let i = 0; i &lt; epochs; i += 1) {
    // Прямое распространение для всех тренировочных примеров.
    // Сохраняем стоимость текущей итерации.
    // Это поможет анализировать обучение модели
    const [predictions, cost] = forwardPropagation(model, xTrain, yTrain)
    costHistory.push(cost)

    // Обратное распространение. Учимся на ошибках.
    // Эта функция возвращает небольшие модификации, которые нужно применить к параметрам 'w' и 'b',
    // чтобы сделать предсказания более точными
    const [dW, dB] = backwardPropagation(predictions, xTrain, yTrain)

    // Модифицируем параметры нейрончика для повышения точности его предсказаний
    nanoNeuron.w += alpha * dW
    nanoNeuron.b += alpha * dB
  }

  // Возвращаем историю обучения для анализа и визуализации
  return costHistory
}

// ===
// Создаем экземпляр модели.
// В данный момент нейрончику неизвестны значения параметров 'w' и 'b'.
// Устанавливаем их произвольно
const w = Math.random() // например -&gt; 0.9492
const b = Math.random() // например -&gt; 0.4570
const nanoNeuron = new NanoNeuron(w, b)

// Генерируем тренировочные и тестовые наборы данных
const [xTrain, yTrain, xTest, yTest] = generateDataSets()

// Обучаем модель небольшими шагами (0.0005) в течение 70000 эпох.
// Можете попробовать другие значения, они определены эмпирическим путем
const epochs = 70000
const alpha = 0.0005
const trainingCostHistory = trainModel(
  nanoNeuron,
  epochs,
  alpha,
  xTrain,
  yTrain,
)

// Проверим, как менялась стоимость в процессе обучения.
// Мы ожидаем, что стоимость после обучения будет значительно ниже, чем до него.
// Это будет означать, что наш нейрончик стал умнее. Но возможно и обратное
console.log('Стоимость до обучения:', trainingCostHistory[0]) // например -&gt; 4694.3335043
console.log('Стоимость после обучения:', trainingCostHistory[epochs - 1]) // например -&gt; 0.0000024

// Взглянем на параметры нейрончика, чтобы увидеть, чему он научился.
// Мы ожидаем, что значения параметров 'w' и 'b' модели будут близки к истинным значениям,
// которые используются в функции celsiusToFahrenheit() (w = 1.8 и b = 32)
console.log(
  'Параметры нейрончика:',
  JSON.stringify({ w: nanoNeuron.w, b: nanoNeuron.b }, null, 2),
) // например -&gt; { w: 1.8, b: 31.99 }

// Оцениваем точность модели на тестовых данных, чтобы увидеть, насколько хорошо она обрабатывает неизвестные данные.
// Мы ожидаем, что стоимость тестовых предсказаний будет близкой к стоимости тренировочных предсказаний.
// Это будет означать, что нейрончик хорошо справляется как с тренировочными, так и с тестовыми данными
const [testPredictions, testCost] = forwardPropagation(nanoNeuron, xTest, yTest)
console.log('Стоимость тестовых предсказаний:', testCost) // например -&gt; 0.0000023

// После того, как "ребенок" хорошо показал себя в "школе" в процессе обучения и хорошо справился с тестовыми данными,
// мы можем назвать его "умным" и задать ему парочку вопросов
const tempInCelsius = 70
const customPrediction = nanoNeuron.predict(tempInCelsius)
console.log(
  `Нейрончик "думает", что ${tempInCelsius}°C в градусах Фаренгейта:`,
  customPrediction,
) // -&gt; 158.0002
console.log('Правильный ответ:', celsiusToFahrenheit(tempInCelsius)) // -&gt; 158
// Очень близко! Нейрончик хорош, но не идеален, как все люди :)</code></pre>
                       </div>
                      </div>
                      <br>
                      <p><strong>Пропущенные концепции машинного обучения</strong></p>
                      <br>
                      <p>Следующие концепции машинного обучения были пропущены или упрощены.</p>
                      <br>
                      <p><em>Разделение данных</em></p>
                      <br>
                      <p>Обычно, у нас имеется один большой набор данных. Часто он разделяется в пропорции 70/30 для тренировочного/тестового набора (это зависит от количества примеров). Данные должны произвольно перемешиваться перед разделением. Если примеров много (например, миллионы), то пропорция может быть ближе к 90/10 или даже к 95/5.</p>
                      <br>
                      <p><em>Сеть</em></p>
                      <br>
                      <p>Как правило, нейроны не используются по отдельности. Настоящая сила заключается в нейронных сетях. Сеть можно научить гораздо более сложным вещам. Наш нейрончик больше похож на линейную регрессию, чем на нейронную сеть.</p>
                      <br>
                      <p><em>Нормализация</em></p>
                      <br>
                      <p>Перед обучением входные данные лучше <a href="https://www.jeremyjordan.me/batch-normalization/">нормализовать</a>.</p>
                      <br>
                      <p><em>Векторная реализация</em></p>
                      <br>
                      <p>Для сетей векторные (матричные) вычисления работают намного быстрее, чем циклы <code>for</code>.</p>
                      <br>
                      <p><em>Минимум функции стоимости</em></p>
                      <br>
                      <p>Используемая нами функция стоимости очень упрощена. Она должна содержать <a href="https://stackoverflow.com/questions/32986123/why-the-cost-function-of-logistic-regression-has-a-logarithmic-expression/32998675">логарифмические компоненты</a>. Обратите внимание, что изменение функции стоимости повлечет изменение ее производных, поэтому в обратном распространении также надо будет использовать другие формулы.</p>
                      <br>
                      <p><em>Функция активации</em></p>
                      <br>
                      <p>Обычно, результат нейрона пропускается через функцию активации, такую как <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%B3%D0%BC%D0%BE%D0%B8%D0%B4%D0%B0">сигмоида</a>, <a href="https://en.wikipedia.org/wiki/Rectifier_(neural_networks)">ReLU</a> или аналоги.</p>
                      <br>
                      <h2 id="-metod-k-blizhayshih-sosedey">❯ Метод k ближайших соседей</h2>
                      <br>
                      <p><strong>Описание</strong></p>
                      <br>
                      <ul>
                       <li><a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_k_%D0%B1%D0%BB%D0%B8%D0%B6%D0%B0%D0%B9%D1%88%D0%B8%D1%85_%D1%81%D0%BE%D1%81%D0%B5%D0%B4%D0%B5%D0%B9">Википедия</a></li>
                       <li><a href="https://www.geeksforgeeks.org/k-nearest-neighbours/">GeekForGeeks</a></li>
                       <li><a href="https://habr.com/ru/articles/801885/">Habr (код на Python)</a></li>
                       <li><a href="https://www.youtube.com/watch?v=wsUqBJ0zXYE">YouTube</a></li>
                      </ul>
                      <br>
                      <p>Метод k ближайших соседей (k-nearest neighbors algorithm, k-NN) — метрический алгоритм для автоматической классификации объектов или регрессии. Он относится к методам машинного обучения с учителем (supervised).</p>
                      <br>
                      <p>В случае использования метода для классификации объект присваивается тому классу, который является наиболее распространённым среди <code>k</code> соседей данного элемента, классы которых уже известны. В случае использования метода для регрессии, объекту присваивается среднее значение по <code>k</code> ближайшим к нему объектам, значения которых уже известны. Мы будем говорить в основном о классификации.</p>
                      <br>
                      <p>Алгоритм может быть применим к выборкам с большим количеством атрибутов (многомерным). Для этого перед применением нужно определить функцию расстояния; классический вариант такой функции — <a href="https://ru.wikipedia.org/wiki/%D0%95%D0%B2%D0%BA%D0%BB%D0%B8%D0%B4%D0%BE%D0%B2%D0%B0_%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D0%BA%D0%B0">евклидова метрика</a>.</p>
                      <br><img src="https://habrastorage.org/r/w1560/webt/i_/4h/ql/i_4hqliq67go16a3922u6nv1b9q.png" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/i_/4h/ql/i_4hqliq67go16a3922u6nv1b9q.png 780w,
       https://habrastorage.org/r/w1560/webt/i_/4h/ql/i_4hqliq67go16a3922u6nv1b9q.png 781w" loading="lazy" decode="async">
                      <br>
                      <p><em>Использование теоремы Пифагора для вычисления евклидова расстояния на плоскости</em><br><br></p>
                      <br>
                      <p><strong>Принцип работы</strong></p>
                      <br>
                      <ul>
                       <li>проверяется валидность данных и меток</li>
                       <li>вычисляется евклидово расстояние между тестовым (целевым) и всеми обучающими образцами</li>
                       <li>расстояния вместе с классами сортируются в возрастающем порядке</li>
                       <li>выбирается <code>k</code> ближайших образцов (соседей), где число <code>k</code> задается заранее (как правило, выбирается нечетное число — 3, 5 и т.д.)</li>
                       <li>итоговым прогнозом среди выбранных <code>k</code> ближайших соседей будет мода в случае классификации и среднее арифметическое в случае регрессии</li>
                       <li>возвращается наиболее похожий класс (для классификации) или среднее значение (для регрессии)</li>
                      </ul>
                      <br>
                      <p>Визуализация k-NN для лучшего понимания:</p>
                      <br><img src="https://habrastorage.org/r/w1560/webt/i_/ow/ws/i_owwskzajk-3eyl7ok2cjl4dwg.png" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/i_/ow/ws/i_owwskzajk-3eyl7ok2cjl4dwg.png 780w,
       https://habrastorage.org/r/w1560/webt/i_/ow/ws/i_owwskzajk-3eyl7ok2cjl4dwg.png 781w" loading="lazy" decode="async">
                      <br>
                      <p><em>Пример классификации методом k-NN: тестовый образец (зеленый круг) должен быть классифицирован как синий квадрат (класс 1) или как красный треугольник (класс 2); если k=3, то он классифицируется как 2-й класс, потому что внутри меньшего круга 2 треугольника и только 1 квадрат; если k=5, то он будет классифицирован как 1-й класс (3 квадрата против 2 треугольников внутри большего круга)</em><br><br></p>
                      <br>
                      <p>Еще одна визуализация:</p>
                      <br><img src="https://habrastorage.org/webt/ar/gt/ai/argtaipkmpfxghwvkauvjqfgl6w.gif" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/webt/ar/gt/ai/argtaipkmpfxghwvkauvjqfgl6w.gif 780w,
       https://habrastorage.org/webt/ar/gt/ai/argtaipkmpfxghwvkauvjqfgl6w.gif 781w" loading="lazy" decode="async">
                      <br>
                      <p><em>Здесь k = 7, поэтому тестовый образец классифицируется как зеленый треугольник</em><br><br></p>
                      <br>
                      <p>И еще одна:</p>
                      <br><img src="https://habrastorage.org/r/w1560/webt/rb/y6/cb/rby6cbeenzlbh8y5mopfhz7aa9m.png" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/rb/y6/cb/rby6cbeenzlbh8y5mopfhz7aa9m.png 780w,
       https://habrastorage.org/r/w1560/webt/rb/y6/cb/rby6cbeenzlbh8y5mopfhz7aa9m.png 781w" loading="lazy" decode="async">
                      <br>
                      <p><em>Звездочкой обозначен целевой образец</em></p>
                      <br><img src="https://habrastorage.org/r/w1560/webt/y5/ni/g9/y5nig9m7j9ss7n2frdfx_6r23ue.png" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/y5/ni/g9/y5nig9m7j9ss7n2frdfx_6r23ue.png 780w,
       https://habrastorage.org/r/w1560/webt/y5/ni/g9/y5nig9m7j9ss7n2frdfx_6r23ue.png 781w" loading="lazy" decode="async">
                      <br>
                      <p><em>k=3</em></p>
                      <br><img src="https://habrastorage.org/r/w1560/webt/kn/nr/ks/knnrksemprmbzb6bhzwynhhq1p0.png" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/kn/nr/ks/knnrksemprmbzb6bhzwynhhq1p0.png 780w,
       https://habrastorage.org/r/w1560/webt/kn/nr/ks/knnrksemprmbzb6bhzwynhhq1p0.png 781w" loading="lazy" decode="async">
                      <br>
                      <p><em>k=10</em></p>
                      <br><img src="https://habrastorage.org/r/w1560/webt/yv/ec/lv/yveclvo5luhp1_raoevkpeixwde.png" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/yv/ec/lv/yveclvo5luhp1_raoevkpeixwde.png 780w,
       https://habrastorage.org/r/w1560/webt/yv/ec/lv/yveclvo5luhp1_raoevkpeixwde.png 781w" loading="lazy" decode="async">
                      <br>
                      <p><em>k=20</em></p>
                      <br>
                      <p>Как видим, во всех трех случаях целевой образец классифицируется как синий круг.</p>
                      <br>
                      <p><strong>Реализация</strong></p>
                      <br>
                      <pre><code class="javascript">// algorithms/machine-learning/k-nn.js
// Функция для вычисления евклидова расстояния
import euclideanDistance from '../math/euclidean-distance'

/** Функция принимает:
 * data   - данные
 * labels - метки
 * target - тестовый/целевой образец
 * k      - количество ближайших соседей
 */
export default function kNN(data, labels, target, k = 3) {
  if (!data || !labels || !target) {
    throw new Error('Отсутствует обязательный параметр')
  }

  // Вычисляем расстояние от `target` до каждой точки `data`.
  // Сохраняем расстояние и метку точки в списке
  const distances = []

  for (let i = 0; i &lt; data.length; i++) {
    distances.push({
      distance: euclideanDistance([data[i]], [target]),
      label: labels[i],
    })
  }

  // Сортируем расстояния по возрастанию (от ближайшего к дальнему).
  // Берем `k` значений
  const kn = distances
    .sort((a, b) =&gt; {
      if (a.distance === b.distance) {
        return 0
      }
      return a.distance &lt; b.distance ? -1 : 1
    })
    .slice(0, k)

  // Считаем количество экземпляров каждого класса
  const _labels = {}
  let topClass = 0
  let topClassCount = 0

  for (let i = 0; i &lt; kn.length; i++) {
    if (kn[i].label in _labels) {
      _labels[kn[i].label] += 1
    } else {
      _labels[kn[i].label] = 1
    }

    if (_labels[kn[i].label] &gt; topClassCount) {
      topClassCount = _labels[kn[i].label]
      topClass = kn[i].label
    }
  }

  // Возвращает класс с наибольшим количеством экземпляров
  return topClass
}</code></pre>
                      <br>
                      <div class="spoiler" role="button" tabindex="0">
                       <b class="spoiler_title">Тесты:</b>
                       <div class="spoiler_text">
                        <pre><code class="javascript">// algorithms/machine-learning/__tests__/k-nn.test.js
import kNN from '../k-nn'

describe('kNN', () =&gt; {
  it('при неправильных данных должно выбрасываться исключение', () =&gt; {
    expect(() =&gt; {
      kNN()
    }).toThrowError('Отсутствует обязательный параметр')
  })

  it('при неправильных метках должно выбрасываться исключение', () =&gt; {
    const noLabels = () =&gt; {
      kNN([[1, 1]])
    }
    expect(noLabels).toThrowError('Отсутствует обязательный параметр')
  })

  it('при отсутствии целевого образца должно выбрасываться исключение #1', () =&gt; {
    const noClassification = () =&gt; {
      kNN([[1, 1]], [1])
    }
    expect(noClassification).toThrowError('Отсутствует обязательный параметр')
  })

  it('при отсутствии целевого образца должно выбрасываться исключение #2', () =&gt; {
    const inconsistent = () =&gt; {
      kNN([[1, 1]], [1], [1])
    }
    expect(inconsistent).toThrowError('Матрицы имеют разную форму')
  })

  it('должен выполнить классификацию целевых образцов', () =&gt; {
    let dataSet
    let labels
    let toClassify
    let expectedClass

    dataSet = [
      [1, 1],
      [2, 2],
    ]
    labels = [1, 2]
    toClassify = [1, 1]
    expectedClass = 1
    expect(kNN(dataSet, labels, toClassify)).toBe(expectedClass)

    dataSet = [
      [1, 1],
      [6, 2],
      [3, 3],
      [4, 5],
      [9, 2],
      [2, 4],
      [8, 7],
    ]
    labels = [1, 2, 1, 2, 1, 2, 1]
    toClassify = [1.25, 1.25]
    expectedClass = 1
    expect(kNN(dataSet, labels, toClassify)).toBe(expectedClass)

    dataSet = [
      [1, 1],
      [6, 2],
      [3, 3],
      [4, 5],
      [9, 2],
      [2, 4],
      [8, 7],
    ]
    labels = [1, 2, 1, 2, 1, 2, 1]
    toClassify = [1.25, 1.25]
    expectedClass = 2
    expect(kNN(dataSet, labels, toClassify, 5)).toBe(expectedClass)
  })

  it('должен выполнить классификацию целевого образца с соседями на одинаковых расстояниях', () =&gt; {
    const dataSet = [
      [0, 0],
      [1, 1],
      [0, 2],
    ]
    const labels = [1, 3, 3]
    const toClassify = [0, 1]
    const expectedClass = 3
    expect(kNN(dataSet, labels, toClassify)).toBe(expectedClass)
  })

  it('должен выполнить классификацию целевого образца с соседями в трехмерном пространстве', () =&gt; {
    const dataSet = [
      [0, 0, 0],
      [0, 1, 1],
      [0, 0, 2],
    ]
    const labels = [1, 3, 3]
    const toClassify = [0, 0, 1]
    const expectedClass = 3
    expect(kNN(dataSet, labels, toClassify)).toBe(expectedClass)
  })
})</code></pre>
                       </div>
                      </div>
                      <br>
                      <p>Запускаем тесты:</p>
                      <br>
                      <pre><code class="bash">npm run test ./algorithms/machine-learning/__tests__/k-nn</code></pre>
                      <br><img src="https://habrastorage.org/r/w1560/webt/zy/4m/is/zy4misoszeia7nn7y1whwvv0h-a.png" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/zy/4m/is/zy4misoszeia7nn7y1whwvv0h-a.png 780w,
       https://habrastorage.org/r/w1560/webt/zy/4m/is/zy4misoszeia7nn7y1whwvv0h-a.png 781w" loading="lazy" decode="async">
                      <br>
                      <p><br></p>
                      <br>
                      <h2 id="-metod-k-srednih">❯ Метод k-средних</h2>
                      <br>
                      <p><strong>Описание</strong></p>
                      <br>
                      <ul>
                       <li><a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_k-%D1%81%D1%80%D0%B5%D0%B4%D0%BD%D0%B8%D1%85">Википедия</a></li>
                       <li><a href="https://www.geeksforgeeks.org/k-means-clustering-introduction/">GeekForGeeks</a></li>
                       <li><a href="https://education.yandex.ru/handbook/ml/article/klasterizaciya">Яндекс.Образование — Кластеризация</a></li>
                       <li><a href="https://www.youtube.com/watch?v=8vCuR1AndH0">YouTube</a></li>
                      </ul>
                      <br>
                      <p>Метод k-средних (k-means) — наиболее популярный метод кластеризации. Он относится к методам машинного обучения без учителя (unsupervised).</p>
                      <br>
                      <p>Действие алгоритма таково, что он стремится минимизировать суммарное квадратичное отклонение точек кластеров от центров этих кластеров:</p>
                      <br><img src="https://habrastorage.org/r/w1560/webt/nr/c9/zb/nrc9zbxcz_p_01b2by8llzashbi.png" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/nr/c9/zb/nrc9zbxcz_p_01b2by8llzashbi.png 780w,
       https://habrastorage.org/r/w1560/webt/nr/c9/zb/nrc9zbxcz_p_01b2by8llzashbi.png 781w" loading="lazy" decode="async">
                      <br>
                      <p><br></p>
                      <br>
                      <p>где <code>k</code> — число кластеров, S<sup>i</sup> — полученные кластеры, <code>i = 1, 2, ..., k</code>, а μ<sup>i</sup> — центры масс (центроиды) всех векторов <code>x</code> из кластера S<sup>i</sup>.</p>
                      <br>
                      <p><strong>Принцип работы</strong></p>
                      <br>
                      <p>Алгоритм разбивает множество элементов векторного пространства на заранее известное число кластеров <code>k</code>.</p>
                      <br>
                      <p>Основная идея заключается в том, что на каждой итерации перевычисляется центр масс для каждого кластера, полученного на предыдущем шаге, затем векторы разбиваются на кластеры вновь в соответствии с тем, какой из новых центров оказался ближе по выбранной метрике. Для вычисления схожести между центром масс и векторами данных часто используется <a href="https://ru.wikipedia.org/wiki/%D0%95%D0%B2%D0%BA%D0%BB%D0%B8%D0%B4%D0%BE%D0%B2%D0%B0_%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D0%BA%D0%B0">евклидова метрика</a>.</p>
                      <br><img src="https://habrastorage.org/r/w1560/webt/i_/4h/ql/i_4hqliq67go16a3922u6nv1b9q.png" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/i_/4h/ql/i_4hqliq67go16a3922u6nv1b9q.png 780w,
       https://habrastorage.org/r/w1560/webt/i_/4h/ql/i_4hqliq67go16a3922u6nv1b9q.png 781w" loading="lazy" decode="async">
                      <br>
                      <p><em>Использование теоремы Пифагора для вычисления евклидова расстояния на плоскости</em><br><br></p>
                      <br>
                      <p>Алгоритм завершается, когда на какой-то итерации не происходит изменения внутрикластерного расстояния. Это происходит за конечное число итераций, так как количество возможных разбиений конечного множества конечно, а на каждом шаге суммарное квадратичное отклонение <code>V</code> уменьшается, поэтому зацикливание невозможно.</p>
                      <br><img src="https://habrastorage.org/r/w1560/webt/u8/r_/je/u8r_je1xoj61zsekympel9fvy8c.png" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/u8/r_/je/u8r_je1xoj61zsekympel9fvy8c.png 780w,
       https://habrastorage.org/r/w1560/webt/u8/r_/je/u8r_je1xoj61zsekympel9fvy8c.png 781w" loading="lazy" decode="async">
                      <br>
                      <p><em>Действие алгоритма в двумерном случае. Начальные точки выбраны случайно</em><br><br></p>
                      <br>
                      <p>Последовательность шагов:</p>
                      <br>
                      <ul>
                       <li>проверяется валидность/согласованность данных</li>
                       <li>инициализируется <code>k</code> центроидов с начальными/произвольными <code>k</code> точками</li>
                       <li>вычисляется расстояние каждой точки до каждого центроида</li>
                       <li>каждой точке присваивается значение метки ближайшего кластера</li>
                       <li>вычисляется центроид каждого кластера на основе содержащихся в нем точек</li>
                       <li>цикл повторяется до тех пор, пока положение центроидов не перестанет меняться</li>
                      </ul>
                      <br>
                      <p>Визуализация для лучшего понимания:</p>
                      <br><img src="https://habrastorage.org/webt/gd/-u/7b/gd-u7b4un33ikvsst7yfd2klyfi.gif" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/webt/gd/-u/7b/gd-u7b4un33ikvsst7yfd2klyfi.gif 780w,
       https://habrastorage.org/webt/gd/-u/7b/gd-u7b4un33ikvsst7yfd2klyfi.gif 781w" loading="lazy" decode="async">
                      <br>
                      <p><br></p>
                      <br>
                      <p><strong>Проблемы k-средних</strong></p>
                      <br>
                      <ul>
                       <li>не гарантируется достижение глобального минимума суммарного квадратичного отклонения <code>V</code>, а только одного из локальных минимумов</li>
                      </ul>
                      <br><img src="https://habrastorage.org/r/w1560/webt/nj/o8/og/njo8og0hl035vwkod3l0tjiskk0.png" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/nj/o8/og/njo8og0hl035vwkod3l0tjiskk0.png 780w,
       https://habrastorage.org/r/w1560/webt/nj/o8/og/njo8og0hl035vwkod3l0tjiskk0.png 781w" loading="lazy" decode="async">
                      <br>
                      <p><em>Типичный пример сходимости метода k-средних к локальному минимуму. В этом примере результат кластеризации указанным методом противоречит очевидной кластерной структуре множества данных. Маленькими кружками обозначены точки данных, четырехлучевые звезды — центроиды. Принадлежащие им точки данных окрашены в тот же цвет</em><br><br></p>
                      <br>
                      <ul>
                       <li>результат зависит от выбора исходных центров кластеров, их оптимальный выбор неизвестен</li>
                      </ul>
                      <br><img src="https://habrastorage.org/r/w1560/webt/2w/k8/mb/2wk8mbjs5v5ywihp4ddm1boqsig.png" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/2w/k8/mb/2wk8mbjs5v5ywihp4ddm1boqsig.png 780w,
       https://habrastorage.org/r/w1560/webt/2w/k8/mb/2wk8mbjs5v5ywihp4ddm1boqsig.png 781w" loading="lazy" decode="async">
                      <br>
                      <p><em>Результат кластеризации методом k-средних для ирисов Фишера и реальные виды ирисов, визуализированные с помощью ELKI. Центры кластеров отмечены с помощью крупных, полупрозрачных маркеров</em><br><br></p>
                      <br>
                      <ul>
                       <li>число кластеров надо знать заранее</li>
                      </ul>
                      <br>
                      <p><strong>Применение</strong></p>
                      <br>
                      <p>В алгоритмах глубокого обучения метод k-средних иногда применяют не по прямому назначению (классификация разбивкой на кластеры), а для создания так называемых фильтров (ядер свертки, словарей). Например, для распознавания изображений в алгоритм k-средних подают небольшие случайные кусочки изображений обучающей выборки, допустим, размером <code>16х16</code> в виде линейного вектора, каждый элемент которого кодирует яркость своей точки. Количество кластеров <code>k</code> задается большим, например <code>256</code>. Обученный метод k-средних при определенных условиях вырабатывает при этом центры кластеров (центроиды), которые представляют собой удобные базисы, на которые можно разложить любое входное изображение. Такие "обученные" центроиды в дальнейшем используют в качестве фильтров, например для сверточной нейронной сети в качестве ядер свертки или других аналогичных систем машинного зрения.</p>
                      <br>
                      <p><strong>Реализация</strong></p>
                      <br>
                      <pre><code class="javascript">// algorithms/machine-learning/k-means.js
// Утилиты для матричных вычислений
import * as matrix from '../math/matrix'
// Функция для вычисления евклидова расстояния
import euclideanDistance from '../math/euclidean-distance'

/** Функция принимает:
 * data - данные
 * k    - количество кластеров
 */
export default function kMeans(data, k = 1) {
  if (!data) {
    throw new Error('Отсутствуют данные для классификации')
  }

  // Количество измерений
  const dimension = data[0].length
  // Центроиды
  const centroids = data.slice(0, k)

  // Матрица расстояний от каждой точки до каждого центроида
  const distances = matrix.zeros([data.length, k])

  // Классы векторных точек данных.
  // - 1 означает, что класс еще не назначен
  const classes = new Array(data.length).fill(-1)

  // Индикатор итерации
  let iterate = true
  while (iterate) {
    iterate = false

    // Вычисляем и сохраняем расстояние каждой точки от каждого центроида
    for (let i = 0; i &lt; data.length; i++) {
      for (let j = 0; j &lt; k; j++) {
        distances[i][j] = euclideanDistance([centroids[j]], [data[i]])
      }

      // Присваиваем метку ближайшего кластера каждой точке
      const closestClusterIndex = distances[i].indexOf(
        Math.min(...distances[i]),
      )

      // Проверяем, был ли класс точки изменен
      // и нужно ли повторить итерацию
      if (classes[i] !== closestClusterIndex) {
        iterate = true
      }

      classes[i] = closestClusterIndex
    }

    // Пересчитываем положение центроида кластера
    // на основе содержащихся в нем точек
    for (let i = 0; i &lt; k; i++) {
      // Сбрасываем координаты центроида, поскольку нам нужно их пересчитать
      centroids[i] = new Array(dimension).fill(0)
      let clusterSize = 0
      for (let j = 0; j &lt; data.length; j++) {
        if (classes[j] === i) {
          // Регистрируем еще одну точку текущего кластера
          clusterSize += 1
          for (let l = 0; l &lt; dimension; l++) {
            centroids[i][l] += data[j][l]
          }
        }
      }

      // Вычисляем среднее значение каждой координаты центроида
      for (let j = 0; j &lt; dimension; j++) {
        centroids[i][j] = parseFloat(
          Number(centroids[i][j] / clusterSize).toFixed(2),
        )
      }
    }
  }

  return classes
}</code></pre>
                      <br>
                      <div class="spoiler" role="button" tabindex="0">
                       <b class="spoiler_title">Тесты:</b>
                       <div class="spoiler_text">
                        <pre><code class="javascript">// algorithms/machine-learning/__tests__/k-means.test.js
import KMeans from '../k-means'

describe('kMeans', () =&gt; {
  it('при невалидных данных должно выбрасываться исключение', () =&gt; {
    expect(() =&gt; {
      KMeans()
    }).toThrowError('Отсутствуют данные для классификации')
  })

  it('при несогласованных данных должно выбрасываться исключение', () =&gt; {
    expect(() =&gt; {
      KMeans([[1, 2], [1]], 2)
    }).toThrowError('Матрицы имеют разную форму')
  })

  it('должен выполнить кластеризацию', () =&gt; {
    const data = [
      [1, 1],
      [6, 2],
      [3, 3],
      [4, 5],
      [9, 2],
      [2, 4],
      [8, 7],
    ]
    const k = 2
    const expectedClusters = [0, 1, 0, 1, 1, 0, 1]
    expect(KMeans(data, k)).toEqual(expectedClusters)

    expect(
      KMeans(
        [
          [0, 0],
          [0, 1],
          [10, 10],
        ],
        2,
      ),
    ).toEqual([0, 0, 1])
  })

  it('должен выполнить кластеризацию точек на одинаковых расстояниях', () =&gt; {
    const dataSet = [
      [0, 0],
      [1, 1],
      [2, 2],
    ]
    const k = 3
    const expectedCluster = [0, 1, 2]
    expect(KMeans(dataSet, k)).toEqual(expectedCluster)
  })

  it('должен выполнить кластеризацию точек в трехмерном пространстве', () =&gt; {
    const dataSet = [
      [0, 0, 0],
      [0, 1, 0],
      [2, 0, 2],
    ]
    const k = 2
    const expectedCluster = [1, 1, 0]
    expect(KMeans(dataSet, k)).toEqual(expectedCluster)
  })
})</code></pre>
                       </div>
                      </div>
                      <br>
                      <p>Запускаем тесты:</p>
                      <br>
                      <pre><code class="bash">npm run test ./algorithms/machine-learning/__tests__/k-means</code></pre>
                      <br><img src="https://habrastorage.org/r/w1560/webt/4z/m6/qc/4zm6qcwanifvkkij-ftmlkuzpgk.png" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/4z/m6/qc/4zm6qcwanifvkkij-ftmlkuzpgk.png 780w,
       https://habrastorage.org/r/w1560/webt/4z/m6/qc/4zm6qcwanifvkkij-ftmlkuzpgk.png 781w" loading="lazy" decode="async">
                      <br>
                      <p><br></p>
                      <br>
                      <h1 id="-statistika">❯ Статистика</h1>
                      <br>
                      <h2 id="-vzveshennaya-proizvolnaya-vyborka">❯ Взвешенная произвольная выборка</h2>
                      <br><img src="https://habrastorage.org/r/w1560/webt/e9/94/i2/e994i2o7uknxvrwxlxocf8amr9k.png" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/e9/94/i2/e994i2o7uknxvrwxlxocf8amr9k.png 780w,
       https://habrastorage.org/r/w1560/webt/e9/94/i2/e994i2o7uknxvrwxlxocf8amr9k.png 781w" loading="lazy" decode="async">
                      <br>
                      <p><br></p>
                      <br>
                      <p><strong>Описание</strong></p>
                      <br>
                      <ul>
                       <li><a href="https://ru.statisticseasily.com/glossario/what-is-weighted-random-sampling/">Что такое взвешенная случайная выборка?</a></li>
                      </ul>
                      <br>
                      <p>Допустим, у нас есть список элементов. Элемент может быть чем угодно. Например, у нас может быть список фруктов и овощей, которые мы любим кушать: <code>[ '🍌', '🍎', '🥕' ]</code>.</p>
                      <br>
                      <p>Список весов представляет вес (вероятность выбора, важность) каждого элемента. Веса — это числа. Например, веса <code>[3, 7, 1]</code> означают следующее:</p>
                      <br>
                      <ul>
                       <li>мы выбираем яблоко чаще всего (<code>7</code> из <code>3+7+1=11</code> раз)</li>
                       <li>банан мы выбираем менее часто (<code>3</code> из <code>11</code> раз)</li>
                       <li>морковку мы не любим, поэтому выбираем ее редко (<code>1</code> из <code>11</code> раз)</li>
                      </ul>
                      <br>
                      <blockquote>
                       Если говорить в терминах вероятности, то веса должны быть представлены числами с плавающей запятой, сумма которых дает <code>1</code> (например, <code>[0.1, 0.5, 0.2, 0.2]</code>).
                      </blockquote>
                      <p>Взвешенная произвольная выборка (weighted random) — это функция, которая возвращает произвольный элемент списка с учетом его веса, поэтому элементы с большим весом выбирается чаще.</p>
                      <br>
                      <p>Пример интерфейса функции:</p>
                      <br>
                      <pre><code class="javascript">const items =   [ '🍌', '🍎', '🥕' ];
const weights = [  3,    7,    1  ];

function weightedRandom(items, weights) {
  // Реализация...
}

const nextSnackToEat = weightedRandom(items, weights); // вероятнее всего будет '🍎'</code></pre>
                      <br>
                      <p><strong>Применение</strong></p>
                      <br>
                      <ul>
                       <li>в <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%B5%D0%BD%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC">генетической алгоритме</a> взвешенная произвольная выборка используется на стадии выборки, когда нам нужно выбрать наиболее приспособленных/сильных особей на основе оценки их приспособленности для спаривания и создания следующего более сильного поколения. См. <a href="https://habr.com/ru/users/aio350/articles/page2/">Самопаркующийся авто за 500 строк кода</a></li>
                       <li>в <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%BA%D1%83%D1%80%D1%80%D0%B5%D0%BD%D1%82%D0%BD%D0%B0%D1%8F_%D0%BD%D0%B5%D0%B9%D1%80%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B5%D1%82%D1%8C">рекуррентных нейронных сетях (RNN)</a> при принятии решения о выборе следующей буквы (для формирования предложения) на основе вероятности следующей буквы. См. Jupyter Notebook <a href="https://nbviewer.org/github/trekhleb/machine-learning-experiments/blob/master/experiments/recipe_generation_rnn/recipe_generation_rnn.ipynb">Recipe Generation using Recurrent Neural Network (RNN)</a></li>
                       <li>в <a href="https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/">балансировщике нагрузки Nginx</a> для более частой отправки запросов на сервер с более высоким весом</li>
                       <li>во многих других областях</li>
                      </ul>
                      <br>
                      <p><strong>Алгоритм</strong></p>
                      <br>
                      <p>Самый простой подход состоит в следующем:</p>
                      <br>
                      <ol>
                       <li>Дублируем каждый элемент в соответствии с его весом.</li>
                       <li>Выбираем произвольный элемент.</li>
                      </ol>
                      <br>
                      <p>Например, для наших фруктов и овощей можно сгенерировать следующий список:</p>
                      <br>
                      <pre><code class="javascript">const items =   [ '🍌', '🍎', '🥕' ];
const weights = [  3,    7,    1  ];

// Дублируем элементы на основе их весов
const weightedItems = [
  '🍌', '🍌', '🍌',
  '🍎', '🍎', '🍎', '🍎', '🍎', '🍎', '🍎',
  '🥕',
];

// Теперь просто извлекаем произвольный элемент из `weightedItems`</code></pre>
                      <br>
                      <p>Однако, как вы можете видеть, такой подход требует большого количества памяти в случае, когда у нас много элементов для повторения. Например, повторение строки <code>"some-random-string"</code> 10 млн раз потребует выделения около <code>180 Мб</code> памяти только для массива <code>weightedItems</code>.</p>
                      <br>
                      <p>Более эффективный подход состоит в следующем:</p>
                      <br>
                      <ol>
                       <li>Готовим список совокупных весов для каждого элемента (список <code>cumulativeWeights</code> будет иметь такую же длину, как исходный список <code>weights</code>). В нашем случае он будет выглядеть так: <code>cumulativeWeights = [3, 3 + 7, 3 + 7 + 1] = [3, 10, 11]</code>.</li>
                       <li>Выбираем произвольное число в диапазоне от <code>0</code> до наибольшего совокупного веса. В нашем случае таким диапазоном будет <code>[0...11]</code>. Допустим, мы получили <code>randomNumber = 8</code>.</li>
                       <li>Перебираем <code>cumulativeWeights</code> слева направо и берем первый элемент, который больше или равен <code>randomNumber</code>. Индекс такого элемента используется для выбора элемента из списка <code>items</code>.</li>
                      </ol>
                      <br>
                      <p>Основная идея данного подхода состоит в том, что более высокие веса будут "занимать" больше числового пространства. Таким образом, более высока вероятность выбора произвольного числа из "числовой группы более высокого веса".</p>
                      <br>
                      <pre><code class="javascript">const weights =           [3, 7,  1 ];
const cumulativeWeights = [3, 10, 11];

// `cumulativeWeights` можно представить так
const pseudoCumulativeWeights = [
  1, 2, 3,               // &lt;-- 3 числа
  4, 5, 6, 7, 8, 9, 10,  // &lt;-- 7 чисел
  11,                    // &lt;-- 1 число
];</code></pre>
                      <br>
                      <p><strong>Реализация</strong></p>
                      <br>
                      <pre><code class="javascript">// algorithms/statistics/weighted-random.js
/**
 * Возвращает произвольный элемент на основе его веса.
 * Элементы с более высоким весом выбираются чаще (с большей вероятностью).
 *
 * Например:
 * - items = ['banana', 'orange', 'apple']
 * - weights = [0, 0.2, 0.8]
 * - weightedRandom(items, weights) в 80% случаев будет возвращать 'apple',
 * в 20% случаев - 'orange' и никогда - 'banana' (поскольку вероятность его выбора равна 0%)
 *
 * @param {any[]} items
 * @param {number[]} weights
 * @returns {{item: any, index: number}}
 */
export default function weightedRandom(items, weights) {
  if (!items.length || !weights.length) {
    throw new Error('Элементы/веса не должны быть пустыми')
  }
  if (items.length !== weights.length) {
    throw new Error('Массивы элементов и весов должны иметь одинаковую длину')
  }

  // Готовим массив совокупных весов.
  // Например:
  // - weights = [1, 4, 3]
  // - cumulativeWeights = [1, 5, 8]
  const cumulativeWeights = []
  for (let i = 0; i &lt; weights.length; i++) {
    cumulativeWeights[i] = weights[i] + (cumulativeWeights[i - 1] || 0)
  }

  // Получаем произвольное число в диапазоне [0...sum(weights)].
  // Например:
  // - weights = [1, 4, 3]
  // - maxCumulativeWeight = 8
  // - диапазон произвольного числа - [0...8]
  const maxCumulativeWeight = cumulativeWeights.at(-1)
  const random = Math.random() * maxCumulativeWeight

  // Извлекаем произвольный элемент на основе его веса.
  // Элементы с более высоким весом выбираются чаще
  const index = cumulativeWeights.findIndex((cumulativeWeight) =&gt; {
    return cumulativeWeight &gt;= random
  })
  const item = items[index]

  return {
    item,
    index,
  }
}</code></pre>
                      <br>
                      <div class="spoiler" role="button" tabindex="0">
                       <b class="spoiler_title">Тесты:</b>
                       <div class="spoiler_text">
                        <pre><code class="javascript">import weightedRandom from '../weighted-random'

describe('weightedRandom', () =&gt; {
  it('при передаче пустого массива элементов или весов должно выбрасываться исключение', () =&gt; {
    const getWeightedRandomWithInvalidInputs = () =&gt; {
      weightedRandom([], [])
    }
    expect(getWeightedRandomWithInvalidInputs).toThrow(
      'Элементы/веса не должны быть пустыми',
    )
  })

  it('при несовпадении количества элементов и весов должно выбрасываться исключение', () =&gt; {
    const getWeightedRandomWithInvalidInputs = () =&gt; {
      weightedRandom(['a', 'b', 'c'], [10, 0])
    }
    expect(getWeightedRandomWithInvalidInputs).toThrow(
      'Массивы элементов и весов должны иметь одинаковую длину',
    )
  })

  it('должен правильно выполнять взвешенную произвольную выборку в простых случаях', () =&gt; {
    expect(weightedRandom(['a', 'b', 'c'], [1, 0, 0])).toEqual({
      index: 0,
      item: 'a',
    })
    expect(weightedRandom(['a', 'b', 'c'], [0, 1, 0])).toEqual({
      index: 1,
      item: 'b',
    })
    expect(weightedRandom(['a', 'b', 'c'], [0, 0, 1])).toEqual({
      index: 2,
      item: 'c',
    })
    expect(weightedRandom(['a', 'b', 'c'], [0, 1, 1])).not.toEqual({
      index: 0,
      item: 'a',
    })
    expect(weightedRandom(['a', 'b', 'c'], [1, 0, 1])).not.toEqual({
      index: 1,
      item: 'b',
    })
    expect(weightedRandom(['a', 'b', 'c'], [1, 1, 0])).not.toEqual({
      index: 2,
      item: 'c',
    })
  })

  it('должен правильно выполнять взвешенную произвольную выборку', () =&gt; {
    // Количество выборок
    const ATTEMPTS_NUM = 1000
    // Погрешность количества выборок элемента.
    // Например, если мы хотим, чтобы элемент 'a' выбирался 300 раз из 1000 (30%),
    // тогда 267 раз является приемлемым, поскольку это больше 250 (300 - 50)
    // и меньше 350 (300 + 50)
    const THRESHOLD = 50

    const items = ['a', 'b', 'c'] // значения элементов неважны
    const weights = [0.1, 0.3, 0.6]

    const counter = []
    for (let i = 0; i &lt; ATTEMPTS_NUM; i += 1) {
      const randomItem = weightedRandom(items, weights)
      if (!counter[randomItem.index]) {
        counter[randomItem.index] = 1
      } else {
        counter[randomItem.index] += 1
      }
    }

    for (let itemIndex = 0; itemIndex &lt; items.length; itemIndex += 1) {
      /*
        Элемент под индексом 0 должен выбираться 100 раз (в идеале)
        или, учитывая порог, [100 - 50, 100 + 50] раз.

        Элемент под индексом 1 должен выбираться 300 раз (в идеале)
        или, учитывая порог, [300 - 50, 300 + 50] раз.

        Элемент под индексом 2 должен выбираться 600 раз (в идеале)
        или, учитывая порог, [600 - 50, 600 + 50] раз
       */
      expect(counter[itemIndex]).toBeGreaterThan(
        ATTEMPTS_NUM * weights[itemIndex] - THRESHOLD,
      )
      expect(counter[itemIndex]).toBeLessThan(
        ATTEMPTS_NUM * weights[itemIndex] + THRESHOLD,
      )
    }
  })
})</code></pre>
                       </div>
                      </div>
                      <br>
                      <p>Запускаем тесты:</p>
                      <br>
                      <pre><code class="bash">npm run test ./algorithms/statistics</code></pre>
                      <br><img src="https://habrastorage.org/r/w1560/webt/b4/vf/m-/b4vfm-aglfggwqjagfsl9g-uqsq.png" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/b4/vf/m-/b4vfm-aglfggwqjagfsl9g-uqsq.png 780w,
       https://habrastorage.org/r/w1560/webt/b4/vf/m-/b4vfm-aglfggwqjagfsl9g-uqsq.png 781w" loading="lazy" decode="async">
                      <br>
                      <p><br></p>
                      <br>
                      <p>На сегодня это все, друзья. Увидимся в следующей части.</p>
                      <br>
                      <hr>
                      <br>
                      <blockquote>
                       <a href="https://t.me/timewebru"><b>Новости, обзоры продуктов и конкурсы от команды Timeweb.Cloud — в нашем Telegram-канале</b></a> <b>↩</b>
                      </blockquote>
                      <p><a href="https://timeweb.cloud/?utm_source=habr&amp;utm_medium=banner&amp;utm_campaign=promo"><img src="https://habrastorage.org/r/w1560/webt/6r/9j/sr/6r9jsrljpzsgcfyj1jjupubij5e.png" sizes="(max-width: 780px) 100vw, 50vw" srcset="https://habrastorage.org/r/w780/webt/6r/9j/sr/6r9jsrljpzsgcfyj1jjupubij5e.png 780w,
       https://habrastorage.org/r/w1560/webt/6r/9j/sr/6r9jsrljpzsgcfyj1jjupubij5e.png 781w" loading="lazy" decode="async"></a></p>
                     </div>
                    </div>
                   </div><!----><!---->
                  </div><!----><!---->
                 </div><!--]--><!---->
                 <div class="tm-article-presenter__meta" data-test-id="article-meta-links">
                  <div class="tm-separated-list tm-article-presenter__meta-list">
                   <span class="tm-separated-list__title">Теги:</span>
                   <ul class="tm-separated-list__list">
                    <!--[-->
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[timeweb_%D1%81%D1%82%D0%B0%D1%82%D1%8C%D0%B8]" class="tm-tags-list__link"><span>timeweb_статьи</span></a><!--]--></li>
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[javascript]" class="tm-tags-list__link"><span>javascript</span></a><!--]--></li>
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[algorithms]" class="tm-tags-list__link"><span>algorithms</span></a><!--]--></li>
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[data+structures]" class="tm-tags-list__link"><span>data structures</span></a><!--]--></li>
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B]" class="tm-tags-list__link"><span>алгоритмы</span></a><!--]--></li>
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B+%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85]" class="tm-tags-list__link"><span>структуры данных</span></a><!--]--></li>
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[machine+learning]" class="tm-tags-list__link"><span>machine learning</span></a><!--]--></li>
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[statistics]" class="tm-tags-list__link"><span>statistics</span></a><!--]--></li>
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[%D0%BC%D0%B0%D1%88%D0%B8%D0%BD%D0%BD%D0%BE%D0%B5+%D0%BE%D0%B1%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5]" class="tm-tags-list__link"><span>машинное обучение</span></a><!--]--></li>
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B0]" class="tm-tags-list__link"><span>статистика</span></a><!--]--></li><!--]--><!---->
                   </ul>
                  </div>
                  <div class="tm-separated-list tm-article-presenter__meta-list">
                   <span class="tm-separated-list__title">Хабы:</span>
                   <ul class="tm-separated-list__list">
                    <!--[-->
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/companies/timeweb/articles/" class="tm-hubs-list__link"><!--[--><span>Блог компании Timeweb Cloud</span><!--]--></a><!--]--></li>
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/hubs/javascript/" class="tm-hubs-list__link"><!--[--><span>JavaScript</span><!--]--></a><!--]--></li>
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/hubs/algorithms/" class="tm-hubs-list__link"><!--[--><span>Алгоритмы</span><!--]--></a><!--]--></li>
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/hubs/machine_learning/" class="tm-hubs-list__link"><!--[--><span>Машинное обучение</span><!--]--></a><!--]--></li>
                    <li class="tm-separated-list__item"><!--[--><a href="/ru/hubs/statistics/" class="tm-hubs-list__link"><!--[--><span>Статистика в IT</span><!--]--></a><!--]--></li><!--]--><!---->
                   </ul>
                  </div>
                 </div><!----><!--]-->
                </article><!--]-->
               </div><!---->
              </div>
              <div style="" class="tm-article-sticky-panel" data-test-id="article-sticky-panel">
               <div class="tm-data-icons tm-data-icons tm-data-icons_space-big tm-article-sticky-panel__icons" data-test-id="article-stats-icons">
                <div class="article-rating tm-data-icons__item" data-v-86aec4a7>
                 <div class="tm-votes-lever tm-votes-lever tm-votes-lever_appearance-article votes-switcher" title="Всего голосов 6: ↑6 и ↓0" data-v-86aec4a7>
                  <button class="tm-votes-lever__button" data-test-id="votes-lever-upvote-button" title="Нравится" type="button">
                   <svg class="tm-svg-img tm-votes-lever__icon" height="24" width="24">
                    <title>
                     Нравится
                    </title><use xlink:href="/img/megazord-v28.7909a852..svg#counter-vote"></use>
                   </svg></button>
                  <div class="tm-votes-lever__score tm-votes-lever__score_appearance-article tm-votes-lever__score">
                   <!--[--><span><span class="tm-votes-lever__score-counter tm-votes-lever__score-counter_positive tm-votes-lever__score-counter" data-test-id="votes-score-counter">+8</span></span><!--]-->
                  </div>
                  <button class="tm-votes-lever__button" data-test-id="votes-lever-downvote-button" title="Не нравится" type="button">
                   <svg class="tm-svg-img tm-votes-lever__icon tm-votes-lever__icon_arrow-down" height="24" width="24">
                    <title>
                     Не нравится
                    </title><use xlink:href="/img/megazord-v28.7909a852..svg#counter-vote"></use>
                   </svg></button>
                 </div><!--teleport start--><!--teleport end--><!---->
                </div><!----><!---->
                <button class="bookmarks-button tm-data-icons__item" title="Добавить в закладки" type="button"><span class="tm-svg-icon__wrapper bookmarks-button__icon">
                  <svg class="tm-svg-img tm-svg-icon" height="24" width="24">
                   <title>
                    Добавить в закладки
                   </title><use xlink:href="/img/megazord-v28.7909a852..svg#counter-favorite"></use>
                  </svg></span><span class="bookmarks-button__counter" title="Количество пользователей, добавивших публикацию в закладки">24</span></button>
                <div class="tm-sharing tm-data-icons__item" title="Поделиться">
                 <button class="tm-sharing__button" type="button">
                  <svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="tm-sharing__icon">
                   <path fill="currentColor" d="M13.8 13.8V18l7.2-6.6L13.8 5v3.9C5 8.9 3 18.6 3 18.6c2.5-4.4 6-4.8 10.8-4.8z"></path>
                  </svg></button><!--teleport start--><!--teleport end-->
                </div>
                <div class="tm-article-comments-counter-link tm-data-icons__item" title="Читать комментарии">
                 <a href="/ru/companies/timeweb/articles/903842/comments/" class="tm-article-comments-counter-link__link" data-test-id="counter-comments"><!--[-->
                  <svg class="tm-svg-img tm-article-comments-counter-link__icon" height="24" width="24">
                   <title>
                    Комментарии
                   </title><use xlink:href="/img/megazord-v28.7909a852..svg#counter-comments"></use>
                  </svg><span class="tm-article-comments-counter-link__value">1</span><!--]--></a><!---->
                </div><!--[--><!--[--><!--[--><!----><!--]--><!--]--><!--]--><!--teleport start--><!--teleport end--><!---->
               </div>
              </div>
             </div><!--[--><!--]-->
             <div class="tm-article-presenter__footer">
              <!--[--><!--[-->
              <div class="tm-article-blocks">
               <!----><!--[-->
               <section class="tm-block tm-block tm-block_spacing-bottom">
                <!----><!--[-->
                <div class="tm-block__body tm-block__body tm-block__body_variant-balanced">
                 <!--[-->
                 <div class="tm-article-author" data-test-id="article-author-info" data-async-called="true">
                  <!--[--><!--[-->
                  <div class="tm-article-author__company">
                   <div class="tm-article-author__company-card">
                    <div class="tm-company-snippet">
                     <a href="/ru/companies/timeweb/profile/" class="tm-company-snippet__logo-link">
                      <div class="tm-entity-image">
                       <img alt="" class="tm-entity-image__pic" height="40" src="//habrastorage.org/getpro/habr/company/7dd/ba1/4f4/7ddba14f4fc46943da7d3bbadc46b55a.png" width="40">
                      </div></a>
                     <div class="tm-company-snippet__info">
                      <a href="/ru/companies/timeweb/profile/" class="tm-company-snippet__title" data-test-id="company-title"><span>Timeweb Cloud</span></a>
                      <div class="tm-company-snippet__description">
                       То самое облако
                      </div>
                     </div>
                    </div>
                    <div class="tm-article-author__buttons">
                     <!----><!---->
                    </div>
                   </div><!---->
                   <div class="tm-article-author__separator"></div>
                  </div><!--]--><!--]-->
                  <div class="tm-user-card tm-user-card tm-user-card_variant-article tm-article-author__user-card" data-async-called="true">
                   <div class="tm-user-card__info-container">
                    <div class="tm-user-card__header">
                     <div class="tm-user-card__header-data">
                      <a href="/ru/users/aio350/" class="tm-user-card__userpic tm-user-card__userpic_size-40">
                       <div class="tm-entity-image">
                        <img alt="" class="tm-entity-image__pic" src="//habrastorage.org/getpro/habr/avatars/4d3/879/a5a/4d3879a5a72249d5267d1f152ac59d40.jpg">
                       </div></a>
                      <div class="tm-user-card__meta">
                       <div class="tm-counter-container karma" title=" 443 голоса " data-v-f7c0e283>
                        <div class="tm-counter-container__header">
                         <!--[-->
                         <div class="karma-display positive" data-v-f7c0e283 data-v-7635202e>
                          305
                         </div><!----><!--]-->
                        </div>
                        <div class="tm-counter-container__footer">
                         <!--[-->
                         <div class="karma-text" data-v-f7c0e283>
                          Карма
                         </div><!--teleport start--><!--teleport end--><!--]-->
                        </div>
                       </div>
                       <div class="tm-counter-container" title="Рейтинг пользователя">
                        <div class="tm-counter-container__header">
                         <!--[--><!--[--><!--]-->
                         <div class="tm-votes-lever tm-votes-lever tm-votes-lever_appearance-rating">
                          <!---->
                          <div class="tm-votes-lever__score tm-votes-lever__score_appearance-rating tm-votes-lever__score">
                           <!--[--><span><span class="tm-votes-lever__score-counter tm-votes-lever__score-counter_rating tm-votes-lever__score-counter" data-test-id="votes-score-counter">34.4</span></span><!--]-->
                          </div><!---->
                         </div><!--]-->
                        </div>
                        <div class="tm-counter-container__footer">
                         <!--[--><span class="tm-rating__text tm-rating__text">Рейтинг</span><!--]-->
                        </div>
                       </div>
                      </div>
                     </div>
                    </div>
                    <div class="tm-user-card__info tm-user-card__info_variant-article tm-user-card__info">
                     <div class="tm-user-card__title tm-user-card__title_variant-article tm-user-card__title">
                      <span class="tm-user-card__name tm-user-card__name_variant-article tm-user-card__name">Igor Agapov</span><a href="/ru/users/aio350/" class="tm-user-card__nickname tm-user-card__nickname tm-user-card__nickname_variant-article"> @aio350</a><!---->
                     </div>
                     <p class="tm-user-card__short-info tm-user-card__short-info_variant-article tm-user-card__short-info" data-test-id="user-card-speciality">JavaScript Developer</p>
                    </div>
                   </div><!---->
                   <div class="tm-user-card__buttons tm-user-card__buttons_variant-article tm-user-card__buttons">
                    <!---->
                    <div class="tm-user-card__button">
                     <div class="tm-button-follow tm-user-card__button-follow">
                      <!---->
                      <button class="tm-button-follow__button tm-button-follow__button_big" data-test-id="follow-button" type="button">Подписаться</button>
                     </div>
                    </div><!---->
                    <div class="tm-user-card__button tm-user-card__button_write" data-test-id="user-card-conversations">
                     <svg class="tm-svg-img tm-user-card__button-icon" height="16" width="16">
                      <title>
                       Отправить сообщение
                      </title><use xlink:href="/img/megazord-v28.7909a852..svg#mail"></use>
                     </svg>
                    </div><!---->
                   </div><!---->
                  </div>
                  <div class="tm-article-author__user-contacts" data-test-id="author-contacts">
                   <!----><!----><!---->
                  </div>
                 </div><!--]-->
                </div><!--]--><!---->
               </section><!----><!--[-->
               <div class="banner-wrapper leaderboard tm-company-article__banner" style="--38f3d936:200px;--78a3cd06:auto;" data-v-f4bf0d24>
                <!--[-->
                <div class="placeholder-wrapper placeholder" data-v-f4bf0d24>
                 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->
                 <div class="adfox-banner-placeholder leaderboard" data-v-12f7bcca>
                  <div class="image loads" data-v-12f7bcca></div>
                  <div class="lines" data-v-12f7bcca>
                   <div class="line loads" data-v-12f7bcca></div>
                   <div class="line loads" data-v-12f7bcca></div>
                   <div class="line loads" data-v-12f7bcca></div>
                  </div>
                 </div><!----><!----><!---->
                </div>
                <div id="adfox_164725660339535756" class="tm-adfox-banner" data-v-f4bf0d24></div><!--]-->
               </div><!----><!--]--><!--]-->
               <div class="tm-article-blocks__comments">
                <div id="publication-comments" class="tm-article-page-comments">
                 <div>
                  <!--[-->
                  <div class="tm-article-comments-counter-link tm-article-comments-counter-button">
                   <a href="/ru/companies/timeweb/articles/903842/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style" data-test-id="counter-comments"><!--[-->
                    <svg class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted" height="24" width="24">
                     <title>
                      Комментарии
                     </title><use xlink:href="/img/megazord-v28.7909a852..svg#counter-comments"></use>
                    </svg><span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted"> Комментарии 1 </span><!--]--></a><!---->
                  </div><!--]-->
                 </div>
                </div>
               </div><!--[--><!--[--><!--]-->
               <section class="tm-block tm-block tm-block_spacing-bottom">
                <header class="tm-block__header tm-block__header tm-block__header_variant-borderless">
                 <div class="tm-block__header-container">
                  <h2 class="tm-block__title tm-block__title tm-block__title_variant-large">Публикации</h2><!--[--><!--]-->
                 </div><!---->
                </header><!--[-->
                <div class="tm-block__body tm-block__body tm-block__body_variant-condensed-slim">
                 <!--[--><!--[-->
                 <div class="tm-tabs tm-tabs">
                  <div class="">
                   <!--[--><span class="tm-tabs__tab-item">
                    <button class="tm-tabs__tab-link tm-tabs__tab-link_active tm-tabs__tab-link_slim tm-tabs__tab-link">Лучшие за сутки</button></span><span class="tm-tabs__tab-item">
                    <button class="tm-tabs__tab-link tm-tabs__tab-link_slim tm-tabs__tab-link">Похожие</button></span><!--]-->
                  </div><!---->
                 </div>
                 <div class="similar-and-daily__tab-view">
                  <div class="placeholder-wrapper">
                   <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->
                   <div class="tm-placeholder-article-cards">
                    <!--[-->
                    <div class="tm-placeholder-article-card">
                     <div class="tm-placeholder__user">
                      <div class="tm-placeholder__user-pic loads"></div>
                      <div class="tm-placeholder__user-date loads"></div>
                     </div>
                     <div class="tm-placeholder-article-card__title">
                      <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div>
                      <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div>
                     </div>
                     <div class="tm-placeholder-article-card__icons tm-placeholder__counters">
                      <!--[-->
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div><!--]-->
                     </div>
                    </div>
                    <div class="tm-placeholder-article-card">
                     <div class="tm-placeholder__user">
                      <div class="tm-placeholder__user-pic loads"></div>
                      <div class="tm-placeholder__user-date loads"></div>
                     </div>
                     <div class="tm-placeholder-article-card__title">
                      <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div>
                      <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div>
                     </div>
                     <div class="tm-placeholder-article-card__icons tm-placeholder__counters">
                      <!--[-->
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div><!--]-->
                     </div>
                    </div>
                    <div class="tm-placeholder-article-card">
                     <div class="tm-placeholder__user">
                      <div class="tm-placeholder__user-pic loads"></div>
                      <div class="tm-placeholder__user-date loads"></div>
                     </div>
                     <div class="tm-placeholder-article-card__title">
                      <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div>
                      <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div>
                     </div>
                     <div class="tm-placeholder-article-card__icons tm-placeholder__counters">
                      <!--[-->
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div><!--]-->
                     </div>
                    </div>
                    <div class="tm-placeholder-article-card">
                     <div class="tm-placeholder__user">
                      <div class="tm-placeholder__user-pic loads"></div>
                      <div class="tm-placeholder__user-date loads"></div>
                     </div>
                     <div class="tm-placeholder-article-card__title">
                      <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div>
                      <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div>
                     </div>
                     <div class="tm-placeholder-article-card__icons tm-placeholder__counters">
                      <!--[-->
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div><!--]-->
                     </div>
                    </div>
                    <div class="tm-placeholder-article-card">
                     <div class="tm-placeholder__user">
                      <div class="tm-placeholder__user-pic loads"></div>
                      <div class="tm-placeholder__user-date loads"></div>
                     </div>
                     <div class="tm-placeholder-article-card__title">
                      <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div>
                      <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div>
                     </div>
                     <div class="tm-placeholder-article-card__icons tm-placeholder__counters">
                      <!--[-->
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div>
                      <div class="tm-placeholder-data-icon">
                       <div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div>
                       <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div>
                      </div><!--]-->
                     </div>
                    </div><!--]-->
                   </div><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->
                  </div><!---->
                 </div><!--]--><!--]-->
                </div><!--]--><!---->
               </section><!--[--><!--[-->
               <div>
                <div class="placeholder-wrapper">
                 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->
                 <div class="tm-placeholder-promo">
                  <div class="tm-placeholder-promo__header">
                   <div class="tm-placeholder__line tm-placeholder__line_promo-title"></div>
                  </div>
                  <div class="tm-placeholder-promo__body">
                   <div class="tm-placeholder-promo__posts">
                    <div class="tm-placeholder-promo__post">
                     <div class="tm-placeholder-promo__image"></div>
                     <div class="tm-placeholder__line tm-placeholder__line_post-title"></div>
                    </div>
                    <div class="tm-placeholder-promo__post">
                     <div class="tm-placeholder-promo__image"></div>
                     <div class="tm-placeholder__line tm-placeholder__line_post-title"></div>
                    </div>
                    <div class="tm-placeholder-promo__post">
                     <div class="tm-placeholder-promo__image"></div>
                     <div class="tm-placeholder__line tm-placeholder__line_post-title"></div>
                    </div>
                   </div>
                   <div class="tm-placeholder-promo__dots">
                    <div class="tm-placeholder-promo__dot"></div>
                    <div class="tm-placeholder-promo__dot"></div>
                    <div class="tm-placeholder-promo__dot"></div>
                   </div>
                  </div>
                 </div><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->
                </div>
               </div>
               <div class="placeholder-wrapper">
                <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->
                <div class="tm-placeholder-inset tm-placeholder-courses">
                 <div class="tm-placeholder-inset__header">
                  <div class="tm-placeholder__line tm-placeholder__line_inset-header loads"></div>
                 </div>
                 <div class="tm-placeholder-inset__body">
                  <ul class="tm-placeholder-list">
                   <!--[-->
                   <li class="tm-placeholder-list__item tm-placeholder-list__item_inset">
                    <div class="tm-placeholder-list__title-container">
                     <div class="tm-placeholder__company-avatar"></div>
                     <div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div>
                    </div>
                    <div class="tm-project-block-items__properties">
                     <!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]-->
                    </div></li>
                   <li class="tm-placeholder-list__item tm-placeholder-list__item_inset">
                    <div class="tm-placeholder-list__title-container">
                     <div class="tm-placeholder__company-avatar"></div>
                     <div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div>
                    </div>
                    <div class="tm-project-block-items__properties">
                     <!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]-->
                    </div></li>
                   <li class="tm-placeholder-list__item tm-placeholder-list__item_inset">
                    <div class="tm-placeholder-list__title-container">
                     <div class="tm-placeholder__company-avatar"></div>
                     <div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div>
                    </div>
                    <div class="tm-project-block-items__properties">
                     <!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]-->
                    </div></li>
                   <li class="tm-placeholder-list__item tm-placeholder-list__item_inset">
                    <div class="tm-placeholder-list__title-container">
                     <div class="tm-placeholder__company-avatar"></div>
                     <div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div>
                    </div>
                    <div class="tm-project-block-items__properties">
                     <!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]-->
                    </div></li>
                   <li class="tm-placeholder-list__item tm-placeholder-list__item_inset">
                    <div class="tm-placeholder-list__title-container">
                     <div class="tm-placeholder__company-avatar"></div>
                     <div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div>
                    </div>
                    <div class="tm-project-block-items__properties">
                     <!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]-->
                    </div></li><!--]-->
                  </ul>
                 </div>
                 <div class="tm-placeholder-inset__footer">
                  <div class="tm-placeholder__line tm-placeholder__line_inset-footer loads"></div>
                 </div>
                </div><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->
               </div><!--]--><!--]--><!----><!--[--><!--]--><!--]-->
              </div><!--]--><!--]-->
             </div>
            </div><!--]--><!--]-->
           </div>
          </div>
          <div class="tm-page__sidebar">
           <!--[-->
           <div class="tm-layout-sidebar">
            <div class="tm-layout-sidebar__placeholder_initial"></div>
            <div class="tm-sexy-sidebar_initial tm-sexy-sidebar" style="margin-top:0px;">
             <!--[--><!--]--><!---->
             <div class="tm-layout-sidebar__ads_initial tm-layout-sidebar__ads">
              <div class="banner-wrapper half-page tm-layout-sidebar__banner tm-layout-sidebar__banner_top" style="--38f3d936:600px;--78a3cd06:auto;" data-v-f4bf0d24>
               <!--[-->
               <div class="placeholder-wrapper placeholder" data-v-f4bf0d24>
                <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->
                <div class="adfox-banner-placeholder half-page" data-v-12f7bcca>
                 <div class="image loads" data-v-12f7bcca></div>
                 <div class="lines" data-v-12f7bcca>
                  <div class="line loads" data-v-12f7bcca></div>
                  <div class="line loads" data-v-12f7bcca></div>
                  <div class="line loads" data-v-12f7bcca></div>
                 </div>
                </div><!----><!----><!---->
               </div>
               <div id="adfox_164725680533065327" class="tm-adfox-banner" data-v-f4bf0d24></div><!--]-->
              </div>
             </div><!--[-->
             <section class="tm-block tm-block tm-block_spacing-bottom">
              <header class="tm-block__header tm-block__header">
               <div class="tm-block__header-container">
                <h2 class="tm-block__title tm-block__title">Информация</h2><!--[--><!--]-->
               </div><!---->
              </header><!--[-->
              <div class="tm-block__body tm-block__body">
               <!--[-->
               <div class="tm-company-basic-info">
                <dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap">
                 <dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">
                  Сайт
                 </dt>
                 <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body">
                  <!--[--><a class="tm-company-basic-info__link" href="https://timeweb.cloud/" target="_blank">timeweb.cloud</a><!--]-->
                 </dd>
                </dl>
                <dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap">
                 <dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">
                  Дата регистрации
                 </dt>
                 <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body">
                  <!--[--><time datetime="2011-08-11T14:17:04.000Z" title="2011-08-11, 18:17">11 августа 2011</time><!--]-->
                 </dd>
                </dl>
                <dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap">
                 <dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">
                  Дата основания
                 </dt>
                 <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body">
                  <!--[--><time datetime="2006-05-24T20:00:00.000Z" title="2006-05-25, 00:00">25 мая 2006</time><!--]-->
                 </dd>
                </dl>
                <dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap">
                 <dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">
                  Численность
                 </dt>
                 <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body">
                  <!--[-->201–500 человек<!--]-->
                 </dd>
                </dl>
                <dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap">
                 <dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">
                  Местоположение
                 </dt>
                 <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body">
                  <!--[-->Россия<!--]-->
                 </dd>
                </dl>
                <dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap">
                 <dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">
                  Представитель
                 </dt>
                 <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body">
                  <!--[--><a href="/ru/users/Timeweb_Cloud/" class="tm-company-basic-info__link">Timeweb Cloud</a><!--]-->
                 </dd>
                </dl>
               </div><!--]-->
              </div><!--]--><!---->
             </section>
             <div class="tm-company-widgets">
              <!--[--><!--]-->
             </div><!---->
             <div></div><!--]-->
             <div class="banner-wrapper medium-rectangle tm-layout-sidebar__banner tm-layout-sidebar__banner_bottom" style="--38f3d936:250px;--78a3cd06:auto;" data-v-f4bf0d24>
              <!--[-->
              <div class="placeholder-wrapper placeholder" data-v-f4bf0d24>
               <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->
               <div class="adfox-banner-placeholder medium-rectangle" data-v-12f7bcca>
                <div class="image loads" data-v-12f7bcca></div>
                <div class="lines" data-v-12f7bcca>
                 <div class="line loads" data-v-12f7bcca></div>
                 <div class="line loads" data-v-12f7bcca></div>
                 <div class="line loads" data-v-12f7bcca></div>
                </div>
               </div><!----><!----><!---->
              </div>
              <div id="adfox_164725691003361602" class="tm-adfox-banner" data-v-f4bf0d24></div><!--]-->
             </div>
            </div>
           </div><!--]-->
          </div>
         </div><!----><!--]-->
        </div>
       </div>
      </main><!---->
     </div>
     <div class="tm-footer-menu">
      <div class="tm-page-width">
       <!--[-->
       <div class="tm-footer-menu__container">
        <!--[-->
        <div class="tm-footer-menu__block">
         <p class="tm-footer-menu__block-title">Ваш аккаунт</p>
         <div class="tm-footer-menu__block-content">
          <ul class="tm-footer-menu__list">
           <!--[-->
           <li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/companies/timeweb/articles/903842/&amp;hl=ru" rel="nofollow" target="_self">Войти</a></li>
           <li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/companies/timeweb/articles/903842/&amp;hl=ru" rel="nofollow" target="_self">Регистрация</a></li><!--]-->
          </ul>
         </div>
        </div>
        <div class="tm-footer-menu__block">
         <p class="tm-footer-menu__block-title">Разделы</p>
         <div class="tm-footer-menu__block-content">
          <ul class="tm-footer-menu__list">
           <!--[-->
           <li class="tm-footer-menu__list-item"><a href="/ru/articles/" class="footer-menu__item-link">Статьи</a></li>
           <li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">Новости</a></li>
           <li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">Хабы</a></li>
           <li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">Компании</a></li>
           <li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">Авторы</a></li>
           <li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">Песочница</a></li><!--]-->
          </ul>
         </div>
        </div>
        <div class="tm-footer-menu__block">
         <p class="tm-footer-menu__block-title">Информация</p>
         <div class="tm-footer-menu__block-content">
          <ul class="tm-footer-menu__list">
           <!--[-->
           <li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">Устройство сайта</a></li>
           <li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">Для авторов</a></li>
           <li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">Для компаний</a></li>
           <li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">Документы</a></li>
           <li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement/?hl=ru_RU" target="_blank">Соглашение</a></li>
           <li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/?hl=ru_RU" target="_blank">Конфиденциальность</a></li><!--]-->
          </ul>
         </div>
        </div>
        <div class="tm-footer-menu__block">
         <p class="tm-footer-menu__block-title">Услуги</p>
         <div class="tm-footer-menu__block-content">
          <ul class="tm-footer-menu__list">
           <!--[-->
           <li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/corporate-blogs/" target="_blank">Корпоративный блог</a></li>
           <li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/advertising/" target="_blank">Медийная реклама</a></li>
           <li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/native-special/" target="_blank">Нативные проекты</a></li>
           <li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/education-programs/" target="_blank">Образовательные программы</a></li>
           <li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/hello-startup/" target="_blank">Стартапам</a></li><!--]-->
          </ul>
         </div>
        </div><!--]-->
       </div><!--]-->
      </div>
     </div>
     <div class="tm-footer">
      <div class="tm-page-width">
       <!--[-->
       <div class="tm-footer__container">
        <!---->
        <div class="tm-footer__social">
         <!--[--><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank">
          <svg class="tm-svg-img tm-svg-icon" height="24" width="24">
           <title>
            Facebook
           </title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-facebook"></use>
          </svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank">
          <svg class="tm-svg-img tm-svg-icon" height="24" width="24">
           <title>
            Twitter
           </title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-twitter"></use>
          </svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank">
          <svg class="tm-svg-img tm-svg-icon" height="24" width="24">
           <title>
            VK
           </title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-vk"></use>
          </svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank">
          <svg class="tm-svg-img tm-svg-icon" height="24" width="24">
           <title>
            Telegram
           </title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-telegram"></use>
          </svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank">
          <svg class="tm-svg-img tm-svg-icon" height="24" width="24">
           <title>
            Youtube
           </title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-youtube"></use>
          </svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://dzen.ru/habr" rel="nofollow noopener noreferrer" target="_blank">
          <svg class="tm-svg-img tm-svg-icon" height="24" width="24">
           <title>
            Яндекс Дзен
           </title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-dzen"></use>
          </svg></a><!--]-->
        </div><!--teleport start--><!--teleport end-->
        <button class="tm-footer__link"><!----> Настройка языка</button><a href="/ru/feedback/" class="tm-footer__link">Техническая поддержка</a>
        <div class="tm-footer-copyright">
         <span class="tm-copyright"><span class="tm-copyright__years">© 2006–2025, </span><span class="tm-copyright__name"><a class="tm-copyright__link" href="https://company.habr.com/" rel="noopener" target="_blank">Habr</a></span></span>
        </div>
       </div><!--]-->
      </div>
     </div><!----><!--]-->
    </div><!---->
   </div>
   <script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"903842":{"id":"903842","timePublished":"2025-05-06T10:05:09+00:00","isCorporative":true,"lang":"ru","titleHtml":"JavaScript: структуры данных и алгоритмы. Часть 11","leadData":{"textHtml":"\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fma\u002Fpo\u002Flv\u002Fmapolvqq4uunxfqoaviv3g9km9y.jpeg\"\u003E\u003Cbr\u003E\r\n\u003Cp\u003E\u003Cbr\u003E\r\nПривет, друзья!\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EВ этой серии статей мы разбираем структуры данных и алгоритмы, представленные в \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ftrekhleb\u002Fjavascript-algorithms\" rel=\"nofollow noopener noreferrer\"\u003Eэтом замечательном репозитории\u003C\u002Fa\u003E. Это одиннадцатая часть серии.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EСегодня мы рассмотрим несколько простых, но интересных алгоритмов машинного обучения, а также один весьма любопытный статистический алгоритм.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EКод, представленный в этой и других статьях серии, можно найти в \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fharryheman\u002Falgorithms-data-structures\" rel=\"nofollow noopener noreferrer\"\u003Eэтом репозитории\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EИнтересно? Тогда прошу под кат.\u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"editorVersion":"1.0","postType":"article","postLabels":[],"author":{"id":"2147423","alias":"aio350","fullname":"Igor Agapov","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F4d3\u002F879\u002Fa5a\u002F4d3879a5a72249d5267d1f152ac59d40.jpg","speciality":"JavaScript Developer","scoreStats":{"score":305,"votesCount":443},"rating":34.4,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"donationsMethod":null,"isInBlacklist":null,"careerProfile":null},"statistics":{"commentsCount":1,"favoritesCount":24,"readingCount":1531,"score":8,"votesCount":6,"votesCountPlus":6,"votesCountMinus":0},"hubs":[{"id":"17357","alias":"timeweb","type":"corporative","title":"Блог компании Timeweb Cloud","titleHtml":"Блог компании Timeweb Cloud","isProfiled":false,"relatedData":null},{"id":"357","alias":"javascript","type":"collective","title":"JavaScript","titleHtml":"JavaScript","isProfiled":true,"relatedData":null},{"id":"8000","alias":"algorithms","type":"collective","title":"Алгоритмы","titleHtml":"Алгоритмы","isProfiled":true,"relatedData":null},{"id":"19439","alias":"machine_learning","type":"collective","title":"Машинное обучение","titleHtml":"Машинное обучение","isProfiled":true,"relatedData":null},{"id":"21890","alias":"statistics","type":"collective","title":"Статистика в IT","titleHtml":"Статистика в IT","isProfiled":false,"relatedData":null}],"flows":[{"id":"1","alias":"develop","title":"Разработка","titleHtml":"Разработка"},{"id":"7","alias":"popsci","title":"Научпоп","titleHtml":"Научпоп"}],"relatedData":{"vote":null,"unreadCommentsCount":0,"bookmarked":false,"canComment":false,"canEdit":false,"canViewVotes":false,"votePlus":{"canVote":false,"isChargeEnough":false,"isKarmaEnough":false,"isVotingOver":false,"isPublicationLimitEnough":false},"voteMinus":{"canVote":false,"isChargeEnough":false,"isKarmaEnough":false,"isVotingOver":false,"isPublicationLimitEnough":false},"canModerateComments":false,"trackerSubscribed":false,"emailSubscribed":false},"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fma\u002Fpo\u002Flv\u002Fmapolvqq4uunxfqoaviv3g9km9y.jpeg\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002Fma\u002Fpo\u002Flv\u002Fmapolvqq4uunxfqoaviv3g9km9y.jpeg 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fma\u002Fpo\u002Flv\u002Fmapolvqq4uunxfqoaviv3g9km9y.jpeg 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cbr\u002F\u003E\nПривет, друзья!\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВ этой серии статей мы разбираем структуры данных и алгоритмы, представленные в \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ftrekhleb\u002Fjavascript-algorithms\"\u003Eэтом замечательном репозитории\u003C\u002Fa\u003E. Это одиннадцатая часть серии.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EСегодня мы рассмотрим несколько простых, но интересных алгоритмов машинного обучения, а также один весьма любопытный статистический алгоритм.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EКод, представленный в этой и других статьях серии, можно найти в \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fharryheman\u002Falgorithms-data-structures\"\u003Eэтом репозитории\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EИнтересно? Тогда прошу под кат.\u003C\u002Fp\u003E\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompanies\u002Ftimeweb\u002Farticles\u002F826424\u002F\"\u003EПервая часть\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompanies\u002Ftimeweb\u002Farticles\u002F828068\u002F\"\u003EВторая часть\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompanies\u002Ftimeweb\u002Farticles\u002F832402\u002F\"\u003EТретья часть\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompanies\u002Ftimeweb\u002Farticles\u002F836782\u002F\"\u003EЧетвертая часть\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompanies\u002Ftimeweb\u002Farticles\u002F838794\u002F\"\u003EПятая часть\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompanies\u002Ftimeweb\u002Farticles\u002F845544\u002F\"\u003EШестая часть\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompanies\u002Ftimeweb\u002Farticles\u002F856046\u002F\"\u003EСедьмая часть\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompanies\u002Ftimeweb\u002Farticles\u002F856046\u002F\"\u003EВосьмая часть\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompanies\u002Ftimeweb\u002Farticles\u002F856046\u002F\"\u003EДевятая часть\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompanies\u002Ftimeweb\u002Farticles\u002F856046\u002F\"\u003EДесятая часть\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\n\u003Ch1 id=\"-mashinnoe-obuchenie\"\u003E❯ Машинное обучение\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\n\u003Ch2 id=\"-nanoneuron\"\u003E❯ NanoNeuron\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003ENanoNeuron (далее — нейрончик) — это очень упрощенная версия концепции нейронов из нейронных сетей. Нейрончик умеет конвертировать значения температуры из градусов Цельсия в градусы Фаренгейта.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EКод примера содержит 7 простых функций (затрагивающих предсказание модели, вычисление стоимости, прямое\u002Fобратное распространение и обучение), позволяющих понять, как машины на самом деле \"обучаются\". В коде нет сторонних библиотек, внешних зависимостей или наборов данных, только чистые и простые функции.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЭти функции не являются руководством по машинному обучению. Многие концепции машинного обучения отсутствуют и упрощены! Упрощение преследует цель дать читателю самое базовое понимание того, как учатся машины, а также того, что машинное обучение — это не магия, а математика.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EЧему NanoNeuron будет учиться?\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВероятно, вы слышали о нейронах в контексте \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%9D%D0%B5%D0%B9%D1%80%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B5%D1%82%D1%8C\"\u003Eнейронных сетей\u003C\u002Fa\u003E. Нейрончик — это как раз такой нейрон, только проще. Мы реализуем его с нуля. Для простоты мы даже не будем создавать сеть из нейрончиков. Он будет работать сам по себе, делая некоторые \"магические\" предсказания для нас. Мы научим его конвертировать (предсказывать) температуру в градусах Фаренгейта на основе температуры в градусах Цельсия.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EКстати, формула для такого преобразования следующая:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Ef = c * 1.8 + 32\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНо пока наш нейрончик о ней не знает.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EМодель NanoNeuron\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EОпределим функцию моделирования нейрончика. Она реализует базовую линейную зависимость между \u003Ccode\u003Ex\u003C\u002Fcode\u003E и \u003Ccode\u003Ey\u003C\u002Fcode\u003E, которая выглядит как \u003Ccode\u003Ey = w * x + b\u003C\u002Fcode\u003E. Проще говоря, наш нейрончик — это \"ребенок\" в \"школе\", который учится рисовать прямую линию в системе координат \u003Ccode\u003EXY\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПеременные \u003Ccode\u003Ew\u003C\u002Fcode\u003E и \u003Ccode\u003Eb\u003C\u002Fcode\u003E — это параметры модели. Нейрончику известны только эти параметры линейной функции. Он \"выучит\" значения этих параметров в процессе обучения.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЕдинственная вещь, которую умеет делать нейрончик, — это имитация линейной зависимости. В методе \u003Ccode\u003Epredict()\u003C\u002Fcode\u003E он принимает некоторый \u003Ccode\u003Ex\u003C\u002Fcode\u003E и предсказывает \u003Ccode\u003Ey\u003C\u002Fcode\u003E. Никакой магии:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Efunction NanoNeuron(w, b) {\n  this.w = w;\n  this.b = b;\n  this.predict = (x) =&gt; {\n    return x * this.w + this.b;\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%9B%D0%B8%D0%BD%D0%B5%D0%B9%D0%BD%D0%B0%D1%8F_%D1%80%D0%B5%D0%B3%D1%80%D0%B5%D1%81%D1%81%D0%B8%D1%8F\"\u003EЛинейная регрессия\u003C\u002Fa\u003E — это ты?🧐\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EПреобразование градусов\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Efunction celsiusToFahrenheit(c) {\n  const w = 1.8;\n  const b = 32;\n  const f = c * w + b;\n  return f;\n};\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EМы хотим научить нейрончика имитировать эту функцию, т.е. научить, что \u003Ccode\u003Ew = 1.8\u003C\u002Fcode\u003E, а \u003Ccode\u003Eb = 32\u003C\u002Fcode\u003E без предоставления этих значений.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EГрафически эту функцию можно представить следующим образом:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002F_g\u002Fvw\u002Foh\u002F_gvwohoerz92tp_vet1rqqkwpuc.png\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002F_g\u002Fvw\u002Foh\u002F_gvwohoerz92tp_vet1rqqkwpuc.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002F_g\u002Fvw\u002Foh\u002F_gvwohoerz92tp_vet1rqqkwpuc.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cbr\u002F\u003E\n\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EГенерация наборов данных\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПеред обучением модели нужно сгенерировать наборы тренировочных и тестовых данных на основе функции \u003Ccode\u003EcelsiusToFahrenheit()\u003C\u002Fcode\u003E. Наборы состоят из пар входных значений и правильно размеченных результатов.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cblockquote\u003EВ реальной жизни данные, как правило, собираются, а не генерируются. Например, у нас может быть набор изображений с рукописными цифрами и набор соответствующих цифр.\u003C\u002Fblockquote\u003E\u003Cp\u003EДля обучения нейрончика используется тренировочный набор. Перед тем, как нейрончик вырастет и сможет принимать решения самостоятельно, мы должны объяснить ему, что такое хорошо и что такое плохо с помощью тренировочных примеров.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EТестовый набор используется для проверки того, насколько хорошо нейрончик обрабатывает данные, которых он не видел в процессе обучения. Это та точка, когда мы видим, что наш \"ребенок\" вырос и может принимать самостоятельные решения:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Efunction generateDataSets() {\n  \u002F\u002F xTrain -&gt; [0, 1, 2, ...],\n  \u002F\u002F yTrain -&gt; [32, 33.8, 35.6, ...]\n  const xTrain = [];\n  const yTrain = [];\n  for (let x = 0; x &lt; 100; x += 1) {\n    const y = celsiusToFahrenheit(x);\n    xTrain.push(x);\n    yTrain.push(y);\n  }\n\n  \u002F\u002F xTest -&gt; [0.5, 1.5, 2.5, ...]\n  \u002F\u002F yTest -&gt; [32.9, 34.7, 36.5, ...]\n  const xTest = [];\n  const yTest = [];\n  \u002F\u002F Начиная с 0.5 и используя такой же шаг 1,\n  \u002F\u002F который мы использовали для тренировочного набора,\n  \u002F\u002F мы обеспечиваем уникальность данных\n  for (let x = 0.5; x &lt; 100; x += 1) {\n    const y = celsiusToFahrenheit(x);\n    xTest.push(x);\n    yTest.push(y);\n  }\n\n  return [xTrain, yTrain, xTest, yTest];\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EСтоимость (ошибка) предсказания\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНам нужен какой-то критерий верности предсказания. Вычисление стоимости (ошибки) между правильным значением \u003Ccode\u003Ey\u003C\u002Fcode\u003E и \u003Ccode\u003Eprediction\u003C\u002Fcode\u003E (предсказанием), сделанным нейрончиком, производится по следующей формуле:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003EpredictionCost = (y - prediction) ** 2 * 0.5\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЭто просто разница между двумя значениями. Чем ближе значения друг к другу, тем меньше разница. Мы используем степень \u003Ccode\u003E2\u003C\u002Fcode\u003E для избавления от отрицательных чисел, поэтому \u003Ccode\u003E(1 - 2) ** 2\u003C\u002Fcode\u003E = \u003Ccode\u003E(2 - 1) ** 2\u003C\u002Fcode\u003E. Деление на \u003Ccode\u003E2\u003C\u002Fcode\u003E выполняется для упрощения дальнейшей формулы обратного распространения (см. ниже):\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Efunction predictionCost(y, prediction) {\n  return (y - prediction) ** 2 \u002F 2;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EПрямое распространение\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПрямое распространение (forward propagation) означает выполнение предсказаний для всех тренировочных примеров из наборов \u003Ccode\u003ExTrain\u003C\u002Fcode\u003E и \u003Ccode\u003EyTrain\u003C\u002Fcode\u003E и вычисление средней стоимости этих предсказаний.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EМы позволяет нейрончику играть в \"угадайку\". Он может сильно ошибаться. Средняя стоимость покажет нам, насколько некорректной является наша модель. Эта стоимость очень важна, поскольку влияет на параметры \u003Ccode\u003Ew\u003C\u002Fcode\u003E и \u003Ccode\u003Eb\u003C\u002Fcode\u003E, которыми оперирует нейрончик. Повторное выполнение прямого распространения показывает, стал ли нейрончик умнее после соответствующих изменений.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EСредняя стоимость вычисляется по такой формуле:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fjc\u002F9j\u002Fh2\u002Fjc9jh2sfgrprioxjlybno6wu7k0.png\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002Fjc\u002F9j\u002Fh2\u002Fjc9jh2sfgrprioxjlybno6wu7k0.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fjc\u002F9j\u002Fh2\u002Fjc9jh2sfgrprioxjlybno6wu7k0.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cbr\u002F\u003E\n\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EГде \u003Ccode\u003Em\u003C\u002Fcode\u003E — это количество тренировочных примеров (\u003Ccode\u003E100\u003C\u002Fcode\u003E в нашем случае).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Efunction forwardPropagation(model, xTrain, yTrain) {\n  const m = xTrain.length;\n  const predictions = [];\n  let cost = 0;\n  for (let i = 0; i &lt; m; i += 1) {\n    const prediction = nanoNeuron.predict(xTrain[i]);\n    cost += predictionCost(yTrain[i], prediction);\n    predictions.push(prediction);\n  }\n  \u002F\u002F Нас интересует средняя стоимость\n  cost \u002F= m;\n  return [predictions, cost];\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EОбратное распространение\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПосле того, как мы узнали, насколько верными являются предсказания модели (на основе средней стоимости), как нам сделать их более точными?\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EОтвет — обратное распространение (backward propagation). Обратное распространение — это процесс оценки стоимости предсказания и модификации параметров \u003Ccode\u003Ew\u003C\u002Fcode\u003E и \u003Ccode\u003Eb\u003C\u002Fcode\u003E таким образом, чтобы будущие предсказания были более точными.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВ этом месте машинное обучение выглядит как магия. Ключевой концепцией здесь является производная (derivative), которая показывает, какой шаг необходимо предпринять, чтобы подобраться к минимальной функции стоимости (minimum cost function).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПомните, что нахождение минимальной функции стоимости — это конечная цель обучения. Если мы нашли значения \u003Ccode\u003Ew\u003C\u002Fcode\u003E и \u003Ccode\u003Eb\u003C\u002Fcode\u003E, которые делают среднюю стоимость маленькой, значит, модель будет делать хорошие и точные предсказания.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПроизводные — это большая и отдельная тема, выходящая за рамки нашей беседы. \u003Ca href=\"https:\u002F\u002Fwww.mathsisfun.com\u002Fcalculus\u002Fderivatives-introduction.html\"\u003EMathIsFun\u003C\u002Fa\u003E — отличный ресурс для начала погружения в эту тему.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПроизводная, по сути, является касательной к кривой функции, которая указывает в направлении минимума функции:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002F_t\u002Fln\u002Fsz\u002F_tlnsz_p-p1dnornwgpazuttcdo.png\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002F_t\u002Fln\u002Fsz\u002F_tlnsz_p-p1dnornwgpazuttcdo.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002F_t\u002Fln\u002Fsz\u002F_tlnsz_p-p1dnornwgpazuttcdo.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cbr\u002F\u003E\n\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EИз приведенного графика следует, что если мы находимся в точке \u003Ccode\u003E(x=2, y=4)\u003C\u002Fcode\u003E, то кривая \"говорит\" нам двигаться влево и вниз для достижения минимума функции.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПроизводные функции \u003Ccode\u003EaverageCost()\u003C\u002Fcode\u003E для параметров \u003Ccode\u003Ew\u003C\u002Fcode\u003E и \u003Ccode\u003Eb\u003C\u002Fcode\u003E выглядят так:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002F4t\u002F53\u002F5d\u002F4t535dwgswdm5a4lkyivyqobkte.png\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002F4t\u002F53\u002F5d\u002F4t535dwgswdm5a4lkyivyqobkte.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002F4t\u002F53\u002F5d\u002F4t535dwgswdm5a4lkyivyqobkte.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fj8\u002Flu\u002F4n\u002Fj8lu4nhjzvzkzbkypc8azhqlepi.png\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002Fj8\u002Flu\u002F4n\u002Fj8lu4nhjzvzkzbkypc8azhqlepi.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fj8\u002Flu\u002F4n\u002Fj8lu4nhjzvzkzbkypc8azhqlepi.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cbr\u002F\u003E\n\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EГде \u003Ccode\u003Em\u003C\u002Fcode\u003E — количество тренировочных примеров (\u003Ccode\u003E100\u003C\u002Fcode\u003E в нашем случае).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Efunction backwardPropagation(predictions, xTrain, yTrain) {\n  const m = xTrain.length;\n  \u002F\u002F В начале мы не знаем, как менять параметры 'w' и 'b'.\n  \u002F\u002F Поэтому устанавливаем шаг изменения для каждого параметра в 0\n  let dW = 0;\n  let dB = 0;\n  for (let i = 0; i &lt; m; i += 1) {\n    dW += (yTrain[i] - predictions[i]) * xTrain[i];\n    dB += yTrain[i] - predictions[i];\n  }\n  \u002F\u002F Нас интересует средняя дельта каждого параметра\n  dW \u002F= m;\n  dB \u002F= m;\n  return [dW, dB];\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EОбучение модели\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EТеперь мы знаем, как оценивать корректность модели для всех тренировочных примеров (прямое распространение). Мы также знаем, как применять небольшие модификации параметров \u003Ccode\u003Ew\u003C\u002Fcode\u003E и \u003Ccode\u003Eb\u003C\u002Fcode\u003E модели (обратное распространение). Но проблема состоит в том, что однократного запуска прямого и обратного распространений недостаточно для того, чтобы наша модель извлекла какие-то уроки из тренировочных данных. Это можно сравнить с одним днем обучения ребенка в школе. Ребенок ходит в школу не однажды, а день за днем и год за годом, чтобы чему-нибудь научиться.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПоэтому распространения следует повторять много раз. Это как раз то, что делает функция \u003Ccode\u003EtrainModel()\u003C\u002Fcode\u003E. Это как учитель для нашего нейрончика:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cul\u003E\n\u003Cli\u003Eон проводит некоторое время (\u003Ccode\u003Eepochs\u003C\u002Fcode\u003E) с нашим глупым нейрончиком и пытается его чему-то научить\u003C\u002Fli\u003E\n\u003Cli\u003Eон использует специальные \"книги\" (наборы данных \u003Ccode\u003ExTrain\u003C\u002Fcode\u003E и \u003Ccode\u003EyTrain\u003C\u002Fcode\u003E) для обучения\u003C\u002Fli\u003E\n\u003Cli\u003Eон заставляет нейрончика учиться усерднее (быстрее) с помощью параметра оценки обучения \u003Ccode\u003Ealpha\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНесколько слов об \u003Ccode\u003Ealpha\u003C\u002Fcode\u003E. Это просто произведение \u003Ccode\u003EdW\u003C\u002Fcode\u003E и \u003Ccode\u003EdB\u003C\u002Fcode\u003E, вычисленных в процессе обратного распространения. Производная указывает нам направление, в котором мы должны двигаться для достижения минимума функции стоимости (положительные\u002Fотрицательные знаки \u003Ccode\u003EdW\u003C\u002Fcode\u003E и \u003Ccode\u003EdB\u003C\u002Fcode\u003E), а также скорость, с которой мы должны двигаться в этом направлении (абсолютные значения \u003Ccode\u003EdW\u003C\u002Fcode\u003E и \u003Ccode\u003EdB\u003C\u002Fcode\u003E). Нам нужно умножить эти шаги на \u003Ccode\u003Ealpha\u003C\u002Fcode\u003E, чтобы ускорить или замедлить наше движение к минимуму. При использовании больших значений для \u003Ccode\u003Ealpha\u003C\u002Fcode\u003E можно просто перепрыгнуть минимум и никогда его не найти.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЕсли использовать аналогию с учителем, то можно сказать, что чем сильнее учитель будет давить на ребенка, тем быстрее он будет учиться, но если учитель будет давить слишком сильно, то у ребенка случится нервный срыв и больше учиться он не сможет 🤯\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПараметры \u003Ccode\u003Ew\u003C\u002Fcode\u003E и \u003Ccode\u003Eb\u003C\u002Fcode\u003E будут обновляться следующим образом:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Ew = w + alpha * dW\nb = b + alpha * dB\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EФункция обучения:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Efunction trainModel({model, epochs, alpha, xTrain, yTrain}) {\n  \u002F\u002F История обучения\n  const costHistory = [];\n\n  \u002F\u002F Перебираем эпохи\n  for (let epoch = 0; epoch &lt; epochs; epoch += 1) {\n    \u002F\u002F Прямое распространение\n    const [predictions, cost] = forwardPropagation(model, xTrain, yTrain);\n    costHistory.push(cost);\n\n    \u002F\u002F Обратное распространение\n    const [dW, dB] = backwardPropagation(predictions, xTrain, yTrain);\n\n    \u002F\u002F Модифицируем параметры модели для повышения точности предсказаний\n    nanoNeuron.w += alpha * dW;\n    nanoNeuron.b += alpha * dB;\n  }\n\n  return costHistory;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EВместе веселее\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПрименим созданные функции.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EСоздаем экземпляр \u003Ccode\u003ENanoNeuron\u003C\u002Fcode\u003E. В данный момент нейрончику неизвестны значения \u003Ccode\u003Ew\u003C\u002Fcode\u003E и \u003Ccode\u003Eb\u003C\u002Fcode\u003E. Устанавливаем их произвольно:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econst w = Math.random(); \u002F\u002F например -&gt; 0.9492\nconst b = Math.random(); \u002F\u002F например -&gt; 0.4570\nconst nanoNeuron = new NanoNeuron(w, b);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EГенерируем наборы данных:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econst [xTrain, yTrain, xTest, yTest] = generateDataSets();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EОбучаем модель небольшими шагами (\u003Ccode\u003E0.0005\u003C\u002Fcode\u003E) на протяжении \u003Ccode\u003E7000\u003C\u002Fcode\u003E эпох. Эти значения были определены эмпирическим путем, не стесняйтесь их менять:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econst epochs = 70000;\nconst alpha = 0.0005;\nconst trainingCostHistory = trainModel({ model: nanoNeuron, epochs, alpha, xTrain, yTrain });\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПроверяем функцию стоимости в процессе обучения. Мы ожидаем, что стоимость после обучения будет значительно ниже, чем до него. Это будет означать, что нейрончик стал умнее. Противоположное также возможно:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econsole.log('Стоимость до обучения:', trainingCostHistory[0]); \u002F\u002F например, 4694.3335043\nconsole.log('Стоимость после обучения:', trainingCostHistory[epochs - 1]); \u002F\u002F например, 0.0000024\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EГрафически снижение стоимости выглядит так (ось \u003Ccode\u003Ex\u003C\u002Fcode\u003E — количество эпох):\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fkc\u002Frf\u002Fhb\u002Fkcrfhb350xpq2alm_jq9ulcb0z8.png\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002Fkc\u002Frf\u002Fhb\u002Fkcrfhb350xpq2alm_jq9ulcb0z8.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fkc\u002Frf\u002Fhb\u002Fkcrfhb350xpq2alm_jq9ulcb0z8.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cbr\u002F\u003E\n\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВзглянем на параметры модели. Мы ожидаем, что \u003Ccode\u003Ew\u003C\u002Fcode\u003E и \u003Ccode\u003Eb\u003C\u002Fcode\u003E нейрончика будут близки к истинным (\u003Ccode\u003Ew = 1.8\u003C\u002Fcode\u003E и \u003Ccode\u003Eb = 32\u003C\u002Fcode\u003E):\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econsole.log('Параметры нейрончика:', { w: nanoNeuron.w, b: nanoNeuron.b }); \u002F\u002F например -&gt; { w: 1.8, b: 31.99 }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EОцениваем точность модели на тестовых данных, чтобы увидеть, как хорошо нейрончик справляется с обработкой неизвестных данных. Мы ожидаем, что стоимость тестовых предсказаний будет близка к стоимости тренировочных предсказаний:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E[testPredictions, testCost] = forwardPropagation(nanoNeuron, xTest, yTest);\nconsole.log('Стоимость тестовых предсказаний:', testCost); \u002F\u002F например -&gt; 0.0000023\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EТеперь, поскольку наш \"ребенок\" хорошо показал себя при обучении в \"школе\" и научился правильно обрабатывать данные, которых он не видел, мы можем назвать его \"умным\" и задать ему парочку вопросов. В этом и заключалась цель обучения:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econst tempInCelsius = 70;\nconst customPrediction = nanoNeuron.predict(tempInCelsius);\nconsole.log(`Нейрончик \"думает\", что ${tempInCelsius}°C в градусах Фаренгейта:`, customPrediction); \u002F\u002F -&gt; 158.0002\nconsole.log('Правильный ответ:', celsiusToFahrenheit(tempInCelsius)); \u002F\u002F -&gt; 158\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EОчень близко! Наш нейрончик хорош, но не идеален, как все люди :)\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EПолный код:\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F\u002F Модель NanoNeuron (нейрончика).\n\u002F\u002F Она реализует базовую линейную зависимость между 'x' и 'y': y = w * x + b.\n\u002F\u002F Проще говоря, наш нейрончик - это \"ребенок\", умеющий рисовать прямую линию в системе координат XY.\n\u002F\u002F w, b - параметры модели\nclass NanoNeuron {\n  constructor(w, b) {\n    \u002F\u002F Нейрончику известны только эти два параметра линейной функции.\n    \u002F\u002F Значения этих параметров будут определяться нейрончиком в процессе обучения\n    this.w = w\n    this.b = b\n  }\n  \u002F\u002F Все, что умеет нейрончик, - имитировать линейную зависимость.\n  \u002F\u002F Он принимает некоторый 'x' и предсказывает 'y'. Никакой магии\n  predict(x) {\n    return x * this.w + this.b\n  }\n}\n\n\u002F\u002F Конвертирует градусы Цельсия в градусы Фаренгейта по формуле: f = 1.8 * c + 32.\n\u002F\u002F Мы хотим научить нейрончика имитировать эту функцию, т.е.\n\u002F\u002F научить, что W = 1.8, а B = 32 без предоставления этих значений.\n\u002F\u002F c - температура в градусах Цельсия\n\u002F\u002F f - вычисленная температура в градусах Фаренгейта\nconst W = 1.8\nconst B = 32\nfunction celsiusToFahrenheit(c) {\n  const f = c * W + B\n  return f\n}\n\n\u002F\u002F Генерирует обучающий и тестовый наборы данных с помощью функции celsiusToFahrenheit().\n\u002F\u002F Наборы состоят из пар входных значений и правильно размеченных результатов.\n\u002F\u002F В реальной жизни в большинстве случаев эти данные будут собраны, а не сгенерированы.\n\u002F\u002F Например, у нас может быть набор изображений рукописных цифр и\n\u002F\u002F набор соответствующих цифр\nfunction generateDataSets() {\n  \u002F\u002F Генерируем ТРЕНИРОВОЧНЫЕ данные.\n  \u002F\u002F Эти данные будут использоваться для обучения модели.\n  \u002F\u002F Перед тем, как нейрончик вырастет и сможет принимать решения самостоятельно,\n  \u002F\u002F мы должны объяснить ему, что такое хорошо и что такое плохо с помощью\n  \u002F\u002F тренировочных примеров.\n  \u002F\u002F xTrain -&gt; [0, 1, 2, ...],\n  \u002F\u002F yTrain -&gt; [32, 33.8, 35.6, ...]\n  const xTrain = []\n  const yTrain = []\n  for (let x = 0; x &lt; 100; x += 1) {\n    const y = celsiusToFahrenheit(x)\n    xTrain.push(x)\n    yTrain.push(y)\n  }\n\n  \u002F\u002F Генерируем ТЕСТОВЫЕ данные.\n  \u002F\u002F Эти данные будут использоваться для оценки того, насколько хорошо модель работает с данными,\n  \u002F\u002F которых она не видела в процессе обучения. Здесь мы можем увидеть,\n  \u002F\u002F что наш \"ребенок\" вырос и может принимать решения самостоятельно.\n  \u002F\u002F xTest -&gt; [0.5, 1.5, 2.5, ...]\n  \u002F\u002F yTest -&gt; [32.9, 34.7, 36.5, ...]\n  const xTest = []\n  const yTest = []\n  \u002F\u002F Начиная с 0.5 и используя такой же шаг 1,\n  \u002F\u002F который мы использовали для тренировочного набора,\n  \u002F\u002F мы обеспечиваем уникальность данных\n  for (let x = 0.5; x &lt; 100; x += 1) {\n    const y = celsiusToFahrenheit(x)\n    xTest.push(x)\n    yTest.push(y)\n  }\n\n  return [xTrain, yTrain, xTest, yTest]\n}\n\n\u002F\u002F Вычисляем стоимость (ошибку) между правильным значением 'y' и\n\u002F\u002F 'prediction' (предсказанием), сделанным нейрончиком\nfunction predictionCost(y, prediction) {\n  \u002F\u002F Это просто разница между двумя значениями.\n  \u002F\u002F Чем ближе значения друг к другу, тем меньше разница.\n  \u002F\u002F Мы используем здесь степень 2 только для того, чтобы избавиться от отрицательных чисел,\n  \u002F\u002F поэтому (1 - 2) ^ 2 = (2 - 1) ^ 2.\n  \u002F\u002F Результат делится на 2 просто для упрощения дальнейшей формулы обратного распространения (см. ниже)\n  return (y - prediction) ** 2 \u002F 2 \u002F\u002F например -&gt; 235.6\n}\n\n\u002F\u002F Прямое распространение.\n\u002F\u002F Эта функция берет все примеры из тренировочных наборов xTrain и yTrain\n\u002F\u002F и вычисляет предсказания модели для каждого примера из xTrain.\n\u002F\u002F По пути она также вычисляет среднюю стоимость предсказаний\nfunction forwardPropagation(model, xTrain, yTrain) {\n  const m = xTrain.length\n  const predictions = []\n  let cost = 0\n  for (let i = 0; i &lt; m; i += 1) {\n    const prediction = model.predict(xTrain[i])\n    cost += predictionCost(yTrain[i], prediction)\n    predictions.push(prediction)\n  }\n  \u002F\u002F Нас интересует средняя стоимость\n  cost \u002F= m\n  return [predictions, cost]\n}\n\n\u002F\u002F Обратное распространение.\n\u002F\u002F В этом месте машинное обучение выглядит как магия.\n\u002F\u002F Ключевой концепцией здесь является производная (derivative), которая показывает, какой шаг нужно предпринять, чтобы\n\u002F\u002F приблизиться к минимуму функции стоимости. Помните, нахождение минимальной функции стоимости -\n\u002F\u002F конечная цель процесса обучения. Функция стоимости выглядит следующим образом:\n\u002F\u002F (y - prediction) ^ 2 * 1\u002F2, где prediction = x * w + b.\nfunction backwardPropagation(predictions, xTrain, yTrain) {\n  const m = xTrain.length\n  \u002F\u002F В начале мы не знаем, как менять параметры 'w' и 'b'.\n  \u002F\u002F Поэтому устанавливаем шаг изменения для каждого параметра в значение 0\n  let dW = 0\n  let dB = 0\n  for (let i = 0; i &lt; m; i += 1) {\n    \u002F\u002F Это производная функции стоимости параметра 'w'.\n    \u002F\u002F Она показывает, в каком направлении (положительный\u002Fотрицательный знак 'dW') и\n    \u002F\u002F на сколько (абсолютное значение 'dW') параметр 'w' должен быть изменен\n    dW += (yTrain[i] - predictions[i]) * xTrain[i]\n    \u002F\u002F Это производная функции стоимости параметра 'b'.\n    \u002F\u002F Она показывает, в каком направлении (знак 'dB') и\n    \u002F\u002F на сколько (абсолютное значение 'dB') параметр 'b' должен быть изменен\n    dB += yTrain[i] - predictions[i]\n  }\n  \u002F\u002F Нас интересуют средняя дельта каждого параметра\n  dW \u002F= m\n  dB \u002F= m\n  return [dW, dB]\n}\n\n\u002F\u002F Обучает модель.\n\u002F\u002F Это \"учитель\" нашего нейрончика:\n\u002F\u002F - он проводит некоторое время (epochs) с нашим глупым нейрончиком и пытается его чему-то научить,\n\u002F\u002F - он использует специальные \"книги\" (наборы данных xTrain и yTrain) для обучения,\n\u002F\u002F - он заставляет ребенка учиться усерднее (быстрее) с помощью параметра оценки обучения 'alpha'\n\u002F\u002F (чем сильнее стимул, тем быстрее модель учится, но если учитель будет давить слишком сильно\n\u002F\u002F у \"ребенка\" может случиться нервный срыв, и больше он не сможет учиться)\nfunction trainModel(model, epochs, alpha, xTrain, yTrain) {\n  \u002F\u002F История обучения модели.\n  \u002F\u002F Она может содержать хорошие или плохие \"оценки\" (стоимость),\n  \u002F\u002F полученные в процессе обучения\n  const costHistory = []\n\n  \u002F\u002F Перебираем эпохи\n  for (let i = 0; i &lt; epochs; i += 1) {\n    \u002F\u002F Прямое распространение для всех тренировочных примеров.\n    \u002F\u002F Сохраняем стоимость текущей итерации.\n    \u002F\u002F Это поможет анализировать обучение модели\n    const [predictions, cost] = forwardPropagation(model, xTrain, yTrain)\n    costHistory.push(cost)\n\n    \u002F\u002F Обратное распространение. Учимся на ошибках.\n    \u002F\u002F Эта функция возвращает небольшие модификации, которые нужно применить к параметрам 'w' и 'b',\n    \u002F\u002F чтобы сделать предсказания более точными\n    const [dW, dB] = backwardPropagation(predictions, xTrain, yTrain)\n\n    \u002F\u002F Модифицируем параметры нейрончика для повышения точности его предсказаний\n    nanoNeuron.w += alpha * dW\n    nanoNeuron.b += alpha * dB\n  }\n\n  \u002F\u002F Возвращаем историю обучения для анализа и визуализации\n  return costHistory\n}\n\n\u002F\u002F ===\n\u002F\u002F Создаем экземпляр модели.\n\u002F\u002F В данный момент нейрончику неизвестны значения параметров 'w' и 'b'.\n\u002F\u002F Устанавливаем их произвольно\nconst w = Math.random() \u002F\u002F например -&gt; 0.9492\nconst b = Math.random() \u002F\u002F например -&gt; 0.4570\nconst nanoNeuron = new NanoNeuron(w, b)\n\n\u002F\u002F Генерируем тренировочные и тестовые наборы данных\nconst [xTrain, yTrain, xTest, yTest] = generateDataSets()\n\n\u002F\u002F Обучаем модель небольшими шагами (0.0005) в течение 70000 эпох.\n\u002F\u002F Можете попробовать другие значения, они определены эмпирическим путем\nconst epochs = 70000\nconst alpha = 0.0005\nconst trainingCostHistory = trainModel(\n  nanoNeuron,\n  epochs,\n  alpha,\n  xTrain,\n  yTrain,\n)\n\n\u002F\u002F Проверим, как менялась стоимость в процессе обучения.\n\u002F\u002F Мы ожидаем, что стоимость после обучения будет значительно ниже, чем до него.\n\u002F\u002F Это будет означать, что наш нейрончик стал умнее. Но возможно и обратное\nconsole.log('Стоимость до обучения:', trainingCostHistory[0]) \u002F\u002F например -&gt; 4694.3335043\nconsole.log('Стоимость после обучения:', trainingCostHistory[epochs - 1]) \u002F\u002F например -&gt; 0.0000024\n\n\u002F\u002F Взглянем на параметры нейрончика, чтобы увидеть, чему он научился.\n\u002F\u002F Мы ожидаем, что значения параметров 'w' и 'b' модели будут близки к истинным значениям,\n\u002F\u002F которые используются в функции celsiusToFahrenheit() (w = 1.8 и b = 32)\nconsole.log(\n  'Параметры нейрончика:',\n  JSON.stringify({ w: nanoNeuron.w, b: nanoNeuron.b }, null, 2),\n) \u002F\u002F например -&gt; { w: 1.8, b: 31.99 }\n\n\u002F\u002F Оцениваем точность модели на тестовых данных, чтобы увидеть, насколько хорошо она обрабатывает неизвестные данные.\n\u002F\u002F Мы ожидаем, что стоимость тестовых предсказаний будет близкой к стоимости тренировочных предсказаний.\n\u002F\u002F Это будет означать, что нейрончик хорошо справляется как с тренировочными, так и с тестовыми данными\nconst [testPredictions, testCost] = forwardPropagation(nanoNeuron, xTest, yTest)\nconsole.log('Стоимость тестовых предсказаний:', testCost) \u002F\u002F например -&gt; 0.0000023\n\n\u002F\u002F После того, как \"ребенок\" хорошо показал себя в \"школе\" в процессе обучения и хорошо справился с тестовыми данными,\n\u002F\u002F мы можем назвать его \"умным\" и задать ему парочку вопросов\nconst tempInCelsius = 70\nconst customPrediction = nanoNeuron.predict(tempInCelsius)\nconsole.log(\n  `Нейрончик \"думает\", что ${tempInCelsius}°C в градусах Фаренгейта:`,\n  customPrediction,\n) \u002F\u002F -&gt; 158.0002\nconsole.log('Правильный ответ:', celsiusToFahrenheit(tempInCelsius)) \u002F\u002F -&gt; 158\n\u002F\u002F Очень близко! Нейрончик хорош, но не идеален, как все люди :)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EПропущенные концепции машинного обучения\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EСледующие концепции машинного обучения были пропущены или упрощены.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cem\u003EРазделение данных\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EОбычно, у нас имеется один большой набор данных. Часто он разделяется в пропорции 70\u002F30 для тренировочного\u002Fтестового набора (это зависит от количества примеров). Данные должны произвольно перемешиваться перед разделением. Если примеров много (например, миллионы), то пропорция может быть ближе к 90\u002F10 или даже к 95\u002F5.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cem\u003EСеть\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EКак правило, нейроны не используются по отдельности. Настоящая сила заключается в нейронных сетях. Сеть можно научить гораздо более сложным вещам. Наш нейрончик больше похож на линейную регрессию, чем на нейронную сеть.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cem\u003EНормализация\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПеред обучением входные данные лучше \u003Ca href=\"https:\u002F\u002Fwww.jeremyjordan.me\u002Fbatch-normalization\u002F\"\u003Eнормализовать\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cem\u003EВекторная реализация\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EДля сетей векторные (матричные) вычисления работают намного быстрее, чем циклы \u003Ccode\u003Efor\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cem\u003EМинимум функции стоимости\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EИспользуемая нами функция стоимости очень упрощена. Она должна содержать \u003Ca href=\"https:\u002F\u002Fstackoverflow.com\u002Fquestions\u002F32986123\u002Fwhy-the-cost-function-of-logistic-regression-has-a-logarithmic-expression\u002F32998675\"\u003Eлогарифмические компоненты\u003C\u002Fa\u003E. Обратите внимание, что изменение функции стоимости повлечет изменение ее производных, поэтому в обратном распространении также надо будет использовать другие формулы.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cem\u003EФункция активации\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EОбычно, результат нейрона пропускается через функцию активации, такую как \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%A1%D0%B8%D0%B3%D0%BC%D0%BE%D0%B8%D0%B4%D0%B0\"\u003Eсигмоида\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FRectifier_(neural_networks)\"\u003EReLU\u003C\u002Fa\u003E или аналоги.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch2 id=\"-metod-k-blizhayshih-sosedey\"\u003E❯ Метод k ближайших соседей\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EОписание\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_k_%D0%B1%D0%BB%D0%B8%D0%B6%D0%B0%D0%B9%D1%88%D0%B8%D1%85_%D1%81%D0%BE%D1%81%D0%B5%D0%B4%D0%B5%D0%B9\"\u003EВикипедия\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.geeksforgeeks.org\u002Fk-nearest-neighbours\u002F\"\u003EGeekForGeeks\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Farticles\u002F801885\u002F\"\u003EHabr (код на Python)\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.youtube.com\u002Fwatch?v=wsUqBJ0zXYE\"\u003EYouTube\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EМетод k ближайших соседей (k-nearest neighbors algorithm, k-NN) — метрический алгоритм для автоматической классификации объектов или регрессии. Он относится к методам машинного обучения с учителем (supervised).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВ случае использования метода для классификации объект присваивается тому классу, который является наиболее распространённым среди \u003Ccode\u003Ek\u003C\u002Fcode\u003E соседей данного элемента, классы которых уже известны. В случае использования метода для регрессии, объекту присваивается среднее значение по \u003Ccode\u003Ek\u003C\u002Fcode\u003E ближайшим к нему объектам, значения которых уже известны. Мы будем говорить в основном о классификации.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EАлгоритм может быть применим к выборкам с большим количеством атрибутов (многомерным). Для этого перед применением нужно определить функцию расстояния; классический вариант такой функции — \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%95%D0%B2%D0%BA%D0%BB%D0%B8%D0%B4%D0%BE%D0%B2%D0%B0_%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D0%BA%D0%B0\"\u003Eевклидова метрика\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fi_\u002F4h\u002Fql\u002Fi_4hqliq67go16a3922u6nv1b9q.png\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002Fi_\u002F4h\u002Fql\u002Fi_4hqliq67go16a3922u6nv1b9q.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fi_\u002F4h\u002Fql\u002Fi_4hqliq67go16a3922u6nv1b9q.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cem\u003EИспользование теоремы Пифагора для вычисления евклидова расстояния на плоскости\u003C\u002Fem\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EПринцип работы\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cul\u003E\n\u003Cli\u003Eпроверяется валидность данных и меток\u003C\u002Fli\u003E\n\u003Cli\u003Eвычисляется евклидово расстояние между тестовым (целевым) и всеми обучающими образцами\u003C\u002Fli\u003E\n\u003Cli\u003Eрасстояния вместе с классами сортируются в возрастающем порядке\u003C\u002Fli\u003E\n\u003Cli\u003Eвыбирается \u003Ccode\u003Ek\u003C\u002Fcode\u003E ближайших образцов (соседей), где число \u003Ccode\u003Ek\u003C\u002Fcode\u003E задается заранее (как правило, выбирается нечетное число — 3, 5 и т.д.)\u003C\u002Fli\u003E\n\u003Cli\u003Eитоговым прогнозом среди выбранных \u003Ccode\u003Ek\u003C\u002Fcode\u003E ближайших соседей будет мода в случае классификации и среднее арифметическое в случае регрессии\u003C\u002Fli\u003E\n\u003Cli\u003Eвозвращается наиболее похожий класс (для классификации) или среднее значение (для регрессии)\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВизуализация k-NN для лучшего понимания:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fi_\u002Fow\u002Fws\u002Fi_owwskzajk-3eyl7ok2cjl4dwg.png\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002Fi_\u002Fow\u002Fws\u002Fi_owwskzajk-3eyl7ok2cjl4dwg.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fi_\u002Fow\u002Fws\u002Fi_owwskzajk-3eyl7ok2cjl4dwg.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cem\u003EПример классификации методом k-NN: тестовый образец (зеленый круг) должен быть классифицирован как синий квадрат (класс 1) или как красный треугольник (класс 2); если k=3, то он классифицируется как 2-й класс, потому что внутри меньшего круга 2 треугольника и только 1 квадрат; если k=5, то он будет классифицирован как 1-й класс (3 квадрата против 2 треугольников внутри большего круга)\u003C\u002Fem\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЕще одна визуализация:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Far\u002Fgt\u002Fai\u002Fargtaipkmpfxghwvkauvjqfgl6w.gif\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Far\u002Fgt\u002Fai\u002Fargtaipkmpfxghwvkauvjqfgl6w.gif 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Far\u002Fgt\u002Fai\u002Fargtaipkmpfxghwvkauvjqfgl6w.gif 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cem\u003EЗдесь k = 7, поэтому тестовый образец классифицируется как зеленый треугольник\u003C\u002Fem\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EИ еще одна:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Frb\u002Fy6\u002Fcb\u002Frby6cbeenzlbh8y5mopfhz7aa9m.png\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002Frb\u002Fy6\u002Fcb\u002Frby6cbeenzlbh8y5mopfhz7aa9m.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Frb\u002Fy6\u002Fcb\u002Frby6cbeenzlbh8y5mopfhz7aa9m.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cem\u003EЗвездочкой обозначен целевой образец\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fy5\u002Fni\u002Fg9\u002Fy5nig9m7j9ss7n2frdfx_6r23ue.png\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002Fy5\u002Fni\u002Fg9\u002Fy5nig9m7j9ss7n2frdfx_6r23ue.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fy5\u002Fni\u002Fg9\u002Fy5nig9m7j9ss7n2frdfx_6r23ue.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cem\u003Ek=3\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fkn\u002Fnr\u002Fks\u002Fknnrksemprmbzb6bhzwynhhq1p0.png\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002Fkn\u002Fnr\u002Fks\u002Fknnrksemprmbzb6bhzwynhhq1p0.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fkn\u002Fnr\u002Fks\u002Fknnrksemprmbzb6bhzwynhhq1p0.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cem\u003Ek=10\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fyv\u002Fec\u002Flv\u002Fyveclvo5luhp1_raoevkpeixwde.png\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002Fyv\u002Fec\u002Flv\u002Fyveclvo5luhp1_raoevkpeixwde.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fyv\u002Fec\u002Flv\u002Fyveclvo5luhp1_raoevkpeixwde.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cem\u003Ek=20\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EКак видим, во всех трех случаях целевой образец классифицируется как синий круг.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EРеализация\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F\u002F algorithms\u002Fmachine-learning\u002Fk-nn.js\n\u002F\u002F Функция для вычисления евклидова расстояния\nimport euclideanDistance from '..\u002Fmath\u002Feuclidean-distance'\n\n\u002F** Функция принимает:\n * data   - данные\n * labels - метки\n * target - тестовый\u002Fцелевой образец\n * k      - количество ближайших соседей\n *\u002F\nexport default function kNN(data, labels, target, k = 3) {\n  if (!data || !labels || !target) {\n    throw new Error('Отсутствует обязательный параметр')\n  }\n\n  \u002F\u002F Вычисляем расстояние от `target` до каждой точки `data`.\n  \u002F\u002F Сохраняем расстояние и метку точки в списке\n  const distances = []\n\n  for (let i = 0; i &lt; data.length; i++) {\n    distances.push({\n      distance: euclideanDistance([data[i]], [target]),\n      label: labels[i],\n    })\n  }\n\n  \u002F\u002F Сортируем расстояния по возрастанию (от ближайшего к дальнему).\n  \u002F\u002F Берем `k` значений\n  const kn = distances\n    .sort((a, b) =&gt; {\n      if (a.distance === b.distance) {\n        return 0\n      }\n      return a.distance &lt; b.distance ? -1 : 1\n    })\n    .slice(0, k)\n\n  \u002F\u002F Считаем количество экземпляров каждого класса\n  const _labels = {}\n  let topClass = 0\n  let topClassCount = 0\n\n  for (let i = 0; i &lt; kn.length; i++) {\n    if (kn[i].label in _labels) {\n      _labels[kn[i].label] += 1\n    } else {\n      _labels[kn[i].label] = 1\n    }\n\n    if (_labels[kn[i].label] &gt; topClassCount) {\n      topClassCount = _labels[kn[i].label]\n      topClass = kn[i].label\n    }\n  }\n\n  \u002F\u002F Возвращает класс с наибольшим количеством экземпляров\n  return topClass\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EТесты:\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F\u002F algorithms\u002Fmachine-learning\u002F__tests__\u002Fk-nn.test.js\nimport kNN from '..\u002Fk-nn'\n\ndescribe('kNN', () =&gt; {\n  it('при неправильных данных должно выбрасываться исключение', () =&gt; {\n    expect(() =&gt; {\n      kNN()\n    }).toThrowError('Отсутствует обязательный параметр')\n  })\n\n  it('при неправильных метках должно выбрасываться исключение', () =&gt; {\n    const noLabels = () =&gt; {\n      kNN([[1, 1]])\n    }\n    expect(noLabels).toThrowError('Отсутствует обязательный параметр')\n  })\n\n  it('при отсутствии целевого образца должно выбрасываться исключение #1', () =&gt; {\n    const noClassification = () =&gt; {\n      kNN([[1, 1]], [1])\n    }\n    expect(noClassification).toThrowError('Отсутствует обязательный параметр')\n  })\n\n  it('при отсутствии целевого образца должно выбрасываться исключение #2', () =&gt; {\n    const inconsistent = () =&gt; {\n      kNN([[1, 1]], [1], [1])\n    }\n    expect(inconsistent).toThrowError('Матрицы имеют разную форму')\n  })\n\n  it('должен выполнить классификацию целевых образцов', () =&gt; {\n    let dataSet\n    let labels\n    let toClassify\n    let expectedClass\n\n    dataSet = [\n      [1, 1],\n      [2, 2],\n    ]\n    labels = [1, 2]\n    toClassify = [1, 1]\n    expectedClass = 1\n    expect(kNN(dataSet, labels, toClassify)).toBe(expectedClass)\n\n    dataSet = [\n      [1, 1],\n      [6, 2],\n      [3, 3],\n      [4, 5],\n      [9, 2],\n      [2, 4],\n      [8, 7],\n    ]\n    labels = [1, 2, 1, 2, 1, 2, 1]\n    toClassify = [1.25, 1.25]\n    expectedClass = 1\n    expect(kNN(dataSet, labels, toClassify)).toBe(expectedClass)\n\n    dataSet = [\n      [1, 1],\n      [6, 2],\n      [3, 3],\n      [4, 5],\n      [9, 2],\n      [2, 4],\n      [8, 7],\n    ]\n    labels = [1, 2, 1, 2, 1, 2, 1]\n    toClassify = [1.25, 1.25]\n    expectedClass = 2\n    expect(kNN(dataSet, labels, toClassify, 5)).toBe(expectedClass)\n  })\n\n  it('должен выполнить классификацию целевого образца с соседями на одинаковых расстояниях', () =&gt; {\n    const dataSet = [\n      [0, 0],\n      [1, 1],\n      [0, 2],\n    ]\n    const labels = [1, 3, 3]\n    const toClassify = [0, 1]\n    const expectedClass = 3\n    expect(kNN(dataSet, labels, toClassify)).toBe(expectedClass)\n  })\n\n  it('должен выполнить классификацию целевого образца с соседями в трехмерном пространстве', () =&gt; {\n    const dataSet = [\n      [0, 0, 0],\n      [0, 1, 1],\n      [0, 0, 2],\n    ]\n    const labels = [1, 3, 3]\n    const toClassify = [0, 0, 1]\n    const expectedClass = 3\n    expect(kNN(dataSet, labels, toClassify)).toBe(expectedClass)\n  })\n})\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЗапускаем тесты:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"bash\"\u003Enpm run test .\u002Falgorithms\u002Fmachine-learning\u002F__tests__\u002Fk-nn\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fzy\u002F4m\u002Fis\u002Fzy4misoszeia7nn7y1whwvv0h-a.png\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002Fzy\u002F4m\u002Fis\u002Fzy4misoszeia7nn7y1whwvv0h-a.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fzy\u002F4m\u002Fis\u002Fzy4misoszeia7nn7y1whwvv0h-a.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cbr\u002F\u003E\n\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch2 id=\"-metod-k-srednih\"\u003E❯ Метод k-средних\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EОписание\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_k-%D1%81%D1%80%D0%B5%D0%B4%D0%BD%D0%B8%D1%85\"\u003EВикипедия\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.geeksforgeeks.org\u002Fk-means-clustering-introduction\u002F\"\u003EGeekForGeeks\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Feducation.yandex.ru\u002Fhandbook\u002Fml\u002Farticle\u002Fklasterizaciya\"\u003EЯндекс.Образование — Кластеризация\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.youtube.com\u002Fwatch?v=8vCuR1AndH0\"\u003EYouTube\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EМетод k-средних (k-means) — наиболее популярный метод кластеризации. Он относится к методам машинного обучения без учителя (unsupervised).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EДействие алгоритма таково, что он стремится минимизировать суммарное квадратичное отклонение точек кластеров от центров этих кластеров:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fnr\u002Fc9\u002Fzb\u002Fnrc9zbxcz_p_01b2by8llzashbi.png\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002Fnr\u002Fc9\u002Fzb\u002Fnrc9zbxcz_p_01b2by8llzashbi.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fnr\u002Fc9\u002Fzb\u002Fnrc9zbxcz_p_01b2by8llzashbi.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cbr\u002F\u003E\n\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003Eгде \u003Ccode\u003Ek\u003C\u002Fcode\u003E — число кластеров, S\u003Csup\u003Ei\u003C\u002Fsup\u003E — полученные кластеры, \u003Ccode\u003Ei = 1, 2, ..., k\u003C\u002Fcode\u003E, а μ\u003Csup\u003Ei\u003C\u002Fsup\u003E — центры масс (центроиды) всех векторов \u003Ccode\u003Ex\u003C\u002Fcode\u003E из кластера S\u003Csup\u003Ei\u003C\u002Fsup\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EПринцип работы\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EАлгоритм разбивает множество элементов векторного пространства на заранее известное число кластеров \u003Ccode\u003Ek\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EОсновная идея заключается в том, что на каждой итерации перевычисляется центр масс для каждого кластера, полученного на предыдущем шаге, затем векторы разбиваются на кластеры вновь в соответствии с тем, какой из новых центров оказался ближе по выбранной метрике. Для вычисления схожести между центром масс и векторами данных часто используется \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%95%D0%B2%D0%BA%D0%BB%D0%B8%D0%B4%D0%BE%D0%B2%D0%B0_%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D0%BA%D0%B0\"\u003Eевклидова метрика\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fi_\u002F4h\u002Fql\u002Fi_4hqliq67go16a3922u6nv1b9q.png\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002Fi_\u002F4h\u002Fql\u002Fi_4hqliq67go16a3922u6nv1b9q.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fi_\u002F4h\u002Fql\u002Fi_4hqliq67go16a3922u6nv1b9q.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cem\u003EИспользование теоремы Пифагора для вычисления евклидова расстояния на плоскости\u003C\u002Fem\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EАлгоритм завершается, когда на какой-то итерации не происходит изменения внутрикластерного расстояния. Это происходит за конечное число итераций, так как количество возможных разбиений конечного множества конечно, а на каждом шаге суммарное квадратичное отклонение \u003Ccode\u003EV\u003C\u002Fcode\u003E уменьшается, поэтому зацикливание невозможно.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fu8\u002Fr_\u002Fje\u002Fu8r_je1xoj61zsekympel9fvy8c.png\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002Fu8\u002Fr_\u002Fje\u002Fu8r_je1xoj61zsekympel9fvy8c.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fu8\u002Fr_\u002Fje\u002Fu8r_je1xoj61zsekympel9fvy8c.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cem\u003EДействие алгоритма в двумерном случае. Начальные точки выбраны случайно\u003C\u002Fem\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПоследовательность шагов:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cul\u003E\n\u003Cli\u003Eпроверяется валидность\u002Fсогласованность данных\u003C\u002Fli\u003E\n\u003Cli\u003Eинициализируется \u003Ccode\u003Ek\u003C\u002Fcode\u003E центроидов с начальными\u002Fпроизвольными \u003Ccode\u003Ek\u003C\u002Fcode\u003E точками\u003C\u002Fli\u003E\n\u003Cli\u003Eвычисляется расстояние каждой точки до каждого центроида\u003C\u002Fli\u003E\n\u003Cli\u003Eкаждой точке присваивается значение метки ближайшего кластера\u003C\u002Fli\u003E\n\u003Cli\u003Eвычисляется центроид каждого кластера на основе содержащихся в нем точек\u003C\u002Fli\u003E\n\u003Cli\u003Eцикл повторяется до тех пор, пока положение центроидов не перестанет меняться\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВизуализация для лучшего понимания:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fgd\u002F-u\u002F7b\u002Fgd-u7b4un33ikvsst7yfd2klyfi.gif\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fgd\u002F-u\u002F7b\u002Fgd-u7b4un33ikvsst7yfd2klyfi.gif 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fgd\u002F-u\u002F7b\u002Fgd-u7b4un33ikvsst7yfd2klyfi.gif 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cbr\u002F\u003E\n\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EПроблемы k-средних\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cul\u003E\n\u003Cli\u003Eне гарантируется достижение глобального минимума суммарного квадратичного отклонения \u003Ccode\u003EV\u003C\u002Fcode\u003E, а только одного из локальных минимумов\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fnj\u002Fo8\u002Fog\u002Fnjo8og0hl035vwkod3l0tjiskk0.png\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002Fnj\u002Fo8\u002Fog\u002Fnjo8og0hl035vwkod3l0tjiskk0.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fnj\u002Fo8\u002Fog\u002Fnjo8og0hl035vwkod3l0tjiskk0.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cem\u003EТипичный пример сходимости метода k-средних к локальному минимуму. В этом примере результат кластеризации указанным методом противоречит очевидной кластерной структуре множества данных. Маленькими кружками обозначены точки данных, четырехлучевые звезды — центроиды. Принадлежащие им точки данных окрашены в тот же цвет\u003C\u002Fem\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cul\u003E\n\u003Cli\u003Eрезультат зависит от выбора исходных центров кластеров, их оптимальный выбор неизвестен\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002F2w\u002Fk8\u002Fmb\u002F2wk8mbjs5v5ywihp4ddm1boqsig.png\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002F2w\u002Fk8\u002Fmb\u002F2wk8mbjs5v5ywihp4ddm1boqsig.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002F2w\u002Fk8\u002Fmb\u002F2wk8mbjs5v5ywihp4ddm1boqsig.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cem\u003EРезультат кластеризации методом k-средних для ирисов Фишера и реальные виды ирисов, визуализированные с помощью ELKI. Центры кластеров отмечены с помощью крупных, полупрозрачных маркеров\u003C\u002Fem\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cul\u003E\n\u003Cli\u003Eчисло кластеров надо знать заранее\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EПрименение\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВ алгоритмах глубокого обучения метод k-средних иногда применяют не по прямому назначению (классификация разбивкой на кластеры), а для создания так называемых фильтров (ядер свертки, словарей). Например, для распознавания изображений в алгоритм k-средних подают небольшие случайные кусочки изображений обучающей выборки, допустим, размером \u003Ccode\u003E16х16\u003C\u002Fcode\u003E в виде линейного вектора, каждый элемент которого кодирует яркость своей точки. Количество кластеров \u003Ccode\u003Ek\u003C\u002Fcode\u003E задается большим, например \u003Ccode\u003E256\u003C\u002Fcode\u003E. Обученный метод k-средних при определенных условиях вырабатывает при этом центры кластеров (центроиды), которые представляют собой удобные базисы, на которые можно разложить любое входное изображение. Такие \"обученные\" центроиды в дальнейшем используют в качестве фильтров, например для сверточной нейронной сети в качестве ядер свертки или других аналогичных систем машинного зрения.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EРеализация\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F\u002F algorithms\u002Fmachine-learning\u002Fk-means.js\n\u002F\u002F Утилиты для матричных вычислений\nimport * as matrix from '..\u002Fmath\u002Fmatrix'\n\u002F\u002F Функция для вычисления евклидова расстояния\nimport euclideanDistance from '..\u002Fmath\u002Feuclidean-distance'\n\n\u002F** Функция принимает:\n * data - данные\n * k    - количество кластеров\n *\u002F\nexport default function kMeans(data, k = 1) {\n  if (!data) {\n    throw new Error('Отсутствуют данные для классификации')\n  }\n\n  \u002F\u002F Количество измерений\n  const dimension = data[0].length\n  \u002F\u002F Центроиды\n  const centroids = data.slice(0, k)\n\n  \u002F\u002F Матрица расстояний от каждой точки до каждого центроида\n  const distances = matrix.zeros([data.length, k])\n\n  \u002F\u002F Классы векторных точек данных.\n  \u002F\u002F - 1 означает, что класс еще не назначен\n  const classes = new Array(data.length).fill(-1)\n\n  \u002F\u002F Индикатор итерации\n  let iterate = true\n  while (iterate) {\n    iterate = false\n\n    \u002F\u002F Вычисляем и сохраняем расстояние каждой точки от каждого центроида\n    for (let i = 0; i &lt; data.length; i++) {\n      for (let j = 0; j &lt; k; j++) {\n        distances[i][j] = euclideanDistance([centroids[j]], [data[i]])\n      }\n\n      \u002F\u002F Присваиваем метку ближайшего кластера каждой точке\n      const closestClusterIndex = distances[i].indexOf(\n        Math.min(...distances[i]),\n      )\n\n      \u002F\u002F Проверяем, был ли класс точки изменен\n      \u002F\u002F и нужно ли повторить итерацию\n      if (classes[i] !== closestClusterIndex) {\n        iterate = true\n      }\n\n      classes[i] = closestClusterIndex\n    }\n\n    \u002F\u002F Пересчитываем положение центроида кластера\n    \u002F\u002F на основе содержащихся в нем точек\n    for (let i = 0; i &lt; k; i++) {\n      \u002F\u002F Сбрасываем координаты центроида, поскольку нам нужно их пересчитать\n      centroids[i] = new Array(dimension).fill(0)\n      let clusterSize = 0\n      for (let j = 0; j &lt; data.length; j++) {\n        if (classes[j] === i) {\n          \u002F\u002F Регистрируем еще одну точку текущего кластера\n          clusterSize += 1\n          for (let l = 0; l &lt; dimension; l++) {\n            centroids[i][l] += data[j][l]\n          }\n        }\n      }\n\n      \u002F\u002F Вычисляем среднее значение каждой координаты центроида\n      for (let j = 0; j &lt; dimension; j++) {\n        centroids[i][j] = parseFloat(\n          Number(centroids[i][j] \u002F clusterSize).toFixed(2),\n        )\n      }\n    }\n  }\n\n  return classes\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EТесты:\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F\u002F algorithms\u002Fmachine-learning\u002F__tests__\u002Fk-means.test.js\nimport KMeans from '..\u002Fk-means'\n\ndescribe('kMeans', () =&gt; {\n  it('при невалидных данных должно выбрасываться исключение', () =&gt; {\n    expect(() =&gt; {\n      KMeans()\n    }).toThrowError('Отсутствуют данные для классификации')\n  })\n\n  it('при несогласованных данных должно выбрасываться исключение', () =&gt; {\n    expect(() =&gt; {\n      KMeans([[1, 2], [1]], 2)\n    }).toThrowError('Матрицы имеют разную форму')\n  })\n\n  it('должен выполнить кластеризацию', () =&gt; {\n    const data = [\n      [1, 1],\n      [6, 2],\n      [3, 3],\n      [4, 5],\n      [9, 2],\n      [2, 4],\n      [8, 7],\n    ]\n    const k = 2\n    const expectedClusters = [0, 1, 0, 1, 1, 0, 1]\n    expect(KMeans(data, k)).toEqual(expectedClusters)\n\n    expect(\n      KMeans(\n        [\n          [0, 0],\n          [0, 1],\n          [10, 10],\n        ],\n        2,\n      ),\n    ).toEqual([0, 0, 1])\n  })\n\n  it('должен выполнить кластеризацию точек на одинаковых расстояниях', () =&gt; {\n    const dataSet = [\n      [0, 0],\n      [1, 1],\n      [2, 2],\n    ]\n    const k = 3\n    const expectedCluster = [0, 1, 2]\n    expect(KMeans(dataSet, k)).toEqual(expectedCluster)\n  })\n\n  it('должен выполнить кластеризацию точек в трехмерном пространстве', () =&gt; {\n    const dataSet = [\n      [0, 0, 0],\n      [0, 1, 0],\n      [2, 0, 2],\n    ]\n    const k = 2\n    const expectedCluster = [1, 1, 0]\n    expect(KMeans(dataSet, k)).toEqual(expectedCluster)\n  })\n})\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЗапускаем тесты:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"bash\"\u003Enpm run test .\u002Falgorithms\u002Fmachine-learning\u002F__tests__\u002Fk-means\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002F4z\u002Fm6\u002Fqc\u002F4zm6qcwanifvkkij-ftmlkuzpgk.png\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002F4z\u002Fm6\u002Fqc\u002F4zm6qcwanifvkkij-ftmlkuzpgk.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002F4z\u002Fm6\u002Fqc\u002F4zm6qcwanifvkkij-ftmlkuzpgk.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cbr\u002F\u003E\n\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch1 id=\"-statistika\"\u003E❯ Статистика\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\n\u003Ch2 id=\"-vzveshennaya-proizvolnaya-vyborka\"\u003E❯ Взвешенная произвольная выборка\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fe9\u002F94\u002Fi2\u002Fe994i2o7uknxvrwxlxocf8amr9k.png\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002Fe9\u002F94\u002Fi2\u002Fe994i2o7uknxvrwxlxocf8amr9k.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fe9\u002F94\u002Fi2\u002Fe994i2o7uknxvrwxlxocf8amr9k.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cbr\u002F\u003E\n\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EОписание\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fru.statisticseasily.com\u002Fglossario\u002Fwhat-is-weighted-random-sampling\u002F\"\u003EЧто такое взвешенная случайная выборка?\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EДопустим, у нас есть список элементов. Элемент может быть чем угодно. Например, у нас может быть список фруктов и овощей, которые мы любим кушать: \u003Ccode\u003E[ '🍌', '🍎', '🥕' ]\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EСписок весов представляет вес (вероятность выбора, важность) каждого элемента. Веса — это числа. Например, веса \u003Ccode\u003E[3, 7, 1]\u003C\u002Fcode\u003E означают следующее:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cul\u003E\n\u003Cli\u003Eмы выбираем яблоко чаще всего (\u003Ccode\u003E7\u003C\u002Fcode\u003E из \u003Ccode\u003E3+7+1=11\u003C\u002Fcode\u003E раз)\u003C\u002Fli\u003E\n\u003Cli\u003Eбанан мы выбираем менее часто (\u003Ccode\u003E3\u003C\u002Fcode\u003E из \u003Ccode\u003E11\u003C\u002Fcode\u003E раз)\u003C\u002Fli\u003E\n\u003Cli\u003Eморковку мы не любим, поэтому выбираем ее редко (\u003Ccode\u003E1\u003C\u002Fcode\u003E из \u003Ccode\u003E11\u003C\u002Fcode\u003E раз)\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\n\u003Cblockquote\u003EЕсли говорить в терминах вероятности, то веса должны быть представлены числами с плавающей запятой, сумма которых дает \u003Ccode\u003E1\u003C\u002Fcode\u003E (например, \u003Ccode\u003E[0.1, 0.5, 0.2, 0.2]\u003C\u002Fcode\u003E).\u003C\u002Fblockquote\u003E\u003Cp\u003EВзвешенная произвольная выборка (weighted random) — это функция, которая возвращает произвольный элемент списка с учетом его веса, поэтому элементы с большим весом выбирается чаще.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПример интерфейса функции:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econst items =   [ '🍌', '🍎', '🥕' ];\nconst weights = [  3,    7,    1  ];\n\nfunction weightedRandom(items, weights) {\n  \u002F\u002F Реализация...\n}\n\nconst nextSnackToEat = weightedRandom(items, weights); \u002F\u002F вероятнее всего будет '🍎'\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EПрименение\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cul\u003E\n\u003Cli\u003Eв \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%93%D0%B5%D0%BD%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC\"\u003Eгенетической алгоритме\u003C\u002Fa\u003E взвешенная произвольная выборка используется на стадии выборки, когда нам нужно выбрать наиболее приспособленных\u002Fсильных особей на основе оценки их приспособленности для спаривания и создания следующего более сильного поколения. См. \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fusers\u002Faio350\u002Farticles\u002Fpage2\u002F\"\u003EСамопаркующийся авто за 500 строк кода\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003Eв \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%A0%D0%B5%D0%BA%D1%83%D1%80%D1%80%D0%B5%D0%BD%D1%82%D0%BD%D0%B0%D1%8F_%D0%BD%D0%B5%D0%B9%D1%80%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B5%D1%82%D1%8C\"\u003Eрекуррентных нейронных сетях (RNN)\u003C\u002Fa\u003E при принятии решения о выборе следующей буквы (для формирования предложения) на основе вероятности следующей буквы. См. Jupyter Notebook \u003Ca href=\"https:\u002F\u002Fnbviewer.org\u002Fgithub\u002Ftrekhleb\u002Fmachine-learning-experiments\u002Fblob\u002Fmaster\u002Fexperiments\u002Frecipe_generation_rnn\u002Frecipe_generation_rnn.ipynb\"\u003ERecipe Generation using Recurrent Neural Network (RNN)\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003Eв \u003Ca href=\"https:\u002F\u002Fdocs.nginx.com\u002Fnginx\u002Fadmin-guide\u002Fload-balancer\u002Fhttp-load-balancer\u002F\"\u003Eбалансировщике нагрузки Nginx\u003C\u002Fa\u003E для более частой отправки запросов на сервер с более высоким весом\u003C\u002Fli\u003E\n\u003Cli\u003Eво многих других областях\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EАлгоритм\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EСамый простой подход состоит в следующем:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Col\u003E\n\u003Cli\u003EДублируем каждый элемент в соответствии с его весом.\u003C\u002Fli\u003E\n\u003Cli\u003EВыбираем произвольный элемент.\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНапример, для наших фруктов и овощей можно сгенерировать следующий список:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econst items =   [ '🍌', '🍎', '🥕' ];\nconst weights = [  3,    7,    1  ];\n\n\u002F\u002F Дублируем элементы на основе их весов\nconst weightedItems = [\n  '🍌', '🍌', '🍌',\n  '🍎', '🍎', '🍎', '🍎', '🍎', '🍎', '🍎',\n  '🥕',\n];\n\n\u002F\u002F Теперь просто извлекаем произвольный элемент из `weightedItems`\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EОднако, как вы можете видеть, такой подход требует большого количества памяти в случае, когда у нас много элементов для повторения. Например, повторение строки \u003Ccode\u003E\"some-random-string\"\u003C\u002Fcode\u003E 10 млн раз потребует выделения около \u003Ccode\u003E180 Мб\u003C\u002Fcode\u003E памяти только для массива \u003Ccode\u003EweightedItems\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EБолее эффективный подход состоит в следующем:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Col\u003E\n\u003Cli\u003EГотовим список совокупных весов для каждого элемента (список \u003Ccode\u003EcumulativeWeights\u003C\u002Fcode\u003E будет иметь такую же длину, как исходный список \u003Ccode\u003Eweights\u003C\u002Fcode\u003E). В нашем случае он будет выглядеть так: \u003Ccode\u003EcumulativeWeights = [3, 3 + 7, 3 + 7 + 1] = [3, 10, 11]\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003EВыбираем произвольное число в диапазоне от \u003Ccode\u003E0\u003C\u002Fcode\u003E до наибольшего совокупного веса. В нашем случае таким диапазоном будет \u003Ccode\u003E[0...11]\u003C\u002Fcode\u003E. Допустим, мы получили \u003Ccode\u003ErandomNumber = 8\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003EПеребираем \u003Ccode\u003EcumulativeWeights\u003C\u002Fcode\u003E слева направо и берем первый элемент, который больше или равен \u003Ccode\u003ErandomNumber\u003C\u002Fcode\u003E. Индекс такого элемента используется для выбора элемента из списка \u003Ccode\u003Eitems\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EОсновная идея данного подхода состоит в том, что более высокие веса будут \"занимать\" больше числового пространства. Таким образом, более высока вероятность выбора произвольного числа из \"числовой группы более высокого веса\".\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econst weights =           [3, 7,  1 ];\nconst cumulativeWeights = [3, 10, 11];\n\n\u002F\u002F `cumulativeWeights` можно представить так\nconst pseudoCumulativeWeights = [\n  1, 2, 3,               \u002F\u002F &lt;-- 3 числа\n  4, 5, 6, 7, 8, 9, 10,  \u002F\u002F &lt;-- 7 чисел\n  11,                    \u002F\u002F &lt;-- 1 число\n];\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EРеализация\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F\u002F algorithms\u002Fstatistics\u002Fweighted-random.js\n\u002F**\n * Возвращает произвольный элемент на основе его веса.\n * Элементы с более высоким весом выбираются чаще (с большей вероятностью).\n *\n * Например:\n * - items = ['banana', 'orange', 'apple']\n * - weights = [0, 0.2, 0.8]\n * - weightedRandom(items, weights) в 80% случаев будет возвращать 'apple',\n * в 20% случаев - 'orange' и никогда - 'banana' (поскольку вероятность его выбора равна 0%)\n *\n * @param {any[]} items\n * @param {number[]} weights\n * @returns {{item: any, index: number}}\n *\u002F\nexport default function weightedRandom(items, weights) {\n  if (!items.length || !weights.length) {\n    throw new Error('Элементы\u002Fвеса не должны быть пустыми')\n  }\n  if (items.length !== weights.length) {\n    throw new Error('Массивы элементов и весов должны иметь одинаковую длину')\n  }\n\n  \u002F\u002F Готовим массив совокупных весов.\n  \u002F\u002F Например:\n  \u002F\u002F - weights = [1, 4, 3]\n  \u002F\u002F - cumulativeWeights = [1, 5, 8]\n  const cumulativeWeights = []\n  for (let i = 0; i &lt; weights.length; i++) {\n    cumulativeWeights[i] = weights[i] + (cumulativeWeights[i - 1] || 0)\n  }\n\n  \u002F\u002F Получаем произвольное число в диапазоне [0...sum(weights)].\n  \u002F\u002F Например:\n  \u002F\u002F - weights = [1, 4, 3]\n  \u002F\u002F - maxCumulativeWeight = 8\n  \u002F\u002F - диапазон произвольного числа - [0...8]\n  const maxCumulativeWeight = cumulativeWeights.at(-1)\n  const random = Math.random() * maxCumulativeWeight\n\n  \u002F\u002F Извлекаем произвольный элемент на основе его веса.\n  \u002F\u002F Элементы с более высоким весом выбираются чаще\n  const index = cumulativeWeights.findIndex((cumulativeWeight) =&gt; {\n    return cumulativeWeight &gt;= random\n  })\n  const item = items[index]\n\n  return {\n    item,\n    index,\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EТесты:\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport weightedRandom from '..\u002Fweighted-random'\n\ndescribe('weightedRandom', () =&gt; {\n  it('при передаче пустого массива элементов или весов должно выбрасываться исключение', () =&gt; {\n    const getWeightedRandomWithInvalidInputs = () =&gt; {\n      weightedRandom([], [])\n    }\n    expect(getWeightedRandomWithInvalidInputs).toThrow(\n      'Элементы\u002Fвеса не должны быть пустыми',\n    )\n  })\n\n  it('при несовпадении количества элементов и весов должно выбрасываться исключение', () =&gt; {\n    const getWeightedRandomWithInvalidInputs = () =&gt; {\n      weightedRandom(['a', 'b', 'c'], [10, 0])\n    }\n    expect(getWeightedRandomWithInvalidInputs).toThrow(\n      'Массивы элементов и весов должны иметь одинаковую длину',\n    )\n  })\n\n  it('должен правильно выполнять взвешенную произвольную выборку в простых случаях', () =&gt; {\n    expect(weightedRandom(['a', 'b', 'c'], [1, 0, 0])).toEqual({\n      index: 0,\n      item: 'a',\n    })\n    expect(weightedRandom(['a', 'b', 'c'], [0, 1, 0])).toEqual({\n      index: 1,\n      item: 'b',\n    })\n    expect(weightedRandom(['a', 'b', 'c'], [0, 0, 1])).toEqual({\n      index: 2,\n      item: 'c',\n    })\n    expect(weightedRandom(['a', 'b', 'c'], [0, 1, 1])).not.toEqual({\n      index: 0,\n      item: 'a',\n    })\n    expect(weightedRandom(['a', 'b', 'c'], [1, 0, 1])).not.toEqual({\n      index: 1,\n      item: 'b',\n    })\n    expect(weightedRandom(['a', 'b', 'c'], [1, 1, 0])).not.toEqual({\n      index: 2,\n      item: 'c',\n    })\n  })\n\n  it('должен правильно выполнять взвешенную произвольную выборку', () =&gt; {\n    \u002F\u002F Количество выборок\n    const ATTEMPTS_NUM = 1000\n    \u002F\u002F Погрешность количества выборок элемента.\n    \u002F\u002F Например, если мы хотим, чтобы элемент 'a' выбирался 300 раз из 1000 (30%),\n    \u002F\u002F тогда 267 раз является приемлемым, поскольку это больше 250 (300 - 50)\n    \u002F\u002F и меньше 350 (300 + 50)\n    const THRESHOLD = 50\n\n    const items = ['a', 'b', 'c'] \u002F\u002F значения элементов неважны\n    const weights = [0.1, 0.3, 0.6]\n\n    const counter = []\n    for (let i = 0; i &lt; ATTEMPTS_NUM; i += 1) {\n      const randomItem = weightedRandom(items, weights)\n      if (!counter[randomItem.index]) {\n        counter[randomItem.index] = 1\n      } else {\n        counter[randomItem.index] += 1\n      }\n    }\n\n    for (let itemIndex = 0; itemIndex &lt; items.length; itemIndex += 1) {\n      \u002F*\n        Элемент под индексом 0 должен выбираться 100 раз (в идеале)\n        или, учитывая порог, [100 - 50, 100 + 50] раз.\n\n        Элемент под индексом 1 должен выбираться 300 раз (в идеале)\n        или, учитывая порог, [300 - 50, 300 + 50] раз.\n\n        Элемент под индексом 2 должен выбираться 600 раз (в идеале)\n        или, учитывая порог, [600 - 50, 600 + 50] раз\n       *\u002F\n      expect(counter[itemIndex]).toBeGreaterThan(\n        ATTEMPTS_NUM * weights[itemIndex] - THRESHOLD,\n      )\n      expect(counter[itemIndex]).toBeLessThan(\n        ATTEMPTS_NUM * weights[itemIndex] + THRESHOLD,\n      )\n    }\n  })\n})\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЗапускаем тесты:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"bash\"\u003Enpm run test .\u002Falgorithms\u002Fstatistics\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fb4\u002Fvf\u002Fm-\u002Fb4vfm-aglfggwqjagfsl9g-uqsq.png\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002Fb4\u002Fvf\u002Fm-\u002Fb4vfm-aglfggwqjagfsl9g-uqsq.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002Fb4\u002Fvf\u002Fm-\u002Fb4vfm-aglfggwqjagfsl9g-uqsq.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cbr\u002F\u003E\n\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНа сегодня это все, друзья. Увидимся в следующей части.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Chr\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cblockquote\u003E\u003Ca href=\"https:\u002F\u002Ft.me\u002Ftimewebru\"\u003E\u003Cb\u003EНовости, обзоры продуктов и конкурсы от команды Timeweb.Cloud — в нашем Telegram-канале\u003C\u002Fb\u003E\u003C\u002Fa\u003E \u003Cb\u003E↩\u003C\u002Fb\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Ftimeweb.cloud\u002F?utm_source=habr&amp;utm_medium=banner&amp;utm_campaign=promo\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002F6r\u002F9j\u002Fsr\u002F6r9jsrljpzsgcfyj1jjupubij5e.png\" sizes=\"(max-width: 780px) 100vw, 50vw\" srcset=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780\u002Fwebt\u002F6r\u002F9j\u002Fsr\u002F6r9jsrljpzsgcfyj1jjupubij5e.png 780w,&#10;       https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fwebt\u002F6r\u002F9j\u002Fsr\u002F6r9jsrljpzsgcfyj1jjupubij5e.png 781w\" loading=\"lazy\" decode=\"async\"\u002F\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"timeweb_статьи"},{"titleHtml":"javascript"},{"titleHtml":"algorithms"},{"titleHtml":"data structures"},{"titleHtml":"алгоритмы"},{"titleHtml":"структуры данных"},{"titleHtml":"machine learning"},{"titleHtml":"statistics"},{"titleHtml":"машинное обучение"},{"titleHtml":"статистика"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fma\u002Fpo\u002Flv\u002Fmapolvqq4uunxfqoaviv3g9km9y.jpeg","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fma\u002Fpo\u002Flv\u002Fmapolvqq4uunxfqoaviv3g9km9y.jpeg","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompanies\\\u002Ftimeweb\\\u002Farticles\\\u002F903842\\\u002F\"},\"headline\":\"JavaScript: структуры данных и алгоритмы. Часть 11\",\"datePublished\":\"2025-05-06T13:05:09+03:00\",\"dateModified\":\"2025-05-06T13:37:43+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Igor Agapov\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Привет, друзья! В этой серии статей мы разбираем структуры данных и алгоритмы, представленные в этом замечательном репозитории. Это одиннадцатая часть серии. С...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompanies\\\u002Ftimeweb\\\u002Farticles\\\u002F903842\\\u002F#post-content-body\",\"about\":[\"c_timeweb\",\"h_javascript\",\"h_algorithms\",\"h_machine_learning\",\"h_statistics\",\"f_develop\",\"f_popsci\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F903842\\\u002F73d84677204d0ca32f3939aa62754a21\\\u002F\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fma\\\u002Fpo\\\u002Flv\\\u002Fmapolvqq4uunxfqoaviv3g9km9y.jpeg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002F_g\\\u002Fvw\\\u002Foh\\\u002F_gvwohoerz92tp_vet1rqqkwpuc.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fjc\\\u002F9j\\\u002Fh2\\\u002Fjc9jh2sfgrprioxjlybno6wu7k0.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002F_t\\\u002Fln\\\u002Fsz\\\u002F_tlnsz_p-p1dnornwgpazuttcdo.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002F4t\\\u002F53\\\u002F5d\\\u002F4t535dwgswdm5a4lkyivyqobkte.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fj8\\\u002Flu\\\u002F4n\\\u002Fj8lu4nhjzvzkzbkypc8azhqlepi.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fkc\\\u002Frf\\\u002Fhb\\\u002Fkcrfhb350xpq2alm_jq9ulcb0z8.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fi_\\\u002F4h\\\u002Fql\\\u002Fi_4hqliq67go16a3922u6nv1b9q.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fi_\\\u002Fow\\\u002Fws\\\u002Fi_owwskzajk-3eyl7ok2cjl4dwg.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Far\\\u002Fgt\\\u002Fai\\\u002Fargtaipkmpfxghwvkauvjqfgl6w.gif\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Frb\\\u002Fy6\\\u002Fcb\\\u002Frby6cbeenzlbh8y5mopfhz7aa9m.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fy5\\\u002Fni\\\u002Fg9\\\u002Fy5nig9m7j9ss7n2frdfx_6r23ue.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fkn\\\u002Fnr\\\u002Fks\\\u002Fknnrksemprmbzb6bhzwynhhq1p0.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fyv\\\u002Fec\\\u002Flv\\\u002Fyveclvo5luhp1_raoevkpeixwde.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fzy\\\u002F4m\\\u002Fis\\\u002Fzy4misoszeia7nn7y1whwvv0h-a.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fnr\\\u002Fc9\\\u002Fzb\\\u002Fnrc9zbxcz_p_01b2by8llzashbi.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fu8\\\u002Fr_\\\u002Fje\\\u002Fu8r_je1xoj61zsekympel9fvy8c.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fgd\\\u002F-u\\\u002F7b\\\u002Fgd-u7b4un33ikvsst7yfd2klyfi.gif\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fnj\\\u002Fo8\\\u002Fog\\\u002Fnjo8og0hl035vwkod3l0tjiskk0.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002F2w\\\u002Fk8\\\u002Fmb\\\u002F2wk8mbjs5v5ywihp4ddm1boqsig.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002F4z\\\u002Fm6\\\u002Fqc\\\u002F4zm6qcwanifvkkij-ftmlkuzpgk.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fe9\\\u002F94\\\u002Fi2\\\u002Fe994i2o7uknxvrwxlxocf8amr9k.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fb4\\\u002Fvf\\\u002Fm-\\\u002Fb4vfm-aglfggwqjagfsl9g-uqsq.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002F6r\\\u002F9j\\\u002Fsr\\\u002F6r9jsrljpzsgcfyj1jjupubij5e.png\"]}","metaDescription":"Привет, друзья! В этой серии статей мы разбираем структуры данных и алгоритмы, представленные в этом замечательном репозитории . Это одиннадцатая часть серии. Сегодня мы рассмотрим несколько простых,...","mainImageUrl":null,"amp":false,"customTrackerLinks":[]},"polls":[],"commentsEnabled":{"status":true,"reason":null},"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"hasPinnedComments":false,"format":"review","banner":null,"multiwidget":null,"multiwidgetUuid":null,"readingTime":25,"complexity":"medium","isEditorial":false,"allowedFeatures":{"isTestTargetAllow":true}}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"postReasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"viewedPosts":[],"myFeedFilter":{"complexity":"all","score":"all","types":["articles","posts","news"]},"myFeedIsApplyFilters":false,"myFeedIsForce":false,"karma":{"userReasonsList":null}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":""},"comments":{"articleComments":{},"articlePinnedComments":{},"searchCommentsResults":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":"","idempotenceKey":""}},"companies":{"companyRefs":{"timeweb":{"alias":"timeweb","imageUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fcompany\u002F7dd\u002Fba1\u002F4f4\u002F7ddba14f4fc46943da7d3bbadc46b55a.png","titleHtml":"Timeweb Cloud","descriptionHtml":"То самое облако","relatedData":null,"statistics":{"subscribersCount":22491,"rating":1524.98,"invest":null,"postsCount":1682,"threadsCount":36,"newsCount":26,"vacanciesCount":0,"employeesCount":4,"careerRating":null},"foundationDate":{"year":"2006","month":"05","day":"25"},"location":{"city":{"id":"447733","title":"Санкт-Петербург"},"region":{"id":"1948","title":"Санкт-Петербург и область"},"country":{"id":"168","title":"Россия"}},"siteUrl":"https:\u002F\u002Ftimeweb.cloud\u002F","staffNumber":"201–500 человек","registrationDate":"2011-08-11T14:17:04+00:00","representativeUser":{"alias":"Timeweb_Cloud","fullname":"Timeweb Cloud"},"contacts":[],"settings":{"analyticsSettings":[{"type":"ym","trackingId":"96525627"}],"branding":null,"status":"active","isStartup":false,"hasActivePolls":false,"shouldShowHabrAds":true},"metadata":{"titleHtml":"Timeweb Cloud, Санкт-Петербург - То самое облако с 25 мая 2006 г.","title":"Timeweb Cloud, Санкт-Петербург - То самое облако с 25 мая 2006 г.","keywords":["timeweb_статьи","искусственный интеллект","игры","timeweb_статьи_выходного_дня","timeweb_статьи_перевод","нейросети","openai","javascript","react","react.js","дайджест","grok","кино"],"descriptionHtml":"1 682 статьи от авторов компании Timeweb Cloud","description":"1 682 статьи от авторов компании Timeweb Cloud"},"aDeskSettings":null,"careerAlias":"hrtimewebru","schoolAlias":null}},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"multiwidgets":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"multiwidgetLoading":false,"vacancies":{},"companiesGalleries":{},"companiesBanners":{},"companiesLandingVacancies":{},"companiesTechnologies":{},"workplaceInfo":null},"companyAdmin":{"companyInfo":null,"companyInfoLoading":false,"faqArticles":null,"brandingPreviewImageUrl":null,"jivoStatus":0,"adminNotifications":null,"availableInvitesCount":{}},"companyAdd":{"currentStep":"","stepsData":{},"uncompletedSteps":[],"isStepLoading":true,"isStepCommitting":false,"isInitialized":false,"agreementContent":""},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"pagesCount":0},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":true},"fixedBanner":{"isArticleStickyPanelVisible":false,"isArticleStickyPanelAtTheBottom":false,"isFixedBannerVisible":false,"isStickyPanelIconsHidden":false},"flows":{"updates":{}},"global":{"isPwa":false,"device":"desktop","isHabrCom":true,"requestId":"4321d1b455414f1f83674e16a8ed27bc"},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"welcomePage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"query":{},"pathname":"\u002Fru\u002Fcompanies\u002Ftimeweb\u002Farticles\u002F903842\u002F","path":"\u002Fru\u002Fcompanies\u002Ftimeweb\u002Farticles\u002F903842\u002F","href":"\u002Fru\u002Fcompanies\u002Ftimeweb\u002Farticles\u002F903842\u002F"}},"me":{"user":null,"uuid":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null,"userUpdates":{"feeds":{"newPostsCount":null,"newThreadsCount":null,"newNewsCount":null,"newCount":null},"conversationUnreadCount":0},"features":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"onboarding":{"currentStep":null,"stepsData":{},"stepsErrors":{},"completedSteps":[],"isStepCommitting":false,"isCommitDisabled":true},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{"courses":"project-block-company-article"}},"promoData":{"isLoading":false,"hasLoaded":false,"featurer":null,"megaposts":null,"promoLinks":null,"promoPosts":null,"sticker":null},"publicationStatistics":{"statsInfo":{},"statsFunnels":{},"statsGraph":{},"defaultSuggest":{},"suggest":{},"timeTracker":{},"isTrackingActivity":false,"isUserActive":true,"otherPublicationStats":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"search":{"searchQueryError":null},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":true,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"stories":{"stories":null},"technotext":{"years":[],"technotextDocForNominees":null,"technotextDocForWinners":null,"technotextInfo":{},"technotextInfoLoading":false,"technotextWinners":{},"technotextWinnersLoading":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"userVotes":{"karmaVotesList":[],"karmaVotesPagesCount":null,"karmaVotesListLoading":false,"commentsVotesList":[],"commentsVotesPagesCount":null,"commentsVotesListLoading":false,"postsVotesList":[],"postsVotesPagesCount":null,"postsVotesListLoading":false,"userVotesList":[],"userVotesPagesCount":null,"userVotesListLoading":false},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"userSpecialization":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"notificationsLoading":false,"notificationsList":[],"notificationsPageCount":0,"pendingMarkNotificationsRead":[],"publicationsLoading":true,"publicationsList":[],"publicationsPageCount":0,"pendingDeletePublications":false,"pendingMarkPublicationsRead":false},"events":{"eventRefs":{},"eventIds":[],"pagesCount":0,"categories":[],"cities":[],"actualEvents":null,"currentEvent":null,"eventsFilter":{"city":"all","timeStarted":null,"timeEnded":null}},"wysiwyg":{"WYSIWYGRulesRefs":null},"refs":{"specializationRefs":[]},"hint":{"hints":{}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
   <script src="https://assets.habr.com/habr-web/js/chunk-vendors.978df117.js" defer></script>
   <script src="https://assets.habr.com/habr-web/js/app.58b8c457.js" defer></script>
  </div>
  <div id="overlays">
   <!----><!--teleport anchor--><!----><!--teleport anchor--><!----><!--teleport anchor--><!----><!--teleport anchor--><!----><!--teleport anchor--><!----><!--teleport anchor-->
  </div>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-S28W1WC23F"></script>
  <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    </script>
  <script type="text/javascript">
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

  </script>
  <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
 </body>
</html>